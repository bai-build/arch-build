From 372ac89288717a5c256964516b68748e38554e37 Mon Sep 17 00:00:00 2001
From: Roger Ferrer Ibanez <roger.ferrer@bsc.es>
Date: Thu, 11 Jul 2019 22:09:30 +0200
Subject: [PATCH 1/5] Remove old Python 2 support and prioritise Python 3

---
 configure.ac  |  12 ++-
 m4/python2.m4 | 197 --------------------------------------------------
 2 files changed, 9 insertions(+), 200 deletions(-)
 delete mode 100644 m4/python2.m4

diff --git a/configure.ac b/configure.ac
index 284f7a3ba..0cb148c79 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,11 +78,16 @@ AX_CXX_COMPILE_STDCXX_11([noext],[optional])
 dnl Check GNU Bash.
 AC_PATH_PROG([BASH], [bash], [])
 
-dnl Check python 2.7
-AM_PATH_PYTHON2([2.7],, [:])
+dnl Prioritize Python 3.x
+AM_PATH_PYTHON([3.0],, [:])
 
+dnl Fallback to 2.7
 if test "$PYTHON" = ":"; then
-   AC_MSG_ERROR([Python 2.7 not found (note that Python 3 can't be used)])
+   # The earlier result is cached which would make the next check a no-op
+   unset PYTHON
+   unset ac_cv_path_PYTHON
+   unset am_cv_pathless_PYTHON
+   AM_PATH_PYTHON([2.7])
 fi
 
 if test x$BASH = x; then
@@ -2167,6 +2172,7 @@ echo "Mercurium configuration summary"
 echo "==============================="
 echo ""
 echo " * C++ dialect used to build Mercurium : $cxxdialect"
+echo " * Python : $PYTHON (version $PYTHON_VERSION)"
 echo ""
 echo " * Tools configured:"
 echo ""
diff --git a/m4/python2.m4 b/m4/python2.m4
deleted file mode 100644
index 7c11b7b31..000000000
--- a/m4/python2.m4
+++ /dev/null
@@ -1,197 +0,0 @@
-AC_DEFUN([AM_PATH_PYTHON2],
- [
-  dnl Find a Python interpreter.  Python versions prior to 2.0 are not
-  dnl supported. (2.0 was released on October 16, 2000).
-  m4_define_default([_AM_PYTHON_INTERPRETER_LIST],
-[python2 python2.7 python2.6 python2.5 python2.4 python2.3 python2.2 python2.1 python2.0])
-
-  AC_ARG_VAR([PYTHON], [the Python interpreter])
-
-  m4_if([$1],[],[
-    dnl No version check is needed.
-    # Find any Python interpreter.
-    if test -z "$PYTHON"; then
-      AC_PATH_PROGS([PYTHON], _AM_PYTHON_INTERPRETER_LIST, :)
-    fi
-    am_display_PYTHON=python
-  ], [
-    dnl A version check is needed.
-
-    # smateo: 1st round: checking $PYTHON environment variable
-    if test -n "$PYTHON"; then
-      # If the user set $PYTHON, use it and don't search something else.
-      AC_MSG_CHECKING([whether $PYTHON version is >= $1])
-      AM_PYTHON_CHECK_VERSION([$PYTHON], [$1],
-			      [AC_MSG_RESULT([yes])],
-			      [AC_MSG_RESULT([no])
-			       AC_MSG_ERROR([Python interpreter is too old])])
-
-      # smateo: if the user set $PYTHON but its version is Python3, we should ignore it!
-      AC_MSG_CHECKING([whether $PYTHON version is Python3 (unsupported version)])
-      AM_PYTHON_CHECK_VERSION([$PYTHON], [3.0],
-			      [AC_MSG_RESULT([yes])
-			       AC_MSG_WARN([Python3 is not supported, ignoring \$PYTHON environment variable])],
-			      [AC_MSG_RESULT([no])
-			       am_display_PYTHON=$PYTHON])
-    fi
-
-    #smateo: 2nd round, looking for one of the supported python2.X versions
-    if test x"$am_display_PYTHON" = x""; then
-      # Otherwise, try each interpreter until we find one that satisfies VERSION.
-      AC_CACHE_CHECK([for a Python interpreter with version >= $1],
-	[am_cv_pathless_PYTHON],[
-	for am_cv_pathless_PYTHON in _AM_PYTHON_INTERPRETER_LIST none; do
-	  test "$am_cv_pathless_PYTHON" = none && break
-	  AM_PYTHON_CHECK_VERSION([$am_cv_pathless_PYTHON], [$1], [break])
-	done])
-      # Set $PYTHON to the absolute path of $am_cv_pathless_PYTHON.
-      if test "$am_cv_pathless_PYTHON" = none; then
-	PYTHON=:
-      else
-        AC_PATH_PROG([PYTHON], [$am_cv_pathless_PYTHON])
-      fi
-      am_display_PYTHON=$am_cv_pathless_PYTHON
-    fi
-  ])
-
-  if test "$PYTHON" = :; then
-  dnl Run any user-specified action, or abort.
-    m4_default([$3], [AC_MSG_ERROR([no suitable Python interpreter found])])
-  else
-
-  dnl Query Python for its version number.  Getting [:3] seems to be
-  dnl the best way to do this; it's what "site.py" does in the standard
-  dnl library.
-
-  AC_CACHE_CHECK([for $am_display_PYTHON version], [am_cv_python_version],
-    [am_cv_python_version=`$PYTHON -c "import sys; sys.stdout.write(sys.version[[:3]])"`])
-  AC_SUBST([PYTHON_VERSION], [$am_cv_python_version])
-
-  dnl Use the values of $prefix and $exec_prefix for the corresponding
-  dnl values of PYTHON_PREFIX and PYTHON_EXEC_PREFIX.  These are made
-  dnl distinct variables so they can be overridden if need be.  However,
-  dnl general consensus is that you shouldn't need this ability.
-
-  AC_SUBST([PYTHON_PREFIX], ['${prefix}'])
-  AC_SUBST([PYTHON_EXEC_PREFIX], ['${exec_prefix}'])
-
-  dnl At times (like when building shared libraries) you may want
-  dnl to know which OS platform Python thinks this is.
-
-  AC_CACHE_CHECK([for $am_display_PYTHON platform], [am_cv_python_platform],
-    [am_cv_python_platform=`$PYTHON -c "import sys; sys.stdout.write(sys.platform)"`])
-  AC_SUBST([PYTHON_PLATFORM], [$am_cv_python_platform])
-
-  # Just factor out some code duplication.
-  am_python_setup_sysconfig="\
-import sys
-# Prefer sysconfig over distutils.sysconfig, for better compatibility
-# with python 3.x.  See automake bug#10227.
-try:
-    import sysconfig
-except ImportError:
-    can_use_sysconfig = 0
-else:
-    can_use_sysconfig = 1
-# Can't use sysconfig in CPython 2.7, since it's broken in virtualenvs:
-# <https://github.com/pypa/virtualenv/issues/118>
-try:
-    from platform import python_implementation
-    if python_implementation() == 'CPython' and sys.version[[:3]] == '2.7':
-        can_use_sysconfig = 0
-except ImportError:
-    pass"
-
-  dnl Set up 4 directories:
-
-  dnl pythondir -- where to install python scripts.  This is the
-  dnl   site-packages directory, not the python standard library
-  dnl   directory like in previous automake betas.  This behavior
-  dnl   is more consistent with lispdir.m4 for example.
-  dnl Query distutils for this directory.
-  AC_CACHE_CHECK([for $am_display_PYTHON script directory],
-    [am_cv_python_pythondir],
-    [if test "x$prefix" = xNONE
-     then
-       am_py_prefix=$ac_default_prefix
-     else
-       am_py_prefix=$prefix
-     fi
-     am_cv_python_pythondir=`$PYTHON -c "
-$am_python_setup_sysconfig
-if can_use_sysconfig:
-    sitedir = sysconfig.get_path('purelib', vars={'base':'$am_py_prefix'})
-else:
-    from distutils import sysconfig
-    sitedir = sysconfig.get_python_lib(0, 0, prefix='$am_py_prefix')
-sys.stdout.write(sitedir)"`
-     case $am_cv_python_pythondir in
-     $am_py_prefix*)
-       am__strip_prefix=`echo "$am_py_prefix" | sed 's|.|.|g'`
-       am_cv_python_pythondir=`echo "$am_cv_python_pythondir" | sed "s,^$am__strip_prefix,$PYTHON_PREFIX,"`
-       ;;
-     *)
-       case $am_py_prefix in
-         /usr|/System*) ;;
-         *)
-	  am_cv_python_pythondir=$PYTHON_PREFIX/lib/python$PYTHON_VERSION/site-packages
-	  ;;
-       esac
-       ;;
-     esac
-    ])
-  AC_SUBST([pythondir], [$am_cv_python_pythondir])
-
-  dnl pkgpythondir -- $PACKAGE directory under pythondir.  Was
-  dnl   PYTHON_SITE_PACKAGE in previous betas, but this naming is
-  dnl   more consistent with the rest of automake.
-
-  AC_SUBST([pkgpythondir], [\${pythondir}/$PACKAGE])
-
-  dnl pyexecdir -- directory for installing python extension modules
-  dnl   (shared libraries)
-  dnl Query distutils for this directory.
-  AC_CACHE_CHECK([for $am_display_PYTHON extension module directory],
-    [am_cv_python_pyexecdir],
-    [if test "x$exec_prefix" = xNONE
-     then
-       am_py_exec_prefix=$am_py_prefix
-     else
-       am_py_exec_prefix=$exec_prefix
-     fi
-     am_cv_python_pyexecdir=`$PYTHON -c "
-$am_python_setup_sysconfig
-if can_use_sysconfig:
-    sitedir = sysconfig.get_path('platlib', vars={'platbase':'$am_py_prefix'})
-else:
-    from distutils import sysconfig
-    sitedir = sysconfig.get_python_lib(1, 0, prefix='$am_py_prefix')
-sys.stdout.write(sitedir)"`
-     case $am_cv_python_pyexecdir in
-     $am_py_exec_prefix*)
-       am__strip_prefix=`echo "$am_py_exec_prefix" | sed 's|.|.|g'`
-       am_cv_python_pyexecdir=`echo "$am_cv_python_pyexecdir" | sed "s,^$am__strip_prefix,$PYTHON_EXEC_PREFIX,"`
-       ;;
-     *)
-       case $am_py_exec_prefix in
-         /usr|/System*) ;;
-         *)
-	   am_cv_python_pyexecdir=$PYTHON_EXEC_PREFIX/lib/python$PYTHON_VERSION/site-packages
-	   ;;
-       esac
-       ;;
-     esac
-    ])
-  AC_SUBST([pyexecdir], [$am_cv_python_pyexecdir])
-
-  dnl pkgpyexecdir -- $(pyexecdir)/$(PACKAGE)
-
-  AC_SUBST([pkgpyexecdir], [\${pyexecdir}/$PACKAGE])
-
-  dnl Run any user-specified action.
-  $2
-  fi
-
-])
-
-
-- 
2.37.3


From 3e1a9e2846f87ae52a40012c8f5afede6533df07 Mon Sep 17 00:00:00 2001
From: Roger Ferrer Ibanez <roger.ferrer@bsc.es>
Date: Thu, 11 Jul 2019 22:38:03 +0200
Subject: [PATCH 2/5] Update files to Python 3

Used 2to3 and some manual adjustments with string functions that
are now methods of the str type (join and split).
---
 src/frontend/gen-symbol-attrs.py |  278 ++++----
 src/frontend/nodecl-generator.py | 1066 +++++++++++++++---------------
 support/intel_omp/atomic-funs.py |   10 +-
 3 files changed, 676 insertions(+), 678 deletions(-)

diff --git a/src/frontend/gen-symbol-attrs.py b/src/frontend/gen-symbol-attrs.py
index 212f7c565..cdb8b3a57 100755
--- a/src/frontend/gen-symbol-attrs.py
+++ b/src/frontend/gen-symbol-attrs.py
@@ -2,23 +2,23 @@
 
 #  (C) Copyright 2006-2015 Barcelona Supercomputing Center
 #                          Centro Nacional de Supercomputacion
-#  
+#
 #  This file is part of Mercurium C/C++ source-to-source compiler.
-#  
+#
 #  See AUTHORS file in the top level directory for information
 #  regarding developers and contributors.
-#  
+#
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3 of the License, or (at your option) any later version.
-#  
+#
 #  Mercurium C/C++ source-to-source compiler is distributed in the hope
 #  that it will be useful, but WITHOUT ANY WARRANTY; without even the
 #  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 #  PURPOSE.  See the GNU Lesser General Public License for more
 #  details.
-#  
+#
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with Mercurium C/C++ source-to-source compiler; if
 #  not, write to the Free Software Foundation, Inc., 675 Mass Ave,
@@ -55,11 +55,11 @@ def check_file(lines):
   for l in lines:
       fields = l.split("|");
       if len(fields) != 4:
-        raise Exception, "Invalid number of fields"
+        raise Exception("Invalid number of fields")
 
 def get_up_to_matching_paren(s):
     if (s[0] != '('):
-        raise Exception, "String must start with ("
+        raise Exception("String must start with (")
     level = 1
     for i in range(1, len(s)):
         c = s[i]
@@ -71,7 +71,7 @@ def get_up_to_matching_paren(s):
                 return s[1:i]
         else:
             pass
-    raise Exception, "No matching left parent"
+    raise Exception("No matching left parent")
 
 
 class TypeKind:
@@ -126,7 +126,7 @@ def print_type_and_name(_type, name):
             list_name = field_names[1]
         else:
             raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-        return print_type_and_name("integer", num_name) + print_type_and_name("pointer(" + type_name + ")", list_name) 
+        return print_type_and_name("integer", num_name) + print_type_and_name("pointer(" + type_name + ")", list_name)
     else:
         raise Exception("Invalid type %s" % (_type))
 
@@ -146,7 +146,7 @@ def print_entity_specifiers(lines):
       descr = description.strip(" \n")
       decls += print_type_and_name(_type, name)
 
-    print """
+    print("""
 #ifndef CXX_ENTITY_SPECIFIERS_H
 #define CXX_ENTITY_SPECIFIERS_H
 
@@ -154,20 +154,20 @@ def print_entity_specifiers(lines):
 
 // Include this file only from cxx-scope-decls.h and not from anywhere else
 
-typedef struct entity_specifiers_tag\n{"""
+typedef struct entity_specifiers_tag\n{""")
 
     for tk in [TypeKind.OTHER, TypeKind.POINTER, TypeKind.INTEGER, TypeKind.BIT]:
        for d in decls:
          (typename, name, suffix, k) = d
          if k == tk:
-             print indent + typename + " " + name + suffix + ";"
+             print(indent + typename + " " + name + suffix + ";")
 
-    print "} entity_specifiers_t;"
-    print ""
-    print "#endif"
+    print("} entity_specifiers_t;")
+    print("")
+    print("#endif")
 
 def print_getters_setters(lines):
-    print """
+    print("""
 #ifndef CXX_ENTITY_SPECIFIERS_OPS_H
 #define CXX_ENTITY_SPECIFIERS_OPS_H
 
@@ -181,7 +181,7 @@ def print_getters_setters(lines):
 
 // Include this file only from cxx-scope-decls.h and not from anywhere else
 
-"""
+""")
     current_language = "all"
     decls = []
     for l in lines:
@@ -196,10 +196,10 @@ def print_getters_setters(lines):
          if len(decls) != 1:
              raise Exception("Expecting one declaration")
          (typename, name, suffix, k) = decls[0]
-         print "// Single value attribute: '%s' " % (name)
-         print "static inline %s symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (typename, name, name)
-         print "static inline void symbol_entity_specs_set_%s(scope_entry_t* s, %s v)\n{\n    s->_entity_specs.%s = v;\n}" % (name, typename, name)
-         print ""
+         print("// Single value attribute: '%s' " % (name))
+         print("static inline %s symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (typename, name, name))
+         print("static inline void symbol_entity_specs_set_%s(scope_entry_t* s, %s v)\n{\n    s->_entity_specs.%s = v;\n}" % (name, typename, name))
+         print("")
       # Compound types
       elif _type.startswith("array"):
           type_name = get_up_to_matching_paren(_type[len("array"):])
@@ -221,29 +221,29 @@ def print_getters_setters(lines):
           # These types cannot be compared in C
           cannot_be_compared = ["function_parameter_info_t", "gcc_attribute_t"]
 
-          print "// Multiple value attribute: '%s' " % (list_name)
+          print("// Multiple value attribute: '%s' " % (list_name))
           if num_name != "num_" + name:
-              print "// Note: The number of values of this attribute is stored in attribute '%s'" % (num_name)
-          
-          print "static inline int symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (num_name, num_name)
-          print "static inline %s symbol_entity_specs_get_%s_num(scope_entry_t* s, int i)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n        i, s->_entity_specs.%s);\n    return s->_entity_specs.%s[i];\n}" % (type_name, list_name, num_name, num_name, list_name)
-          print "static inline void symbol_entity_specs_set_%s_num(scope_entry_t* s, int i, %s v)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n         i, s->_entity_specs.%s);\n    s->_entity_specs.%s[i] = v;\n}" % (list_name, type_name, num_name, num_name, list_name)
-          print "static inline void symbol_entity_specs_append_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name)
+              print("// Note: The number of values of this attribute is stored in attribute '%s'" % (num_name))
+
+          print("static inline int symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (num_name, num_name))
+          print("static inline %s symbol_entity_specs_get_%s_num(scope_entry_t* s, int i)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n        i, s->_entity_specs.%s);\n    return s->_entity_specs.%s[i];\n}" % (type_name, list_name, num_name, num_name, list_name))
+          print("static inline void symbol_entity_specs_set_%s_num(scope_entry_t* s, int i, %s v)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n         i, s->_entity_specs.%s);\n    s->_entity_specs.%s[i] = v;\n}" % (list_name, type_name, num_name, num_name, list_name))
+          print("static inline void symbol_entity_specs_append_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
           if type_name not in cannot_be_compared:
-              print "static inline void symbol_entity_specs_remove_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_REMOVE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name)
-              print "static inline void symbol_entity_specs_insert_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD_ONCE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name)
-          print "static inline void symbol_entity_specs_remove_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_REMOVE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name)
-          print "static inline void symbol_entity_specs_insert_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_ADD_ONCE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name)
-          print "static inline void symbol_entity_specs_add_%s(scope_entry_t* s, %s item)\n{\n    symbol_entity_specs_append_%s(s, item);\n}" % (list_name, type_name, list_name)
-          print "static inline void symbol_entity_specs_reserve_%s(scope_entry_t* s, int num)\n{\n    s->_entity_specs.%s = num;\n    s->_entity_specs.%s = NEW_VEC0(%s, num);\n}" % (list_name, num_name, list_name, type_name)
+              print("static inline void symbol_entity_specs_remove_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_REMOVE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
+              print("static inline void symbol_entity_specs_insert_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD_ONCE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
+          print("static inline void symbol_entity_specs_remove_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_REMOVE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name))
+          print("static inline void symbol_entity_specs_insert_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_ADD_ONCE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name))
+          print("static inline void symbol_entity_specs_add_%s(scope_entry_t* s, %s item)\n{\n    symbol_entity_specs_append_%s(s, item);\n}" % (list_name, type_name, list_name))
+          print("static inline void symbol_entity_specs_reserve_%s(scope_entry_t* s, int num)\n{\n    s->_entity_specs.%s = num;\n    s->_entity_specs.%s = NEW_VEC0(%s, num);\n}" % (list_name, num_name, list_name, type_name))
           # print "static inline void symbol_entity_specs_clear_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = NULL;\n    s->_entity_specs.%s = 0;\n}" % (list_name, list_name, num_name)
-          print "static inline void symbol_entity_specs_free_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = 0;\n    DELETE(s->_entity_specs.%s);\n    s->_entity_specs.%s = NULL;\n}" % (list_name, num_name, list_name, list_name)
-          print "static inline void symbol_entity_specs_copy_%s_from(scope_entry_t* dest, scope_entry_t* source)\n{\n    symbol_entity_specs_reserve_%s(dest, source->_entity_specs.%s);\n    memcpy(dest->_entity_specs.%s,\n        source->_entity_specs.%s,\n        dest->_entity_specs.%s\n        * (sizeof (*(dest->_entity_specs.%s))));\n} " % (list_name, list_name, num_name, list_name, list_name, num_name, list_name)
-          print ""
+          print("static inline void symbol_entity_specs_free_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = 0;\n    DELETE(s->_entity_specs.%s);\n    s->_entity_specs.%s = NULL;\n}" % (list_name, num_name, list_name, list_name))
+          print("static inline void symbol_entity_specs_copy_%s_from(scope_entry_t* dest, scope_entry_t* source)\n{\n    symbol_entity_specs_reserve_%s(dest, source->_entity_specs.%s);\n    memcpy(dest->_entity_specs.%s,\n        source->_entity_specs.%s,\n        dest->_entity_specs.%s\n        * (sizeof (*(dest->_entity_specs.%s))));\n} " % (list_name, list_name, num_name, list_name, list_name, num_name, list_name))
+          print("")
 
-    print "static inline void symbol_entity_specs_copy_from(scope_entry_t* dest, scope_entry_t* source)"
-    print "{"
-    print "    dest->_entity_specs = source->_entity_specs;"
+    print("static inline void symbol_entity_specs_copy_from(scope_entry_t* dest, scope_entry_t* source)")
+    print("{")
+    print("    dest->_entity_specs = source->_entity_specs;")
     # Now copy every list
     for l in lines:
       fields = l.split("|");
@@ -261,11 +261,11 @@ def print_getters_setters(lines):
               list_name = field_names[1]
           else:
               raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-          print "    symbol_entity_specs_copy_%s_from(dest, source);" % (list_name)
-    print "}"
-    print ""
-    print "static inline void symbol_entity_specs_free(scope_entry_t* symbol)"
-    print "{"
+          print("    symbol_entity_specs_copy_%s_from(dest, source);" % (list_name))
+    print("}")
+    print("")
+    print("static inline void symbol_entity_specs_free(scope_entry_t* symbol)")
+    print("{")
     # Now copy every list
     for l in lines:
       fields = l.split("|");
@@ -283,10 +283,10 @@ def print_getters_setters(lines):
               list_name = field_names[1]
           else:
               raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-          print "    symbol_entity_specs_free_%s(symbol);" % (list_name)
-    print "}"
+          print("    symbol_entity_specs_free_%s(symbol);" % (list_name))
+    print("}")
 
-    print "#endif"
+    print("#endif")
 
 def insert_extra_attr_code(_type, name, getter, getter_extra_args):
     _insert_code = []
@@ -317,9 +317,7 @@ def insert_extra_attr_code(_type, name, getter, getter_extra_args):
             raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
         _insert_code.append("{ int i; for (i = 0; i < symbol_entity_specs_get_%s(sym); i++) {" % (num_name));
         _insert_code.append(
-                string.join(
-                    insert_extra_attr_code(type_name, list_name, "symbol_entity_specs_get_%s_num" % (list_name), ", i"), "\n")
-                );
+                    "\n".join(insert_extra_attr_code(type_name, list_name, "symbol_entity_specs_get_%s_num" % (list_name), ", i")))
         _insert_code.append("} }");
     elif (_type.startswith("typeof")):
         type_name = get_up_to_matching_paren(_type[len("typeof"):])
@@ -424,7 +422,7 @@ def get_extra_load_code(_type, num_name, list_name):
             pass
     else:
         sys.stderr.write("%s:%d: warning: unknown array type '%s'\n" % (sys.argv[0], lineno(), _type))
-    return string.join(result, "\n");
+    return "\n".join(result);
 
 def get_load_code(_type, name):
     result = []
@@ -509,7 +507,7 @@ def get_load_code(_type, name):
         sys.stderr.write("%s:%d: warning: not handling '%s'\n" % (sys.argv[0], lineno(), type_name))
         pass
     result.append("}");
-    return string.join(result, "\n");
+    return "\n".join(result);
 
 
 def print_fortran_modules_functions(lines):
@@ -571,19 +569,19 @@ def print_fortran_modules_functions(lines):
                 sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" % (sys.argv[0], lineno(), type_name))
       else:
           pass
-    print "#ifndef FORTRAN03_MODULES_BITS_H"
-    print "#define FORTRAN03_MODULES_BITS_H"
-    print ""
-    print "static const char * attr_field_names = \"" + string.join(attr_names, ", ") + "\";";
-    print "static char * symbol_get_attribute_values(sqlite3* handle, scope_entry_t* sym)"
-    print "{"
-    print "    const char *format = \"" + string.join(_format, ", ") + "\";"
-    print ""
-    print string.join(_insert_code, "\n");
-    print ""
-    print "    char * result = sqlite3_mprintf(format, " + string.join(sprintf_arguments, ", ") + ");"
-    print "    return result;"
-    print "}"
+    print("#ifndef FORTRAN03_MODULES_BITS_H")
+    print("#define FORTRAN03_MODULES_BITS_H")
+    print("")
+    print("static const char * attr_field_names = \"" + ", ".join(attr_names) + "\";");
+    print("static char * symbol_get_attribute_values(sqlite3* handle, scope_entry_t* sym)")
+    print("{")
+    print("    const char *format = \"" + ", ".join(_format) + "\";")
+    print("")
+    print("\n".join(_insert_code));
+    print("")
+    print("    char * result = sqlite3_mprintf(format, " + ", ".join(sprintf_arguments) + ");")
+    print("    return result;")
+    print("}")
     _extra_attr_code = []
     for l in lines:
       fields = l.split("|");
@@ -594,45 +592,45 @@ def print_fortran_modules_functions(lines):
           _extra_attr_code = _extra_attr_code + insert_extra_attr_code(_type, name, "", "")
       else:
            pass
-    print "static void insert_extended_attributes(sqlite3* handle, scope_entry_t* sym)"
-    print "{"
-    print string.join(_extra_attr_code, "\n");
-    print "}"
-    print ""
-    print "static void get_extra_attributes(sqlite3* handle, int ncols, char **values, char **names, sqlite3_uint64 sym_oid, scope_entry_t* sym)"
-    print "{"
+    print("static void insert_extended_attributes(sqlite3* handle, scope_entry_t* sym)")
+    print("{")
+    print("\n".join(_extra_attr_code));
+    print("}")
+    print("")
+    print("static void get_extra_attributes(sqlite3* handle, int ncols, char **values, char **names, sqlite3_uint64 sym_oid, scope_entry_t* sym)")
+    print("{")
     for l in lines:
       fields = l.split("|");
       (_type,language,name,description) = fields
       if name[0] == "*":
           continue;
-      print get_load_code(_type, name)
-    print "}"
+      print(get_load_code(_type, name))
+    print("}")
 
-    print "typedef struct module_packed_bits_tag"
-    print "{"
+    print("typedef struct module_packed_bits_tag")
+    print("{")
     for l in lines:
       fields = l.split("|");
       (_type,language,name,description) = fields
       if name[1] == "*":
           continue;
       if _type == "bool":
-          print "_Bool %s:1;" % (name)
-    print "} module_packed_bits_t;"
+          print("_Bool %s:1;" % (name))
+    print("} module_packed_bits_t;")
 
-    print "static module_packed_bits_t synthesize_packed_bits(scope_entry_t* sym)"
-    print "{"
-    print "module_packed_bits_t result;"
-    print "memset(&result, 0, sizeof(result));"
+    print("static module_packed_bits_t synthesize_packed_bits(scope_entry_t* sym)")
+    print("{")
+    print("module_packed_bits_t result;")
+    print("memset(&result, 0, sizeof(result));")
     for l in lines:
       fields = l.split("|");
       (_type,language,name,description) = fields
       if name[1] == "*":
           continue;
       if _type == "bool":
-          print "result.%s = symbol_entity_specs_get_%s(sym);" % (name, name)
-    print "return result;"
-    print "}"
+          print("result.%s = symbol_entity_specs_get_%s(sym);" % (name, name))
+    print("return result;")
+    print("}")
 
     # print "static void unpack_bits(entity_specifiers_t *_entity_specs, module_packed_bits_t bitpack)"
     # print "{"
@@ -645,35 +643,35 @@ def print_fortran_modules_functions(lines):
     #       print "_entity_specs->%s = bitpack.%s;" % (name, name)
     # print "}"
 
-    print "static void unpack_bits(scope_entry_t *sym, module_packed_bits_t bitpack)"
-    print "{"
+    print("static void unpack_bits(scope_entry_t *sym, module_packed_bits_t bitpack)")
+    print("{")
     for l in lines:
       fields = l.split("|");
       (_type,language,name,description) = fields
       if name[1] == "*":
           continue;
       if _type == "bool":
-          print "symbol_entity_specs_set_%s(sym, bitpack.%s);" % (name, name)
-    print "}"
+          print("symbol_entity_specs_set_%s(sym, bitpack.%s);" % (name, name))
+    print("}")
 
-    print "#endif // FORTRAN03_MODULES_BITS_H"
+    print("#endif // FORTRAN03_MODULES_BITS_H")
 
 
 def print_deep_copy_entity_specs(lines):
-    print "// DO NOT MODIFY THIS FILE."
-    print "// It will be overwritten when gen-symbols-attrs.py or cxx-entity_specs.def are modified"
-    print "#include \"cxx-scope.h\""
-    print "#include \"cxx-nodecl-deep-copy.h\""
-    print "#include \"cxx-typeutils.h\""
-    print "#include \"string_utils.h\""
-
-    print """
+    print("// DO NOT MODIFY THIS FILE.")
+    print("// It will be overwritten when gen-symbols-attrs.py or cxx-entity_specs.def are modified")
+    print("#include \"cxx-scope.h\"")
+    print("#include \"cxx-nodecl-deep-copy.h\"")
+    print("#include \"cxx-typeutils.h\"")
+    print("#include \"string_utils.h\"")
+
+    print("""
     void symbol_deep_copy_entity_specs(scope_entry_t* dest, scope_entry_t* source,
              const decl_context_t* decl_context, symbol_map_t* symbol_map,
              nodecl_deep_copy_map_t* nodecl_deep_copy_map,
              symbol_deep_copy_map_t* symbol_deep_copy_map)
     {
-    """
+    """)
     for l in lines:
       fields = l.split("|");
       (_type,language,name,description) = fields
@@ -681,24 +679,24 @@ def print_deep_copy_entity_specs(lines):
           name = name[1:]
           continue
       if name == "function_code":
-          print "// We do not copy function code!"
+          print("// We do not copy function code!")
           continue
       if _type in ["bool", "integer"]:
-          print "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name)
+          print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
       elif (_type == "scope"):
-          print "symbol_entity_specs_set_%s(dest, decl_context);"
+          print("symbol_entity_specs_set_%s(dest, decl_context);")
       elif (_type == "nodecl"):
-          print "symbol_entity_specs_set_%s(dest, nodecl_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name)
+          print("symbol_entity_specs_set_%s(dest, nodecl_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name))
       elif (_type == "type"):
-          print "symbol_entity_specs_set_%s(dest, type_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), /* symbol dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name)
+          print("symbol_entity_specs_set_%s(dest, type_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), /* symbol dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name))
       elif (_type == "symbol"):
-          print "symbol_entity_specs_set_%s(dest, symbol_map->map(symbol_map, symbol_entity_specs_get_%s(source)));" % (name, name)
+          print("symbol_entity_specs_set_%s(dest, symbol_map->map(symbol_map, symbol_entity_specs_get_%s(source)));" % (name, name))
       elif (_type == "string"):
-          print "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name)
+          print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
       elif (_type.startswith("typeof")):
             type_name = get_up_to_matching_paren(_type[len("typeof"):]).split(",")[0].strip()
             if type_name in ["intent_kind_t", "access_specifier_t", "_size_t", "simplify_function_t"]:
-                print "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name)
+                print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
             else:
                 sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" % (sys.argv[0], lineno(), type_name))
       elif (_type.startswith("array")):
@@ -714,52 +712,52 @@ def print_deep_copy_entity_specs(lines):
               raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
           if type_name.startswith("typeof"):
               type_name = get_up_to_matching_paren(type_name[len("typeof"):]).split(",")[0].strip()
-          print "{"
-          print "symbol_entity_specs_free_%s(dest);" % (list_name)
-          print "int i, N = symbol_entity_specs_get_%s(source);" % (num_name)
-          print "for (i = 0; i < N; i++)"
-          print "{"
+          print("{")
+          print("symbol_entity_specs_free_%s(dest);" % (list_name))
+          print("int i, N = symbol_entity_specs_get_%s(source);" % (num_name))
+          print("for (i = 0; i < N; i++)")
+          print("{")
           if type_name == "symbol":
-              print "scope_entry_t* copied = symbol_map->map(symbol_map, symbol_entity_specs_get_%s_num(source, i));" % (list_name)
-              print "symbol_entity_specs_add_%s(dest, copied);" % (list_name);
+              print("scope_entry_t* copied = symbol_map->map(symbol_map, symbol_entity_specs_get_%s_num(source, i));" % (list_name))
+              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name));
           elif type_name == "type":
-              print "type_t* copied = type_deep_copy_compute_maps(symbol_entity_specs_get_%s_num(source, i), /* dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (list_name)
-              print "symbol_entity_specs_add_%s(dest, copied);" % (list_name);
+              print("type_t* copied = type_deep_copy_compute_maps(symbol_entity_specs_get_%s_num(source, i), /* dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (list_name))
+              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name));
           elif type_name == "default_argument_info_t*":
-                  print "default_argument_info_t* source_default_arg = symbol_entity_specs_get_%s_num(source, i);" % (list_name)
-                  print "default_argument_info_t* copied = NULL;"
-                  print "if (source_default_arg != NULL)"
-                  print "{"
-                  print "  copied = NEW0(default_argument_info_t);"
-                  print "  copied->argument = nodecl_deep_copy_compute_maps(source_default_arg->argument, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
-                  print "  copied->context = decl_context;"
-                  print "}"
-                  print "symbol_entity_specs_add_%s(dest, copied);" % (list_name)
+                  print("default_argument_info_t* source_default_arg = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
+                  print("default_argument_info_t* copied = NULL;")
+                  print("if (source_default_arg != NULL)")
+                  print("{")
+                  print("  copied = NEW0(default_argument_info_t);")
+                  print("  copied->argument = nodecl_deep_copy_compute_maps(source_default_arg->argument, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
+                  print("  copied->context = decl_context;")
+                  print("}")
+                  print("symbol_entity_specs_add_%s(dest, copied);" % (list_name))
           elif type_name == "gcc_attribute_t":
-              print "gcc_attribute_t source_gcc_attr = symbol_entity_specs_get_%s_num(source, i);" % (list_name)
-              print "gcc_attribute_t copied;"
-              print "copied.attribute_name = source_gcc_attr.attribute_name;"
-              print "copied.expression_list = nodecl_deep_copy_compute_maps(source_gcc_attr.expression_list, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
-              print "symbol_entity_specs_add_%s(dest, copied);" % (list_name)
+              print("gcc_attribute_t source_gcc_attr = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
+              print("gcc_attribute_t copied;")
+              print("copied.attribute_name = source_gcc_attr.attribute_name;")
+              print("copied.expression_list = nodecl_deep_copy_compute_maps(source_gcc_attr.expression_list, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
+              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name))
           elif type_name == "function_parameter_info_t":
-              print "function_parameter_info_t param_info = symbol_entity_specs_get_%s_num(source, i);" % (list_name)
-              print "param_info.function = symbol_map->map(symbol_map, param_info.function);"
-              print "symbol_entity_specs_add_%s(dest, param_info);" % (list_name)
+              print("function_parameter_info_t param_info = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
+              print("param_info.function = symbol_map->map(symbol_map, param_info.function);")
+              print("symbol_entity_specs_add_%s(dest, param_info);" % (list_name))
           else:
               sys.stderr.write("%s:%d: warning: not handling type array of type '%s'\n" % (sys.argv[0], lineno(), _type))
-          print "}"
-          print "}"
+          print("}")
+          print("}")
       else:
           sys.stderr.write("%s:%d: warning: not handling type '%s'\n" % (sys.argv[0], lineno(), _type))
-    print """
+    print("""
     }
-    """
+    """)
 
 lines = loadlines(f)
 check_file(lines)
 
-print "/* This file has been generated by gen-symbols-attrs.py. */" 
-print "/* Do not modify it or you'll get what you deserve */"
+print("/* This file has been generated by gen-symbols-attrs.py. */")
+print("/* Do not modify it or you'll get what you deserve */")
 
 if op == "entity_specifiers":
     print_entity_specifiers(lines)
diff --git a/src/frontend/nodecl-generator.py b/src/frontend/nodecl-generator.py
index 8ced793c6..2a4ed9a9f 100755
--- a/src/frontend/nodecl-generator.py
+++ b/src/frontend/nodecl-generator.py
@@ -1,24 +1,24 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 
-#  (C) Copyright 2006-2015 Barcelona Supercomputing Center
+#  (C) Copyright 2006-2019 Barcelona Supercomputing Center
 #                          Centro Nacional de Supercomputacion
-#  
+#
 #  This file is part of Mercurium C/C++ source-to-source compiler.
-#  
+#
 #  See AUTHORS file in the top level directory for information
 #  regarding developers and contributors.
-#  
+#
 #  This library is free software; you can redistribute it and/or
 #  modify it under the terms of the GNU Lesser General Public
 #  License as published by the Free Software Foundation; either
 #  version 3 of the License, or (at your option) any later version.
-#  
+#
 #  Mercurium C/C++ source-to-source compiler is distributed in the hope
 #  that it will be useful, but WITHOUT ANY WARRANTY; without even the
 #  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 #  PURPOSE.  See the GNU Lesser General Public License for more
 #  details.
-#  
+#
 #  You should have received a copy of the GNU Lesser General Public
 #  License along with Mercurium C/C++ source-to-source compiler; if
 #  not, write to the Free Software Foundation, Inc., 675 Mass Ave,
@@ -53,9 +53,9 @@ def find_matching_parentheses(s):
 
 def parse_rules(f):
     lines = loadlines(f)
-    
+
     rule_set = []
-    
+
     rule_name = ""
     rule_rhs = []
     for l in lines:
@@ -70,14 +70,14 @@ def parse_rules(f):
     # Last rule
     if (rule_name != "") :
        rule_set.append( (rule_name, rule_rhs) )
-    
+
     regex_name = re.compile("\[([_A-Za-z][_*A-Za-z0-9]*)\]\s*([-_A-Za-z0-9]+)")
     rule_map = { }
     rule_map["any"] = []
     for r in rule_set:
         (rule_name, rule_rhs) = r
         if rule_name not in rule_map:
-            rule_map[rule_name] = [] 
+            rule_map[rule_name] = []
         for rhs in rule_rhs:
             # Assume this is a NODECL_ name
             if (rhs[0:len(NODECL_PREFIX)] == NODECL_PREFIX):
@@ -104,7 +104,7 @@ def parse_rules(f):
                 #      ...
                 for (base_var_name, attr) in attributes:
                     statement = "needs_%s = \"%s\" in remaining_flags" % (base_var_name, attr)
-                    exec statement
+                    exec(statement)
 
                 # Optional values
                 # This exec below perfoms the following statements
@@ -113,7 +113,7 @@ def parse_rules(f):
                 #      ...
                 for (base_var_name, attr) in attributes:
                     statement = "may_have_%s = \"%s-opt\" in remaining_flags" % (base_var_name, attr)
-                    exec statement
+                    exec(statement)
 
                 # Module
                 module_name = "base"
@@ -126,7 +126,7 @@ def parse_rules(f):
                         module_name = flag[i+1: i + j].strip()
 
                 if ast_args :
-                    ast_args_2 = map(lambda x : x.strip(), ast_args.split(","))
+                    ast_args_2 = [x.strip() for x in ast_args.split(",")]
                     ast_args_3 = []
                     i = 0
                     for x in ast_args_2:
@@ -222,28 +222,28 @@ class NodeclStructure(Variable):
     def call_to_check(self, tree_name):
         return "%s(%s);" % (self.check_function_name(), tree_name);
     def function_check_code(self):
-        print "static void %s(nodecl_t n)" % (self.check_function_name())
-        print "{"
-        print "ERROR_CONDITION(nodecl_is_null(n), \"Node is null\", 0);"
-        print "ERROR_CONDITION(nodecl_get_kind(n) != %s, \"Invalid node\", 0);" % self.name_to_underscore()
+        print("static void %s(nodecl_t n)" % (self.check_function_name()))
+        print("{")
+        print("ERROR_CONDITION(nodecl_is_null(n), \"Node is null\", 0);")
+        print("ERROR_CONDITION(nodecl_get_kind(n) != %s, \"Invalid node\", 0);" % self.name_to_underscore())
         if (self.needs_symbol):
-           print "   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, \"Tree lacks a symbol\", 0);" 
+           print("   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, \"Tree lacks a symbol\", 0);")
         if (self.needs_type):
-           print "   ERROR_CONDITION(nodecl_get_type(n) == NULL, \"Tree lacks a type\", 0);" 
+           print("   ERROR_CONDITION(nodecl_get_type(n) == NULL, \"Tree lacks a type\", 0);")
         if (self.needs_text):
-           print "   ERROR_CONDITION(nodecl_get_text(n) == NULL, \"Tree lacks an associated text\", 0);" 
+           print("   ERROR_CONDITION(nodecl_get_text(n) == NULL, \"Tree lacks an associated text\", 0);")
         if (self.needs_cval):
-           print "   ERROR_CONDITION(nodecl_get_constant(n) == NULL, \"Tree lacks a constant value\", 0);" 
+           print("   ERROR_CONDITION(nodecl_get_constant(n) == NULL, \"Tree lacks a constant value\", 0);")
         i = 0
         for subtree in self.subtrees:
            (rule_label, rule_ref) = subtree
 
            current_rule = RuleRef(rule_ref)
 
-           print current_rule.call_to_check("nodecl_get_child(n, %d)" % (i));
+           print(current_rule.call_to_check("nodecl_get_child(n, %d)" % (i)));
 
            i = i + 1
-        print "}"
+        print("}")
 
 class RuleRef(Variable):
     def __init__(self, rule_ref):
@@ -253,7 +253,7 @@ class RuleRef(Variable):
         is_opt = rule_ref.find("-opt") > 0
         rule_ref = rule_ref.replace("-seq", "").replace("-opt", "")
         rule_ref_c = rule_ref.replace("-", "_").replace("*", "_")
-        return (rule_ref, rule_ref_c, is_seq, is_opt) 
+        return (rule_ref, rule_ref_c, is_seq, is_opt)
     def canonical_rule(self):
         (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
         return rule_ref
@@ -300,12 +300,12 @@ class RuleRef(Variable):
     def call_to_check(self, tree_name):
         if self.is_nullable():
             if self.is_seq():
-               return "nodecl_check_nullable_list_rule(%s, %s);" % (tree_name, self.check_function_name()) 
+               return "nodecl_check_nullable_list_rule(%s, %s);" % (tree_name, self.check_function_name())
             else:
                return "nodecl_check_nullable_rule(%s, %s);" % (tree_name, self.check_function_name())
         else:
             if self.is_seq():
-               return "nodecl_check_list_rule(%s, %s);" % (tree_name, self.check_function_name()) 
+               return "nodecl_check_list_rule(%s, %s);" % (tree_name, self.check_function_name())
             else:
                return "%s(%s);" % (self.check_function_name(), tree_name)
     def function_check_code(self):
@@ -313,30 +313,30 @@ class RuleRef(Variable):
             raise Exception("Do not call this on non canonical rules")
 
         rule_set = rule_map[self.rule_ref]
-        print "static void %s(nodecl_t n)" % (self.check_function_name())
-        print "{"
-        print "ERROR_CONDITION(nodecl_is_null(n), \"Node is null\", 0);"
-        print "switch (nodecl_get_kind(n))"
-        print "{"
+        print("static void %s(nodecl_t n)" % (self.check_function_name()))
+        print("{")
+        print("ERROR_CONDITION(nodecl_is_null(n), \"Node is null\", 0);")
+        print("switch (nodecl_get_kind(n))")
+        print("{")
         for rhs in rule_set:
             first_set = rhs.first()
             if not first_set:
                raise Exception("First is empty!")
             for first in first_set:
-                print "case %s:" % (first)
-            print "{"
-            print rhs.call_to_check("n");
-            print "break;"
-            print "}"
+                print("case %s:" % (first))
+            print("{")
+            print(rhs.call_to_check("n"));
+            print("break;")
+            print("}")
 
-        print "default:"
-        print "{"
-        print "internal_error(\"Node of kind %s not valid\", ast_print_node_type(nodecl_get_kind(n)));"
-        print "break;"
-        print "}"
-        print "}"
+        print("default:")
+        print("{")
+        print("internal_error(\"Node of kind %s not valid\", ast_print_node_type(nodecl_get_kind(n)));")
+        print("break;")
+        print("}")
+        print("}")
 
-        print "}"
+        print("}")
 
 def get_all_nodecl_structs():
     node_kind_set = set([])
@@ -351,54 +351,54 @@ def get_all_nodecl_structs():
     return nodes
 
 def generate_check_routines(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print ""
-    print "#include \"cxx-nodecl.h\""
-    print "#include \"cxx-utils.h\""
-    print "#include \"cxx-exprtype.h\""
-    print "#include \"mem.h\""
-    print ""
-    print "static inline void nodecl_check_nullable_rule(nodecl_t n, void (*fun)(nodecl_t))"
-    print "{"
-    print "   if (nodecl_is_null(n)) return;"
-    print "   fun(n);"
-    print "}"
-    print "static inline void nodecl_check_list_rule(nodecl_t n, void (*fun)(nodecl_t))"
-    print "{"
-    print "   ERROR_CONDITION(!nodecl_is_list(n), \"Node must be a list\", 0);"
-    print "   int num_items = 0;"
-    print "   nodecl_t* list = nodecl_unpack_list(n, &num_items);"
-    print "   int i;"
-    print "   for (i = 0; i < num_items; i++)"
-    print "   {"
-    print "      fun(list[i]);"
-    print "   }"
-    print "   DELETE(list);"
-    print "}"
-    print "static inline void nodecl_check_nullable_list_rule(nodecl_t n, void (*fun)(nodecl_t))"
-    print "{"
-    print "   if (nodecl_is_null(n)) return;"
-    print "   nodecl_check_list_rule(n, fun);"
-    print "}"
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("")
+    print("#include \"cxx-nodecl.h\"")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"cxx-exprtype.h\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("static inline void nodecl_check_nullable_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print("{")
+    print("   if (nodecl_is_null(n)) return;")
+    print("   fun(n);")
+    print("}")
+    print("static inline void nodecl_check_list_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print("{")
+    print("   ERROR_CONDITION(!nodecl_is_list(n), \"Node must be a list\", 0);")
+    print("   int num_items = 0;")
+    print("   nodecl_t* list = nodecl_unpack_list(n, &num_items);")
+    print("   int i;")
+    print("   for (i = 0; i < num_items; i++)")
+    print("   {")
+    print("      fun(list[i]);")
+    print("   }")
+    print("   DELETE(list);")
+    print("}")
+    print("static inline void nodecl_check_nullable_list_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print("{")
+    print("   if (nodecl_is_null(n)) return;")
+    print("   nodecl_check_list_rule(n, fun);")
+    print("}")
 
     nodes = get_all_nodecl_structs()
     for node in nodes:
-        print "static void %s(nodecl_t);" % (node.check_function_name())
+        print("static void %s(nodecl_t);" % (node.check_function_name()))
 
     for rule_name in rule_map:
-        print "static void %s(nodecl_t);" % ( RuleRef(rule_name).check_function_name() )
-    print ""
+        print("static void %s(nodecl_t);" % ( RuleRef(rule_name).check_function_name() ))
+    print("")
     for node in nodes:
         node.function_check_code()
     for rule_name in rule_map:
         RuleRef(rule_name).function_check_code()
 
-    print "void nodecl_check_tree(AST a)"
-    print "{"
-    print     "nodecl_check_nodecl(_nodecl_wrap(a));"
-    print "}"
-    
+    print("void nodecl_check_tree(AST a)")
+    print("{")
+    print("nodecl_check_nodecl(_nodecl_wrap(a));")
+    print("}")
+
 
 def from_underscore_to_camel_case(x):
     result = ''
@@ -459,7 +459,7 @@ def get_all_class_names_and_children_names(rule_map):
                 class_name = from_underscore_to_camel_case(rhs.base_name())
                 if class_name not in classes_set:
                     classes_set.add(class_name)
-                    subtrees = map(lambda x : x[0], rhs.subtrees)
+                    subtrees = [x[0] for x in rhs.subtrees]
                     result.append((class_name, subtrees, rhs.name_to_underscore(), rhs))
     return result
 
@@ -473,7 +473,7 @@ def get_all_class_names_and_children_names_namespaces(rule_map):
                 class_name = from_underscore_to_camel_case_namespaces(rhs.base_name())
                 if class_name not in classes_set:
                     classes_set.add(class_name)
-                    subtrees = map(lambda x : x[0], rhs.subtrees)
+                    subtrees = [x[0] for x in rhs.subtrees]
                     result.append((class_name, subtrees, rhs.name_to_underscore(), rhs))
     return result
 
@@ -488,176 +488,176 @@ def get_all_class_names_and_children_names_namespaces_and_modules(rule_map):
                 module_name = rhs.module_name
                 if class_name not in classes_set:
                     classes_set.add(class_name)
-                    subtrees = map(lambda x : x[0], rhs.subtrees)
+                    subtrees = [x[0] for x in rhs.subtrees]
                     result.append((class_name, subtrees, rhs.name_to_underscore(), rhs, module_name))
     return result
 
 def generate_nodecl_classes_fwd_decls(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print "#ifndef TL_NODECL_FWD_HPP"
-    print "#define TL_NODECL_FWD_HPP"
-    print ""
-    print "#include \"tl-nodecl-base-fwd.hpp\""
-    print "#include \"mem.h\""
-    print ""
-    print "namespace Nodecl {"
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("#ifndef TL_NODECL_FWD_HPP")
+    print("#define TL_NODECL_FWD_HPP")
+    print("")
+    print("#include \"tl-nodecl-base-fwd.hpp\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("namespace Nodecl {")
     classes = get_all_class_names_and_namespaces(rule_map)
     for (namespaces, class_name) in classes:
         for namespace in namespaces:
-            print "namespace %s { " % (namespace)
-        print "class %s;" % (class_name)
+            print("namespace %s { " % (namespace))
+        print("class %s;" % (class_name))
         for namespace in namespaces:
-            print "}"
-    print ""
-    print "} // Nodecl"
-    print "#endif // TL_NODECL_FWD_HPP"
+            print("}")
+    print("")
+    print("} // Nodecl")
+    print("#endif // TL_NODECL_FWD_HPP")
 
 def get_qualified_name(namespaces, name):
-    return string.join(list(namespaces) + [name], "::")
+    return "::".join(list(namespaces) + [name])
 
 def generate_visitor_class_header(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print "#ifndef TL_NODECL_VISITOR_HPP"
-    print "#define TL_NODECL_VISITOR_HPP"
-    print ""
-    print "#include <tl-objectlist.hpp>"
-    print "#include <tl-nodecl.hpp>"
-    print "#include \"cxx-utils.h\""
-    print "#include \"mem.h\""
-    print ""
-    print "namespace Nodecl {"
-    print ""
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("#ifndef TL_NODECL_VISITOR_HPP")
+    print("#define TL_NODECL_VISITOR_HPP")
+    print("")
+    print("#include <tl-objectlist.hpp>")
+    print("#include <tl-nodecl.hpp>")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("namespace Nodecl {")
+    print("")
     classes = get_all_class_names_and_namespaces(rule_map)
-    print "template <typename _Ret>"
-    print "class BaseNodeclVisitor;"
-    print "template <>"
-    print "class BaseNodeclVisitor<void>;"
-    print ""
-    print "template <typename _Ret>"
-    print "class BaseNodeclVisitor"
-    print "{"
-    print "   public:"
-    print "     typedef _Ret Ret;"
-    print "     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */"
+    print("template <typename _Ret>")
+    print("class BaseNodeclVisitor;")
+    print("template <>")
+    print("class BaseNodeclVisitor<void>;")
+    print("")
+    print("template <typename _Ret>")
+    print("class BaseNodeclVisitor")
+    print("{")
+    print("   public:")
+    print("     typedef _Ret Ret;")
+    print("     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */")
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print "     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name)
-    print "   virtual _Ret join_list(TL::ObjectList<_Ret> &) = 0;"
-    print "   virtual ~BaseNodeclVisitor() { }"
-    print "};"
-    print "template <>"
-    print "class BaseNodeclVisitor<void>"
-    print "{"
-    print "   public:"
-    print "     typedef void Ret;"
-    print "     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */"
+        print("     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name))
+    print("   virtual _Ret join_list(TL::ObjectList<_Ret> &) = 0;")
+    print("   virtual ~BaseNodeclVisitor() { }")
+    print("};")
+    print("template <>")
+    print("class BaseNodeclVisitor<void>")
+    print("{")
+    print("   public:")
+    print("     typedef void Ret;")
+    print("     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */")
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print "     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name)
-    print "   virtual ~BaseNodeclVisitor() { }"
-    print "};"
-    print "template <typename _Ret>"
-    print "class UnhandledNodeclVisitor : public BaseNodeclVisitor<_Ret>"
-    print "{"
-    print "   public:"
-    print "     typedef typename BaseNodeclVisitor<_Ret>::Ret Ret;"
-    print "   virtual Ret unhandled_node(const Nodecl::NodeclBase &) { return Ret(); }"
+        print("     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name))
+    print("   virtual ~BaseNodeclVisitor() { }")
+    print("};")
+    print("template <typename _Ret>")
+    print("class UnhandledNodeclVisitor : public BaseNodeclVisitor<_Ret>")
+    print("{")
+    print("   public:")
+    print("     typedef typename BaseNodeclVisitor<_Ret>::Ret Ret;")
+    print("   virtual Ret unhandled_node(const Nodecl::NodeclBase &) { return Ret(); }")
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print "     virtual Ret visit(const Nodecl::%s & n) { return this->unhandled_node(n); }" % (qualified_name)
-    print "   virtual ~UnhandledNodeclVisitor() { }"
-    print "};"
-    print "template <typename _Ret>"
-    print "class NodeclVisitor : public UnhandledNodeclVisitor<_Ret>"
-    print "{"
-    print "   public:"
-    print "     typedef typename UnhandledNodeclVisitor<_Ret>::Ret Ret;"
-    print "};"
-    print "template <typename _Ret>"
-    print "class NodeclVisitor<TL::ObjectList<_Ret> > : public UnhandledNodeclVisitor<TL::ObjectList<_Ret> >"
-    print "{"
-    print "   public:"
-    print "     typedef typename UnhandledNodeclVisitor<TL::ObjectList<_Ret> >::Ret Ret;"
-    print "     TL::ObjectList<_Ret> join_list(TL::ObjectList<TL::ObjectList<_Ret> > &list)"
-    print "     {"
-    print          "TL::ObjectList<_Ret> result;"
-    print          "for (typename TL::ObjectList<TL::ObjectList<_Ret> >::iterator it = list.begin(); it != list.end(); it++)"
-    print          "{"
-    print               "TL::ObjectList<_Ret> &o_list(*it);"
-    print               "result.append(o_list);"
-    print          "}"
-    print          "return result;"
-    print "     }"
-    print "};"
-    print "template <>"
-    print "class NodeclVisitor<Nodecl::NodeclBase> : public UnhandledNodeclVisitor<Nodecl::NodeclBase>"
-    print "{"
-    print "   public:"
-    print "     // Only GCC 4.6 can compile this typedef"
-    print "     // typedef typename UnhandledNodeclVisitor<Nodecl::NodeclBase>::Ret Ret;"
-    print "     virtual Nodecl::NodeclBase join_list(TL::ObjectList<Nodecl::NodeclBase> &list)"
-    print "     {"
-    print "         return Nodecl::List::make(list);"
-    print "     }"
-    print "};"
-
-    print "template <typename _Ret>"
-    print "class ExhaustiveVisitor : public NodeclVisitor<_Ret>"
-    print "{"
-    print "public:"
-    print "     typedef typename NodeclVisitor<_Ret>::Ret Ret;"
+        print("     virtual Ret visit(const Nodecl::%s & n) { return this->unhandled_node(n); }" % (qualified_name))
+    print("   virtual ~UnhandledNodeclVisitor() { }")
+    print("};")
+    print("template <typename _Ret>")
+    print("class NodeclVisitor : public UnhandledNodeclVisitor<_Ret>")
+    print("{")
+    print("   public:")
+    print("     typedef typename UnhandledNodeclVisitor<_Ret>::Ret Ret;")
+    print("};")
+    print("template <typename _Ret>")
+    print("class NodeclVisitor<TL::ObjectList<_Ret> > : public UnhandledNodeclVisitor<TL::ObjectList<_Ret> >")
+    print("{")
+    print("   public:")
+    print("     typedef typename UnhandledNodeclVisitor<TL::ObjectList<_Ret> >::Ret Ret;")
+    print("     TL::ObjectList<_Ret> join_list(TL::ObjectList<TL::ObjectList<_Ret> > &list)")
+    print("     {")
+    print("TL::ObjectList<_Ret> result;")
+    print("for (typename TL::ObjectList<TL::ObjectList<_Ret> >::iterator it = list.begin(); it != list.end(); it++)")
+    print("{")
+    print("TL::ObjectList<_Ret> &o_list(*it);")
+    print("result.append(o_list);")
+    print("}")
+    print("return result;")
+    print("     }")
+    print("};")
+    print("template <>")
+    print("class NodeclVisitor<Nodecl::NodeclBase> : public UnhandledNodeclVisitor<Nodecl::NodeclBase>")
+    print("{")
+    print("   public:")
+    print("     // Only GCC 4.6 can compile this typedef")
+    print("     // typedef typename UnhandledNodeclVisitor<Nodecl::NodeclBase>::Ret Ret;")
+    print("     virtual Nodecl::NodeclBase join_list(TL::ObjectList<Nodecl::NodeclBase> &list)")
+    print("     {")
+    print("         return Nodecl::List::make(list);")
+    print("     }")
+    print("};")
+
+    print("template <typename _Ret>")
+    print("class ExhaustiveVisitor : public NodeclVisitor<_Ret>")
+    print("{")
+    print("public:")
+    print("     typedef typename NodeclVisitor<_Ret>::Ret Ret;")
     classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(rule_map)
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class, module_name) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "     virtual Ret visit_pre(const Nodecl::%s & n) { return Ret(); }" % (qualified_name)
-         print "     virtual Ret visit_post(const Nodecl::%s & n) { return Ret(); }" % (qualified_name)
-         print "     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name)
-         print "     {"
-         print "        TL::ObjectList<Ret> values;"
-         print "        values.append(this->visit_pre(n));"
+         print("     virtual Ret visit_pre(const Nodecl::%s & n) { return Ret(); }" % (qualified_name))
+         print("     virtual Ret visit_post(const Nodecl::%s & n) { return Ret(); }" % (qualified_name))
+         print("     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name))
+         print("     {")
+         print("        TL::ObjectList<Ret> values;")
+         print("        values.append(this->visit_pre(n));")
          child_num = 0
          for child_name in children_name:
-              print "        values.append(this->walk(n.get_%s()));" % (child_name)
+              print("        values.append(this->walk(n.get_%s()));" % (child_name))
               child_num = child_num + 1
-         print "        values.append(this->visit_post(n));"
-         print "        return this->join_list(values);"
-         print "     }"
-    print "};"
+         print("        values.append(this->visit_post(n));")
+         print("        return this->join_list(values);")
+         print("     }")
+    print("};")
     # ExhaustiveVisitor<void>
-    print "template <>"
-    print "class ExhaustiveVisitor<void> : public NodeclVisitor<void>"
-    print "{"
-    print "public:"
-    print "     typedef NodeclVisitor<void>::Ret Ret;"
+    print("template <>")
+    print("class ExhaustiveVisitor<void> : public NodeclVisitor<void>")
+    print("{")
+    print("public:")
+    print("     typedef NodeclVisitor<void>::Ret Ret;")
     classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(rule_map)
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class, module_name) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "     virtual Ret visit_pre(const Nodecl::%s & n) { }" % (qualified_name)
-         print "     virtual Ret visit_post(const Nodecl::%s & n) { }" % (qualified_name)
-         print "     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name)
-         print "     {"
-         print "        this->visit_pre(n);"
+         print("     virtual Ret visit_pre(const Nodecl::%s & n) { }" % (qualified_name))
+         print("     virtual Ret visit_post(const Nodecl::%s & n) { }" % (qualified_name))
+         print("     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name))
+         print("     {")
+         print("        this->visit_pre(n);")
          child_num = 0
          for child_name in children_name:
-              print "        this->walk(n.get_%s());" % (child_name)
+              print("        this->walk(n.get_%s());" % (child_name))
               child_num = child_num + 1
-         print "        this->visit_post(n);"
-         print "     }"
-    print "};"
-    print ""
-    print "template <typename _Ret>"
-    print "typename BaseNodeclVisitor<_Ret>::Ret BaseNodeclVisitor<_Ret>::walk(const NodeclBase& n)"
-    print "{"
-    print """
+         print("        this->visit_post(n);")
+         print("     }")
+    print("};")
+    print("")
+    print("template <typename _Ret>")
+    print("typename BaseNodeclVisitor<_Ret>::Ret BaseNodeclVisitor<_Ret>::walk(const NodeclBase& n)")
+    print("{")
+    print("""
     if (n.is_null())
         return Ret();
     switch ((int)n.get_kind())
     {
         case AST_NODE_LIST: { TL::ObjectList<Ret> result; AST tree = nodecl_get_ast(n._n); AST it; for_each_element(tree, it) { AST elem = ASTSon1(it);
 NodeclBase nb(::_nodecl_wrap(elem)); result.append(this->walk(nb)); } return this->join_list(result); break; }
-"""
+""")
     node_kind = set([])
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
@@ -665,40 +665,40 @@ NodeclBase nb(::_nodecl_wrap(elem)); result.append(this->walk(nb)); } return thi
             if rhs.__class__ == NodeclStructure:
                 node_kind.add((rhs.name_to_underscore(), from_underscore_to_camel_case_namespaces(rhs.base_name().lower())))
     for (kind_name, (namespaces, class_name)) in node_kind:
-        print "       case %s: { return this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name))
-    print """
+        print("       case %s: { return this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name)))
+    print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(n.get_kind())); }
     }
 
     return Ret();
-"""
-    print "}"
-    print "} /* namespace Nodecl */"
-    print "#endif"
+""")
+    print("}")
+    print("} /* namespace Nodecl */")
+    print("#endif")
 
 def generate_visitor_class_impl(rule_map):
-    print "#ifndef TL_NODECL_VISITOR_CPP"
-    print "#define TL_NODECL_VISITOR_CPP"
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print "#include <tl-nodecl-visitor.hpp>"
-    print "#include <tl-nodecl.hpp>"
-    print "#include \"cxx-utils.h\""
-    print "#include \"mem.h\""
-    print ""
-    print "namespace Nodecl {"
-    print ""
-    print "BaseNodeclVisitor<void>::Ret BaseNodeclVisitor<void>::walk(const NodeclBase& n)"
-    print "{"
-    print """
+    print("#ifndef TL_NODECL_VISITOR_CPP")
+    print("#define TL_NODECL_VISITOR_CPP")
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("#include <tl-nodecl-visitor.hpp>")
+    print("#include <tl-nodecl.hpp>")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("namespace Nodecl {")
+    print("")
+    print("BaseNodeclVisitor<void>::Ret BaseNodeclVisitor<void>::walk(const NodeclBase& n)")
+    print("{")
+    print("""
     if (n.is_null())
         return;
     switch ((int)n.get_kind())
     {
         case AST_NODE_LIST: { AST tree = nodecl_get_ast(n._n); AST it; for_each_element(tree, it) { AST elem = ASTSon1(it);
 NodeclBase nb(::_nodecl_wrap(elem)); this->walk(nb); } break; }
-"""
+""")
     node_kind = set([])
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
@@ -706,157 +706,157 @@ NodeclBase nb(::_nodecl_wrap(elem)); this->walk(nb); } break; }
             if rhs.__class__ == NodeclStructure:
                 node_kind.add((rhs.name_to_underscore(), from_underscore_to_camel_case_namespaces(rhs.base_name().lower())))
     for (kind_name, (namespaces, class_name)) in node_kind:
-        print "       case %s: { this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name))
-    print """
+        print("       case %s: { this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name)))
+    print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(n.get_kind())); }
     }
-"""
-    print "}"
-    print "} /* namespace Nodecl */"
-    print "#endif // TL_NODECL_VISITOR_CPP"
+""")
+    print("}")
+    print("} /* namespace Nodecl */")
+    print("#endif // TL_NODECL_VISITOR_CPP")
 
 def generate_copy_visitor_class_header(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print "#ifndef TL_NODECL_COPY_VISITOR_HPP"
-    print "#define TL_NODECL_COPY_VISITOR_HPP"
-    print ""
-    print "#include \"tl-nodecl-visitor.hpp\""
-    print "#include \"tl-nodecl-copy-visitor-base.hpp\""
-    print "#include \"mem.h\""
-    print ""
-    print "namespace Nodecl {"
-    print "   class ShallowCopyVisitor : public CopyVisitorBase"
-    print "   {"
-    print "      public:"
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("#ifndef TL_NODECL_COPY_VISITOR_HPP")
+    print("#define TL_NODECL_COPY_VISITOR_HPP")
+    print("")
+    print("#include \"tl-nodecl-visitor.hpp\"")
+    print("#include \"tl-nodecl-copy-visitor-base.hpp\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("namespace Nodecl {")
+    print("   class ShallowCopyVisitor : public CopyVisitorBase")
+    print("   {")
+    print("      public:")
     classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name)
-    print "   };"
-    print "   struct SymbolMap"
-    print "   {"
-    print "       virtual TL::Symbol map(TL::Symbol sym) = 0;"
-    print "       virtual void add_map(TL::Symbol source, TL::Symbol target) = 0;"
-    print "   };"
-    print "   class DeepCopyVisitorBase : public CopyVisitorBase"
-    print "   {"
-    print "      protected:"
-    print "         SymbolMap &_map_symbol;"
-    print "      public:"
-    print "          DeepCopyVisitorBase(SymbolMap &map_symbol) : _map_symbol(map_symbol) { }"
+         print("        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name))
+    print("   };")
+    print("   struct SymbolMap")
+    print("   {")
+    print("       virtual TL::Symbol map(TL::Symbol sym) = 0;")
+    print("       virtual void add_map(TL::Symbol source, TL::Symbol target) = 0;")
+    print("   };")
+    print("   class DeepCopyVisitorBase : public CopyVisitorBase")
+    print("   {")
+    print("      protected:")
+    print("         SymbolMap &_map_symbol;")
+    print("      public:")
+    print("          DeepCopyVisitorBase(SymbolMap &map_symbol) : _map_symbol(map_symbol) { }")
     classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name)
-    print "   };"
-    print "}"
-    print "#endif // TL_NODECL_COPY_VISITOR_HPP"
+         print("        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name))
+    print("   };")
+    print("}")
+    print("#endif // TL_NODECL_COPY_VISITOR_HPP")
 
 def generate_copy_visitor_class_impl(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print "#include \"tl-nodecl-copy-visitor.hpp\""
-    print ""
-    print "namespace Nodecl {"
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("#include \"tl-nodecl-copy-visitor.hpp\"")
+    print("")
+    print("namespace Nodecl {")
     classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "  ShallowCopyVisitor::Ret ShallowCopyVisitor::visit(const Nodecl::%s & n)" % (qualified_name)
-         print "  {"
+         print("  ShallowCopyVisitor::Ret ShallowCopyVisitor::visit(const Nodecl::%s & n)" % (qualified_name))
+         print("  {")
 
          factory_arguments = []
          for child_name in children_name:
-             print "Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name)
+             print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name))
              factory_arguments.append("child_%s" % (child_name))
 
          if nodecl_class.needs_symbol:
-             print "TL::Symbol symbol = n.get_symbol();"
+             print("TL::Symbol symbol = n.get_symbol();")
              factory_arguments.append("symbol")
          if nodecl_class.needs_type:
-             print "TL::Type type = n.get_type();";
+             print("TL::Type type = n.get_type();");
              factory_arguments.append("type")
          if nodecl_class.needs_text:
-             print "const std::string& text = n.get_text();"
+             print("const std::string& text = n.get_text();")
              factory_arguments.append("text")
          if nodecl_class.needs_cval:
-             print "const_value_t* cval = n.get_constant();"
+             print("const_value_t* cval = n.get_constant();")
              factory_arguments.append("cval")
          if nodecl_class.needs_template_parameters:
-             print "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());"
+             print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());")
              factory_arguments.append("template_parameters")
          if nodecl_class.needs_decl_context:
-             print "TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());"
+             print("TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());")
              factory_arguments.append("sc")
 
-         print "const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());"
+         print("const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());")
          factory_arguments.append("location")
 
-         print "return %s::make(%s);" % (qualified_name, string.join(factory_arguments, ", "))
+         print("return %s::make(%s);" % (qualified_name, ", ".join(factory_arguments)))
 
-         print "  }"
+         print("  }")
     for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
          qualified_name = get_qualified_name(namespaces, class_name)
-         print "  DeepCopyVisitorBase::Ret DeepCopyVisitorBase::visit(const Nodecl::%s & n)" % (qualified_name)
-         print "  {"
+         print("  DeepCopyVisitorBase::Ret DeepCopyVisitorBase::visit(const Nodecl::%s & n)" % (qualified_name))
+         print("  {")
 
          factory_arguments = []
          for child_name in children_name:
-             print "Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name)
+             print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name))
              factory_arguments.append("child_%s" % (child_name))
 
          if nodecl_class.needs_symbol:
-             print "TL::Symbol symbol = _map_symbol.map( n.get_symbol() );"
+             print("TL::Symbol symbol = _map_symbol.map( n.get_symbol() );")
              factory_arguments.append("symbol")
          if nodecl_class.needs_type:
-             print "TL::Type type = n.get_type();";
+             print("TL::Type type = n.get_type();");
              factory_arguments.append("type")
          if nodecl_class.needs_text:
-             print "const std::string& text = n.get_text();"
+             print("const std::string& text = n.get_text();")
              factory_arguments.append("text")
          if nodecl_class.needs_cval:
-             print "const_value_t* cval = n.get_constant();"
+             print("const_value_t* cval = n.get_constant();")
              factory_arguments.append("cval")
          if nodecl_class.needs_template_parameters:
-             print "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());"
+             print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());")
              factory_arguments.append("template_parameters")
          if nodecl_class.needs_decl_context:
-             print "TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());";
+             print("TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());");
              factory_arguments.append("sc")
 
-         print "const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());"
+         print("const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());")
          factory_arguments.append("location")
 
-         print "return %s::make(%s);" % (qualified_name, string.join(factory_arguments, ", "))
+         print("return %s::make(%s);" % (qualified_name, ", ".join(factory_arguments)))
 
-         print "  }"
-    print "}"
+         print("  }")
+    print("}")
 
 def generate_nodecl_classes_base(rule_map):
-   print "/* Autogenerated file. DO NOT MODIFY. */"
-   print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-   print "#ifndef TL_NODECL_HPP"
-   print "#define TL_NODECL_HPP"
-   print ""
-   print "#include <string>"
-   print "#include \"tl-nodecl-base.hpp\""
-   print "#include \"mem.h\""
-   
-   print "namespace Nodecl {"
+   print("/* Autogenerated file. DO NOT MODIFY. */")
+   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+   print("#ifndef TL_NODECL_HPP")
+   print("#define TL_NODECL_HPP")
+   print("")
+   print("#include <string>")
+   print("#include \"tl-nodecl-base.hpp\"")
+   print("#include \"mem.h\"")
+
+   print("namespace Nodecl {")
 
    classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
        qualified_name = get_qualified_name(namespaces, class_name)
-       print "class %s : public NodeclBase" % (qualified_name)
-       print "{"
-       print "    private:"
-       print "       static const int _kind = ::%s;" % (tree_kind)
-       print "       friend class NodeclBase;"
-       print "    public:"
-       print "    %s() : NodeclBase() { }" %(class_name)
-       print "    %s(const nodecl_t& a) : NodeclBase(a) { }" %(class_name)
-       print ""
+       print("class %s : public NodeclBase" % (qualified_name))
+       print("{")
+       print("    private:")
+       print("       static const int _kind = ::%s;" % (tree_kind))
+       print("       friend class NodeclBase;")
+       print("    public:")
+       print("    %s() : NodeclBase() { }" %(class_name))
+       print("    %s(const nodecl_t& a) : NodeclBase(a) { }" %(class_name))
+       print("")
 
        factory_parameters = []
        for child_name in children_name:
@@ -876,30 +876,30 @@ def generate_nodecl_classes_base(rule_map):
 
        factory_parameters.append("const locus_t *location = ::make_locus(\"\", 0, 0)");
 
-       print "    // Factory method"
-       print "    static %s make(%s);" % (class_name, string.join(factory_parameters, ", "))
-       print ""
+       print("    // Factory method")
+       print("    static %s make(%s);" % (class_name, ", ".join(factory_parameters)))
+       print("")
 
        if children_name:
-            print "    // Children getters and setters "
+            print("    // Children getters and setters ")
        child_num = 0
        for child_name in children_name:
-            print "    NodeclBase get_%s() const { return NodeclBase(nodecl_get_child(_n, %d)); } " % (child_name, child_num)
-            print "    void set_%s(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, %d, n.get_internal_nodecl()); } " % (child_name, child_num)
+            print("    NodeclBase get_%s() const { return NodeclBase(nodecl_get_child(_n, %d)); } " % (child_name, child_num))
+            print("    void set_%s(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, %d, n.get_internal_nodecl()); } " % (child_name, child_num))
             child_num = child_num + 1
-       print "};"
-   print ""
-   print "} /* namespace Nodecl */"
-   print "#endif"
+       print("};")
+   print("")
+   print("} /* namespace Nodecl */")
+   print("#endif")
 
 def generate_nodecl_classes_specs(rule_map):
-   print "/* Autogenerated file. DO NOT MODIFY. */"
-   print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-   print "#include \"cxx-utils.h\""
-   print "#include \"tl-nodecl.hpp\""
-   print "#include \"mem.h\""
-   print ""
-   print "namespace Nodecl {"
+   print("/* Autogenerated file. DO NOT MODIFY. */")
+   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+   print("#include \"cxx-utils.h\"")
+   print("#include \"tl-nodecl.hpp\"")
+   print("#include \"mem.h\"")
+   print("")
+   print("namespace Nodecl {")
    classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
 
@@ -933,42 +933,42 @@ def generate_nodecl_classes_specs(rule_map):
        nodecl_make_name = "nodecl_make_%s" % (nodecl_class.base_name_to_underscore_lowercase())
 
        qualified_name = get_qualified_name(namespaces, class_name)
-       print "%s %s::make(%s)" % (qualified_name, qualified_name, string.join(factory_parameters, ", "))
-       print "{"
-       print "    return ::%s(%s);" % (nodecl_make_name, string.join(factory_arguments, ", "))
-       print "}"
+       print("%s %s::make(%s)" % (qualified_name, qualified_name, ", ".join(factory_parameters)))
+       print("{")
+       print("    return ::%s(%s);" % (nodecl_make_name, ", ".join(factory_arguments)))
+       print("}")
 
-   print "} /* namespace Nodecl */"
+   print("} /* namespace Nodecl */")
 
 def generate_routines_header(rule_map):
-   print "/* Autogenerated file. DO NOT MODIFY. */"
-   print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-   print "#ifndef CXX_NODECL_OUTPUT_H"
-   print "#define CXX_NODECL_OUTPUT_H"
-   print ""
-   print "#include \"cxx-macros.h\""
-   print "#include \"cxx-nodecl.h\""
-   print "#include \"cxx-type-fwd.h\""
-   print "#include \"cxx-cexpr-fwd.h\""
-   print "#include \"cxx-scope-decls.h\""
-   print "#include \"mem.h\""
-   print ""
-   print "MCXX_BEGIN_DECLS"
-   print ""
+   print("/* Autogenerated file. DO NOT MODIFY. */")
+   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+   print("#ifndef CXX_NODECL_OUTPUT_H")
+   print("#define CXX_NODECL_OUTPUT_H")
+   print("")
+   print("#include \"cxx-macros.h\"")
+   print("#include \"cxx-nodecl.h\"")
+   print("#include \"cxx-type-fwd.h\"")
+   print("#include \"cxx-cexpr-fwd.h\"")
+   print("#include \"cxx-scope-decls.h\"")
+   print("#include \"mem.h\"")
+   print("")
+   print("MCXX_BEGIN_DECLS")
+   print("")
 
    for i in range(1, 7):
-        params = map(lambda x : "nodecl_t element%d" % (x) , range(0, i))
-        print "nodecl_t nodecl_make_list_%d(%s);" % (i, string.join(params, ", "))
-   print "nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items);"
-   print ""
+        params = ["nodecl_t element%d" % (x) for x in range(0, i)]
+        print("nodecl_t nodecl_make_list_%d(%s);" % (i, ", ".join(params)))
+   print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items);")
+   print("")
    classes = {}
    for rule_name in rule_map:
        rule_rhs = rule_map[rule_name]
        for rhs in rule_rhs:
            if rhs.__class__ == NodeclStructure:
                classes[rhs.base_name_to_underscore_lowercase()] = rhs
-   for (key, rhs_rule) in classes.iteritems() :
-       param_list_nodecl = map(lambda x : "nodecl_t", rhs_rule.subtrees)
+   for (key, rhs_rule) in classes.items() :
+       param_list_nodecl = ["nodecl_t" for x in rhs_rule.subtrees]
        if rhs_rule.needs_symbol:
            param_list_nodecl.append("scope_entry_t*");
        if rhs_rule.needs_type:
@@ -983,37 +983,37 @@ def generate_routines_header(rule_map):
            param_list_nodecl.append("const decl_context_t*");
        param_list_nodecl.append("const locus_t* location");
 
-       print "nodecl_t nodecl_make_%s(%s);" % (key, string.join(param_list_nodecl, ", "))
-   print ""
-   print "MCXX_END_DECLS"
-   print ""
-   print "#endif // CXX_NODECL_OUTPUT_H"
+       print("nodecl_t nodecl_make_%s(%s);" % (key, ", ".join(param_list_nodecl)))
+   print("")
+   print("MCXX_END_DECLS")
+   print("")
+   print("#endif // CXX_NODECL_OUTPUT_H")
 # print "key %s -> value %s" % (repr(key), repr(value))
 
 
 def generate_routines_impl(rule_map):
-   print "/* Autogenerated file. DO NOT MODIFY. */"
-   print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-   print "#include <stdlib.h>"
-   print "#include \"cxx-nodecl-output.h\""
-   print "#include \"cxx-exprtype.h\""
-   print "#include \"cxx-utils.h\""
-   print "#include \"mem.h\""
-   print ""
+   print("/* Autogenerated file. DO NOT MODIFY. */")
+   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+   print("#include <stdlib.h>")
+   print("#include \"cxx-nodecl-output.h\"")
+   print("#include \"cxx-exprtype.h\"")
+   print("#include \"cxx-utils.h\"")
+   print("#include \"mem.h\"")
+   print("")
    for i in range(2, 7):
-        params = map(lambda x : "nodecl_t element%d" % (x) , range(0, i))
-        args = map(lambda x : "element%d" % (x) , range(0, i))
-        print "nodecl_t nodecl_make_list_%d(%s)" % (i, string.join(params, ", "))
-        print "{"
-        print "  return nodecl_append_to_list(nodecl_make_list_%d(%s), %s);" % (i-1, string.join(args[:-1], ", "), args[-1])
-        print "}"
-   print "nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items)"
-   print "{"
-   print "   int i;"
-   print "   nodecl_t result = nodecl_null();"
-   print "   for (i = 0; i < num_items; i++) result = nodecl_append_to_list(result, items[i]);"
-   print "   return result;"
-   print "}"
+        params = ["nodecl_t element%d" % (x) for x in range(0, i)]
+        args = ["element%d" % (x) for x in range(0, i)]
+        print("nodecl_t nodecl_make_list_%d(%s)" % (i, ", ".join(params)))
+        print("{")
+        print("  return nodecl_append_to_list(nodecl_make_list_%d(%s), %s);" % (i-1, ", ".join(args[:-1]), args[-1]))
+        print("}")
+   print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items)")
+   print("{")
+   print("   int i;")
+   print("   nodecl_t result = nodecl_null();")
+   print("   for (i = 0; i < num_items; i++) result = nodecl_append_to_list(result, items[i]);")
+   print("   return result;")
+   print("}")
 
    classes = {}
    for rule_name in rule_map:
@@ -1021,7 +1021,7 @@ def generate_routines_impl(rule_map):
        for rhs in rule_rhs:
            if rhs.__class__ == NodeclStructure:
                classes[rhs.base_name_to_underscore_lowercase()] = rhs
-   for (key, rhs_rule) in classes.iteritems() :
+   for (key, rhs_rule) in classes.items() :
        param_list_nodecl = []
        param_name_list = []
        for item in rhs_rule.subtrees:
@@ -1048,83 +1048,83 @@ def generate_routines_impl(rule_map):
        if not param_list_nodecl:
            raise Exception("Empty list!")
 
-       print "nodecl_t nodecl_make_%s(%s)" % (key, string.join(param_list_nodecl, ", "))
-       print "{"
+       print("nodecl_t nodecl_make_%s(%s)" % (key, ", ".join(param_list_nodecl)))
+       print("{")
        # Inline check
        i = 0
        for subrule in rhs_rule.subtrees:
           subrule_ref = RuleRef(subrule[1])
           first_set = RuleRef(subrule_ref.canonical_rule()).first();
 
-          print "{"
-          print "nodecl_t checked_tree = %s;" % (param_name_list[i])
+          print("{")
+          print("nodecl_t checked_tree = %s;" % (param_name_list[i]))
           if not subrule_ref.is_nullable():
-              print "if (nodecl_is_null(checked_tree))"
-              print "{"
-              print "  internal_error(\"Null node not allowed in node %d nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key)
-              print "}"
+              print("if (nodecl_is_null(checked_tree))")
+              print("{")
+              print("  internal_error(\"Null node not allowed in node %d nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key))
+              print("}")
           if subrule_ref.is_nullable():
-             print "if (!nodecl_is_null(checked_tree))"
-             print "{"
+             print("if (!nodecl_is_null(checked_tree))")
+             print("{")
           if subrule_ref.is_seq():
-             print " if (!nodecl_is_list(checked_tree))"
-             print " {"
-             print "  internal_error(\"Node must be a list in node %d of nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key)
-             print " }"
-             print "AST list = nodecl_get_ast(checked_tree), it;"
-             print "for_each_element(list, it)"
-             print "{"
-             print "  checked_tree = _nodecl_wrap(ASTSon1(it));"
+             print(" if (!nodecl_is_list(checked_tree))")
+             print(" {")
+             print("  internal_error(\"Node must be a list in node %d of nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key))
+             print(" }")
+             print("AST list = nodecl_get_ast(checked_tree), it;")
+             print("for_each_element(list, it)")
+             print("{")
+             print("  checked_tree = _nodecl_wrap(ASTSon1(it));")
           if first_set :
-              checks = map(lambda x : "(nodecl_get_kind(checked_tree) != %s)" % (x), first_set)
-              print "if (%s)" % (string.join(checks, "\n&& "))
-              print "{"
-              print "  internal_error(\"Invalid node %d of type %%s in nodecl_make_%s. Location: %%s\\n\", ast_print_node_type(nodecl_get_kind(checked_tree)), locus_to_str(location));" % (i, key)
-              print "}"
+              checks = ["(nodecl_get_kind(checked_tree) != %s)" % (x) for x in first_set]
+              print("if (%s)" % ("\n&& ".join(checks)))
+              print("{")
+              print("  internal_error(\"Invalid node %d of type %%s in nodecl_make_%s. Location: %%s\\n\", ast_print_node_type(nodecl_get_kind(checked_tree)), locus_to_str(location));" % (i, key))
+              print("}")
           if subrule_ref.is_seq():
-             print "}"
+             print("}")
           if subrule_ref.is_nullable():
-             print "}"
+             print("}")
           i = i + 1
-          print "}"
+          print("}")
 
        if rhs_rule.needs_text:
-           print "  if (text == NULL) internal_error(\"This node requires a text. Location: %s\", locus_to_str(location));"
+           print("  if (text == NULL) internal_error(\"This node requires a text. Location: %s\", locus_to_str(location));")
            text_value = "text";
        else:
            text_value = "NULL"
 
        # Build the node
-       print "  nodecl_t result = nodecl_null();"
+       print("  nodecl_t result = nodecl_null();")
        num_children = len(rhs_rule.subtrees)
        if num_children == 0:
-          print "  result.tree = ASTLeaf(%s, location, %s);" % (rhs_rule.name_to_underscore(), text_value)
+          print("  result.tree = ASTLeaf(%s, location, %s);" % (rhs_rule.name_to_underscore(), text_value))
        else:
-          print "  result.tree = ASTMake%d(%s, %s, location, %s);" % (num_children, rhs_rule.name_to_underscore(), \
-                 string.join(map(lambda x : x + ".tree", param_name_list), ", "), text_value);
+          print("  result.tree = ASTMake%d(%s, %s, location, %s);" % (num_children, rhs_rule.name_to_underscore(), \
+                 ", ".join([x + ".tree" for x in param_name_list]), text_value));
 
        if rhs_rule.needs_symbol:
-           print "  if (symbol == NULL) internal_error(\"Node requires a symbol. Location: %s\", locus_to_str(location));"
-           print "  nodecl_set_symbol(result, symbol);"
+           print("  if (symbol == NULL) internal_error(\"Node requires a symbol. Location: %s\", locus_to_str(location));")
+           print("  nodecl_set_symbol(result, symbol);")
        if rhs_rule.needs_type:
-           print "  if (type == NULL) internal_error(\"This node requires a type. Location: %s\", locus_to_str(location));"
-           print "  nodecl_set_type(result, type);"
+           print("  if (type == NULL) internal_error(\"This node requires a type. Location: %s\", locus_to_str(location));")
+           print("  nodecl_set_type(result, type);")
        if rhs_rule.needs_cval:
-           print "  if (cval == NULL) internal_error(\"This node requires a constant value. Location: %s\", locus_to_str(location));"
-           print "  nodecl_set_constant(result, cval);"
+           print("  if (cval == NULL) internal_error(\"This node requires a constant value. Location: %s\", locus_to_str(location));")
+           print("  nodecl_set_constant(result, cval);")
        if rhs_rule.needs_template_parameters:
-           print "  nodecl_set_template_parameters(result, template_parameters);"
+           print("  nodecl_set_template_parameters(result, template_parameters);")
        if rhs_rule.needs_decl_context:
-           print "  nodecl_set_decl_context(result, decl_context);"
+           print("  nodecl_set_decl_context(result, decl_context);")
 
-       print "  return result;"
-       print "}"
-       print ""
+       print("  return result;")
+       print("}")
+       print("")
 
 def generate_c_visitor_decl(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print """
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("""
 #ifndef CXX_NODECL_VISITOR_H
 #define CXX_NODECL_VISITOR_H
 
@@ -1138,7 +1138,7 @@ typedef struct nodecl_external_visitor_tag nodecl_external_visitor_t;
 
 struct nodecl_external_visitor_tag
 {
-"""
+""")
     node_kind = set([])
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
@@ -1146,9 +1146,9 @@ struct nodecl_external_visitor_tag
             if rhs.__class__ == NodeclStructure:
                 node_kind.add(rhs.base_name_to_underscore_lowercase())
     for node in node_kind:
-        print "void (*visit_%s)(nodecl_external_visitor_t*, nodecl_t a);" % ( node )
+        print("void (*visit_%s)(nodecl_external_visitor_t*, nodecl_t a);" % ( node ))
 
-    print """
+    print("""
 };
 
 void nodecl_walk(nodecl_external_visitor_t* external_visitor, nodecl_t node);
@@ -1161,12 +1161,12 @@ void nodecl_init_walker(nodecl_external_visitor_t* external_visitor, void (*defa
 MCXX_END_DECLS
 
 #endif // CXX_NODECL_VISITOR_H
-"""
+""")
 
 def generate_c_visitor_def(rule_map):
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-    print """
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print("""
 #include "cxx-nodecl-visitor.h"
 #include "cxx-utils.h"
 #include "mem.h"
@@ -1179,7 +1179,7 @@ void nodecl_walk(nodecl_external_visitor_t* external_visitor, nodecl_t n)
     switch (ASTKind(tree))
     {
         case AST_NODE_LIST: { AST it; for_each_element(tree, it) { AST elem = ASTSon1(it); nodecl_walk(external_visitor, _nodecl_wrap(elem)); } break; }
-"""
+""")
     node_kind = set([])
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
@@ -1187,8 +1187,8 @@ void nodecl_walk(nodecl_external_visitor_t* external_visitor, nodecl_t n)
             if rhs.__class__ == NodeclStructure:
                 node_kind.add((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower()))
     for node in node_kind:
-        print "       case %s: { if (external_visitor->visit_%s != NULL) external_visitor->visit_%s(external_visitor, n); break; }" % (node[0], node[1], node[1])
-    print """
+        print("       case %s: { if (external_visitor->visit_%s != NULL) external_visitor->visit_%s(external_visitor, n); break; }" % (node[0], node[1], node[1]))
+    print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(ASTKind(tree))); }
     }
@@ -1196,12 +1196,12 @@ void nodecl_walk(nodecl_external_visitor_t* external_visitor, nodecl_t n)
 
 void nodecl_init_walker(nodecl_external_visitor_t* external_visitor, void (*default_visitor)(nodecl_external_visitor_t*, nodecl_t))
 {
-"""
+""")
     for node in node_kind:
-        print "    external_visitor->visit_%s = default_visitor;" % (node[1])
-    print """
+        print("    external_visitor->visit_%s = default_visitor;" % (node[1]))
+    print("""
 }
-"""
+""")
 
 def generate_asttypes(rule_map):
     node_kind = set([])
@@ -1213,18 +1213,18 @@ def generate_asttypes(rule_map):
     l = list(node_kind)
     l.sort()
     for kind_name in l:
-        print kind_name
+        print(kind_name)
 
 def generate_c_shallow_copy_def(rule_map):
-    print "#include \"cxx-nodecl.h\""
-    print "#include \"cxx-nodecl-output.h\""
-    print "#include \"cxx-scope.h\""
-    print "#include \"cxx-utils.h\""
-    print "#include \"mem.h\""
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-
-    print """
+    print("#include \"cxx-nodecl.h\"")
+    print("#include \"cxx-nodecl-output.h\"")
+    print("#include \"cxx-scope.h\"")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"mem.h\"")
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+
+    print("""
 nodecl_t nodecl_shallow_copy(nodecl_t n)
 {
     if (nodecl_is_null(n))
@@ -1245,7 +1245,7 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
           return result;
           break;
         }
-"""
+""")
 
     node_kind = []
     for rule_name in rule_map:
@@ -1255,8 +1255,8 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
                 node_kind.append((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower(), rhs))
     for node in node_kind:
         nodecl_class = node[2]
-        print "       case %s:" % (node[0])
-        print "       {"
+        print("       case %s:" % (node[0]))
+        print("       {")
         factory_arguments = []
         i = 0
         for subtree in nodecl_class.subtrees:
@@ -1264,9 +1264,9 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
             current_rule = RuleRef(rule_ref)
 
             if current_rule.canonical_rule() != "any":
-                print "nodecl_t child_%d = nodecl_shallow_copy(nodecl_get_child(n, %d));" % (i, i)
+                print("nodecl_t child_%d = nodecl_shallow_copy(nodecl_get_child(n, %d));" % (i, i))
             else:
-                print "nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i)
+                print("nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i))
 
             factory_arguments.append("child_%d" % (i))
             i = i + 1
@@ -1276,92 +1276,92 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
         has_attr = lambda x : needs_attr(x) or may_have_attr(x)
 
         if has_attr("symbol"):
-            print "scope_entry_t* symbol = nodecl_get_symbol(n);"
+            print("scope_entry_t* symbol = nodecl_get_symbol(n);")
         if needs_attr("symbol"):
             factory_arguments.append("symbol")
 
         if has_attr("type"):
-            print "type_t* type = nodecl_get_type(n);"
+            print("type_t* type = nodecl_get_type(n);")
         if needs_attr("type"):
             factory_arguments.append("type")
 
         if has_attr("text"):
-            print "const char* text = nodecl_get_text(n);"
+            print("const char* text = nodecl_get_text(n);")
         if needs_attr("text"):
             factory_arguments.append("text")
 
         if has_attr("cval"):
-            print "const_value_t* cval = nodecl_get_constant(n);"
+            print("const_value_t* cval = nodecl_get_constant(n);")
         if needs_attr("cval"):
             factory_arguments.append("cval")
 
         if has_attr("template_parameters"):
-            print "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);"
+            print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);")
         if needs_attr("template_parameters"):
             factory_arguments.append("template_parameters")
 
         if has_attr("decl_context"):
-            print "const decl_context_t* decl_context = nodecl_get_decl_context(n);";
+            print("const decl_context_t* decl_context = nodecl_get_decl_context(n);");
         if needs_attr("decl_context"):
             factory_arguments.append("decl_context")
 
-        print "const locus_t* location = nodecl_get_locus(n);"
+        print("const locus_t* location = nodecl_get_locus(n);")
         factory_arguments.append("location")
-        print "nodecl_t result = nodecl_make_%s(%s);" % (node[1], string.join(factory_arguments, ", "))
+        print("nodecl_t result = nodecl_make_%s(%s);" % (node[1], ", ".join(factory_arguments)))
 
         if may_have_attr("symbol"):
-            print "nodecl_set_symbol(result, symbol);"
+            print("nodecl_set_symbol(result, symbol);")
 
         if may_have_attr("type"):
-            print "nodecl_set_type(result, type);"
+            print("nodecl_set_type(result, type);")
 
         if may_have_attr("text"):
-            print "nodecl_set_text(result, text);"
+            print("nodecl_set_text(result, text);")
 
         if may_have_attr("cval"):
-            print "nodecl_set_constant(result, cval);"
+            print("nodecl_set_constant(result, cval);")
 
         if may_have_attr("template_parameters"):
-            print "nodecl_set_template_parameters(result, template_parameters);"
+            print("nodecl_set_template_parameters(result, template_parameters);")
 
         if may_have_attr("decl_context"):
-            print "nodecl_set_decl_context(result, decl_context);"
+            print("nodecl_set_decl_context(result, decl_context);")
 
         # Extra attributes from expressions
-        print "nodecl_expr_set_is_value_dependent(result, nodecl_expr_is_value_dependent(n));"
-        print "nodecl_expr_set_is_type_dependent(result, nodecl_expr_is_type_dependent(n));"
+        print("nodecl_expr_set_is_value_dependent(result, nodecl_expr_is_value_dependent(n));")
+        print("nodecl_expr_set_is_type_dependent(result, nodecl_expr_is_type_dependent(n));")
 
-        print "       return result;";
-        print "       break;"
-        print "       }"
-    print """
+        print("       return result;");
+        print("       break;")
+        print("       }")
+    print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(nodecl_get_kind(n))); }
        }
        return nodecl_null();
 }
-"""
+""")
 
 def generate_c_deep_copy_def(rule_map):
-    print "#include \"cxx-nodecl.h\""
-    print "#include \"cxx-nodecl-deep-copy.h\""
-    print "#include \"cxx-symbol-deep-copy.h\""
-    print "#include \"cxx-cexpr-deep-copy.h\""
-    print "#include \"cxx-nodecl-output.h\""
-    print "#include \"cxx-scope.h\""
-    print "#include \"cxx-typeutils.h\""
-    print "#include \"cxx-utils.h\""
-    print "#include \"mem.h\""
-    print "/* Autogenerated file. DO NOT MODIFY. */"
-    print "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
-
-    print """
-extern nodecl_t nodecl_deep_copy_context(nodecl_t n, const decl_context_t* new_decl_context, 
+    print("#include \"cxx-nodecl.h\"")
+    print("#include \"cxx-nodecl-deep-copy.h\"")
+    print("#include \"cxx-symbol-deep-copy.h\"")
+    print("#include \"cxx-cexpr-deep-copy.h\"")
+    print("#include \"cxx-nodecl-output.h\"")
+    print("#include \"cxx-scope.h\"")
+    print("#include \"cxx-typeutils.h\"")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"mem.h\"")
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+
+    print("""
+extern nodecl_t nodecl_deep_copy_context(nodecl_t n, const decl_context_t* new_decl_context,
    symbol_map_t* symbol_map,
    symbol_map_t** synth_symbol_map,
    nodecl_deep_copy_map_t* nodecl_deep_copy_map,
    symbol_deep_copy_map_t* symbol_deep_copy_map);
-extern nodecl_t nodecl_deep_copy_function_code(nodecl_t n, const decl_context_t* new_decl_context, 
+extern nodecl_t nodecl_deep_copy_function_code(nodecl_t n, const decl_context_t* new_decl_context,
    symbol_map_t* symbol_map,
    symbol_map_t** synth_symbol_map,
    nodecl_deep_copy_map_t* nodecl_deep_copy_map,
@@ -1399,7 +1399,7 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
           DELETE(list);
           break;
         }
-"""
+""")
     node_kind = []
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
@@ -1408,20 +1408,20 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
                 node_kind.append((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower(), rhs))
     for node in node_kind:
         nodecl_class = node[2]
-        print "       case %s:" % (node[0])
-        print "       {"
+        print("       case %s:" % (node[0]))
+        print("       {")
 
         if node[0] == "NODECL_CONTEXT":
-            print "          result = nodecl_deep_copy_context(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
-            print "          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);"
-            print "          return result;"
-            print "       }"
+            print("          result = nodecl_deep_copy_context(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
+            print("          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);")
+            print("          return result;")
+            print("       }")
             continue
         elif node[0] == "NODECL_FUNCTION_CODE":
-            print "          result = nodecl_deep_copy_function_code(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
-            print "          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);"
-            print "          return result;"
-            print "       }"
+            print("          result = nodecl_deep_copy_function_code(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
+            print("          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);")
+            print("          return result;")
+            print("       }")
             continue
 
         factory_arguments = []
@@ -1431,9 +1431,9 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
             current_rule = RuleRef(rule_ref)
 
             if current_rule.canonical_rule() != "any":
-                print "nodecl_t child_%d = nodecl_deep_copy_rec(nodecl_get_child(n, %d), new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (i, i)
+                print("nodecl_t child_%d = nodecl_deep_copy_rec(nodecl_get_child(n, %d), new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (i, i))
             else:
-                print "nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i);
+                print("nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i));
 
             factory_arguments.append("child_%d" % (i))
             i = i + 1
@@ -1443,63 +1443,63 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
         has_attr = lambda x : needs_attr(x) or may_have_attr(x)
 
         if has_attr("symbol"):
-            print "scope_entry_t* symbol = (*synth_symbol_map)->map(*synth_symbol_map, nodecl_get_symbol(n));"
+            print("scope_entry_t* symbol = (*synth_symbol_map)->map(*synth_symbol_map, nodecl_get_symbol(n));")
         if needs_attr("symbol"):
             factory_arguments.append("symbol")
 
         # FIXME - The type may have to be regenerated as well
         if has_attr("type"):
-            print "type_t* type = nodecl_get_type(n);"
-            print "type = type_deep_copy_compute_maps(type, /* dest */ NULL, new_decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+            print("type_t* type = nodecl_get_type(n);")
+            print("type = type_deep_copy_compute_maps(type, /* dest */ NULL, new_decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
         if needs_attr("type"):
             factory_arguments.append("type")
 
         if has_attr("text"):
-            print "const char* text = nodecl_get_text(n);"
+            print("const char* text = nodecl_get_text(n);")
         if needs_attr("text"):
             factory_arguments.append("text")
 
         if has_attr("cval"):
-            print "const_value_t* cval = const_value_deep_copy(nodecl_get_constant(n), *synth_symbol_map);"
+            print("const_value_t* cval = const_value_deep_copy(nodecl_get_constant(n), *synth_symbol_map);")
         if needs_attr("cval"):
             factory_arguments.append("cval")
 
         if has_attr("template_parameters"):
-            print "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);"
+            print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);")
         if needs_attr("template_parameters"):
             factory_arguments.append("template_parameters")
 
         if has_attr("decl_context"):
-            print "const decl_context_t* decl_context = nodecl_get_decl_context(n);";
+            print("const decl_context_t* decl_context = nodecl_get_decl_context(n);");
         if needs_attr("decl_context"):
             factory_arguments.append("decl_context")
 
-        print "const locus_t* location = nodecl_get_locus(n);"
+        print("const locus_t* location = nodecl_get_locus(n);")
         factory_arguments.append("location")
 
-        print "result = nodecl_make_%s(%s);" % (node[1], string.join(factory_arguments, ", "))
+        print("result = nodecl_make_%s(%s);" % (node[1], ", ".join(factory_arguments)))
 
         if may_have_attr("symbol"):
-            print "nodecl_set_symbol(result, symbol);"
+            print("nodecl_set_symbol(result, symbol);")
 
         if may_have_attr("type"):
-            print "nodecl_set_type(result, type);"
+            print("nodecl_set_type(result, type);")
 
         if may_have_attr("text"):
-            print "nodecl_set_text(result, text);"
+            print("nodecl_set_text(result, text);")
 
         if may_have_attr("cval"):
-            print "nodecl_set_constant(result, cval);"
+            print("nodecl_set_constant(result, cval);")
 
         if may_have_attr("template_parameters"):
-            print "nodecl_set_template_parameters(result, template_parameters);"
+            print("nodecl_set_template_parameters(result, template_parameters);")
 
         if may_have_attr("decl_context"):
-            print "nodecl_set_decl_context(n, decl_context);"
+            print("nodecl_set_decl_context(n, decl_context);")
 
-        print "       break;"
-        print "       }"
-    print """
+        print("       break;")
+        print("       }")
+    print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(nodecl_get_kind(n))); }
        }
@@ -1508,7 +1508,7 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
 
        return result;
 }
-"""
+""")
 
 
 # MAIN
diff --git a/support/intel_omp/atomic-funs.py b/support/intel_omp/atomic-funs.py
index a577a7191..2411c02e1 100755
--- a/support/intel_omp/atomic-funs.py
+++ b/support/intel_omp/atomic-funs.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python
+#!/usr/bin/env python
 
 import string
 
@@ -33,7 +33,7 @@ type_map = {
 
 f = open("atomic-list.def", "r")
 for l in f:
-    fields = string.split(l.rstrip(), "_");
+    fields = l.rstrip().split("_");
     typename = fields[0]
     op = fields[1]
     rev = ""
@@ -51,10 +51,10 @@ for l in f:
 
     c_typename = type_map.get(typename, "<<error-%s>>" % (typename))
     if not cpt:
-        print "void __kmpc_atomic_%s_%s%s( ident_t* id_ref, int gtid, %s *lhs, %s rhs);" % (typename, op, rev, c_typename, c_typename)
+        print("void __kmpc_atomic_%s_%s%s( ident_t* id_ref, int gtid, %s *lhs, %s rhs);" % (typename, op, rev, c_typename, c_typename))
     else :
         if typename[0:5] != "cmplx":
-            print "%s __kmpc_atomic_%s_%s%s_cpt( ident_t* id_ref, int gtid, %s *lhs, %s rhs, int flag);" % (c_typename, typename, op, rev, c_typename, c_typename)
+            print("%s __kmpc_atomic_%s_%s%s_cpt( ident_t* id_ref, int gtid, %s *lhs, %s rhs, int flag);" % (c_typename, typename, op, rev, c_typename, c_typename))
         else:
-            print "void __kmpc_atomic_%s_%s%s_cpt( ident_t* id_ref, int gtid, %s *lhs, %s rhs, %s out, int flag);" % (typename, op, rev, c_typename, c_typename, c_typename)
+            print("void __kmpc_atomic_%s_%s%s_cpt( ident_t* id_ref, int gtid, %s *lhs, %s rhs, %s out, int flag);" % (typename, op, rev, c_typename, c_typename, c_typename))
 
-- 
2.37.3


From 0031bd52bbd164d19b32e26c9d72c6012393c070 Mon Sep 17 00:00:00 2001
From: Roger Ferrer Ibanez <roger.ferrer@bsc.es>
Date: Thu, 11 Jul 2019 22:38:32 +0200
Subject: [PATCH 3/5] Run yapf to format the python scripts

---
 src/frontend/gen-symbol-attrs.py |  992 +++++++++++++---------
 src/frontend/nodecl-generator.py | 1339 ++++++++++++++++++------------
 2 files changed, 1427 insertions(+), 904 deletions(-)

diff --git a/src/frontend/gen-symbol-attrs.py b/src/frontend/gen-symbol-attrs.py
index cdb8b3a57..c2a319579 100755
--- a/src/frontend/gen-symbol-attrs.py
+++ b/src/frontend/gen-symbol-attrs.py
@@ -29,16 +29,19 @@ import string
 
 import inspect
 
+
 def lineno():
     """Returns the current line number in our program."""
     return inspect.currentframe().f_back.f_lineno
 
+
 f = open(sys.argv[1])
 
 if (len(sys.argv) >= 3):
-  op = sys.argv[2]
+    op = sys.argv[2]
 else:
-  op = "entity_specifiers"
+    op = "entity_specifiers"
+
 
 def loadlines(f):
     lines = f.readlines()
@@ -52,10 +55,11 @@ def loadlines(f):
 
 
 def check_file(lines):
-  for l in lines:
-      fields = l.split("|");
-      if len(fields) != 4:
-        raise Exception("Invalid number of fields")
+    for l in lines:
+        fields = l.split("|")
+        if len(fields) != 4:
+            raise Exception("Invalid number of fields")
+
 
 def get_up_to_matching_paren(s):
     if (s[0] != '('):
@@ -66,7 +70,7 @@ def get_up_to_matching_paren(s):
         if (c == '('):
             level = level + 1
         elif (c == ')'):
-            level = level-1
+            level = level - 1
             if (level == 0):
                 return s[1:i]
         else:
@@ -80,6 +84,7 @@ class TypeKind:
     POINTER = 3
     OTHER = 5
 
+
 def print_type_and_name(_type, name):
     _type = _type.strip(" \n")
     if (_type == "bool"):
@@ -100,15 +105,17 @@ def print_type_and_name(_type, name):
         return [("const decl_context_t*", name, "", TypeKind.OTHER)]
     elif (_type.startswith("typeof")):
         parts_of_type_name = get_up_to_matching_paren(_type[len("typeof"):])
-        parts_of_type = parts_of_type_name.split(",");
+        parts_of_type = parts_of_type_name.split(",")
         type_name = parts_of_type[0].strip()
         if (len(parts_of_type) == 1):
             kind = TypeKind.OTHER
         elif (len(parts_of_type) == 2):
-            map_kinds = { "pointer" : TypeKind.POINTER,
-                          "intptr" : TypeKind.POINTER,
-                          "integer" : TypeKind.INTEGER,
-                          "enum" : TypeKind.INTEGER }
+            map_kinds = {
+                "pointer": TypeKind.POINTER,
+                "intptr": TypeKind.POINTER,
+                "integer": TypeKind.INTEGER,
+                "enum": TypeKind.INTEGER
+            }
             kind = map_kinds.get(parts_of_type[1].strip(), TypeKind.OTHER)
         return [(type_name, name, "", kind)]
     elif (_type.startswith("pointer")):
@@ -119,32 +126,36 @@ def print_type_and_name(_type, name):
         type_name = get_up_to_matching_paren(_type[len("array"):])
         field_names = name.split(",")
         if (len(field_names) == 1):
-           num_name = "num_" + name
-           list_name = name
+            num_name = "num_" + name
+            list_name = name
         elif (len(field_names) == 2):
             num_name = field_names[0]
             list_name = field_names[1]
         else:
-            raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-        return print_type_and_name("integer", num_name) + print_type_and_name("pointer(" + type_name + ")", list_name)
+            raise Exception(
+                "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+            )
+        return print_type_and_name("integer", num_name) + print_type_and_name(
+            "pointer(" + type_name + ")", list_name)
     else:
         raise Exception("Invalid type %s" % (_type))
 
+
 def print_entity_specifiers(lines):
     indent = " " * 4
     current_language = "all"
     decls = []
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          name = name[1:]
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            name = name[1:]
 
-      language = language.strip(" \n")
-      if (language != current_language) :
-          current_language = language
-      descr = description.strip(" \n")
-      decls += print_type_and_name(_type, name)
+        language = language.strip(" \n")
+        if (language != current_language):
+            current_language = language
+        descr = description.strip(" \n")
+        decls += print_type_and_name(_type, name)
 
     print("""
 #ifndef CXX_ENTITY_SPECIFIERS_H
@@ -156,16 +167,19 @@ def print_entity_specifiers(lines):
 
 typedef struct entity_specifiers_tag\n{""")
 
-    for tk in [TypeKind.OTHER, TypeKind.POINTER, TypeKind.INTEGER, TypeKind.BIT]:
-       for d in decls:
-         (typename, name, suffix, k) = d
-         if k == tk:
-             print(indent + typename + " " + name + suffix + ";")
+    for tk in [
+            TypeKind.OTHER, TypeKind.POINTER, TypeKind.INTEGER, TypeKind.BIT
+    ]:
+        for d in decls:
+            (typename, name, suffix, k) = d
+            if k == tk:
+                print(indent + typename + " " + name + suffix + ";")
 
     print("} entity_specifiers_t;")
     print("")
     print("#endif")
 
+
 def print_getters_setters(lines):
     print("""
 #ifndef CXX_ENTITY_SPECIFIERS_OPS_H
@@ -185,450 +199,618 @@ def print_getters_setters(lines):
     current_language = "all"
     decls = []
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          name = name[1:]
-
-      # Atomic types
-      if (_type in ["integer", "bool", "string", "AST", "nodecl", "type", "symbol"]) or _type.startswith("typeof"):
-         decls = print_type_and_name(_type, name)
-         if len(decls) != 1:
-             raise Exception("Expecting one declaration")
-         (typename, name, suffix, k) = decls[0]
-         print("// Single value attribute: '%s' " % (name))
-         print("static inline %s symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (typename, name, name))
-         print("static inline void symbol_entity_specs_set_%s(scope_entry_t* s, %s v)\n{\n    s->_entity_specs.%s = v;\n}" % (name, typename, name))
-         print("")
-      # Compound types
-      elif _type.startswith("array"):
-          type_name = get_up_to_matching_paren(_type[len("array"):])
-          field_names = name.split(",")
-          if (len(field_names) == 1):
-             num_name = "num_" + name
-             list_name = name
-          elif (len(field_names) == 2):
-              num_name = field_names[0]
-              list_name = field_names[1]
-          else:
-              raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-
-          decls = print_type_and_name(type_name, "")
-          if len(decls) != 1:
-              raise Exception("Expecting one declaration")
-          (type_name, _name, _suffix, _k) = decls[0]
-
-          # These types cannot be compared in C
-          cannot_be_compared = ["function_parameter_info_t", "gcc_attribute_t"]
-
-          print("// Multiple value attribute: '%s' " % (list_name))
-          if num_name != "num_" + name:
-              print("// Note: The number of values of this attribute is stored in attribute '%s'" % (num_name))
-
-          print("static inline int symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}" % (num_name, num_name))
-          print("static inline %s symbol_entity_specs_get_%s_num(scope_entry_t* s, int i)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n        i, s->_entity_specs.%s);\n    return s->_entity_specs.%s[i];\n}" % (type_name, list_name, num_name, num_name, list_name))
-          print("static inline void symbol_entity_specs_set_%s_num(scope_entry_t* s, int i, %s v)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n         i, s->_entity_specs.%s);\n    s->_entity_specs.%s[i] = v;\n}" % (list_name, type_name, num_name, num_name, list_name))
-          print("static inline void symbol_entity_specs_append_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
-          if type_name not in cannot_be_compared:
-              print("static inline void symbol_entity_specs_remove_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_REMOVE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
-              print("static inline void symbol_entity_specs_insert_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD_ONCE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}" % (list_name, type_name, list_name, num_name))
-          print("static inline void symbol_entity_specs_remove_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_REMOVE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name))
-          print("static inline void symbol_entity_specs_insert_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_ADD_ONCE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}" % (list_name, type_name, type_name, type_name, list_name, num_name))
-          print("static inline void symbol_entity_specs_add_%s(scope_entry_t* s, %s item)\n{\n    symbol_entity_specs_append_%s(s, item);\n}" % (list_name, type_name, list_name))
-          print("static inline void symbol_entity_specs_reserve_%s(scope_entry_t* s, int num)\n{\n    s->_entity_specs.%s = num;\n    s->_entity_specs.%s = NEW_VEC0(%s, num);\n}" % (list_name, num_name, list_name, type_name))
-          # print "static inline void symbol_entity_specs_clear_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = NULL;\n    s->_entity_specs.%s = 0;\n}" % (list_name, list_name, num_name)
-          print("static inline void symbol_entity_specs_free_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = 0;\n    DELETE(s->_entity_specs.%s);\n    s->_entity_specs.%s = NULL;\n}" % (list_name, num_name, list_name, list_name))
-          print("static inline void symbol_entity_specs_copy_%s_from(scope_entry_t* dest, scope_entry_t* source)\n{\n    symbol_entity_specs_reserve_%s(dest, source->_entity_specs.%s);\n    memcpy(dest->_entity_specs.%s,\n        source->_entity_specs.%s,\n        dest->_entity_specs.%s\n        * (sizeof (*(dest->_entity_specs.%s))));\n} " % (list_name, list_name, num_name, list_name, list_name, num_name, list_name))
-          print("")
-
-    print("static inline void symbol_entity_specs_copy_from(scope_entry_t* dest, scope_entry_t* source)")
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            name = name[1:]
+
+        # Atomic types
+        if (_type in
+            ["integer", "bool", "string", "AST", "nodecl", "type", "symbol"]
+            ) or _type.startswith("typeof"):
+            decls = print_type_and_name(_type, name)
+            if len(decls) != 1:
+                raise Exception("Expecting one declaration")
+            (typename, name, suffix, k) = decls[0]
+            print("// Single value attribute: '%s' " % (name))
+            print(
+                "static inline %s symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}"
+                % (typename, name, name))
+            print(
+                "static inline void symbol_entity_specs_set_%s(scope_entry_t* s, %s v)\n{\n    s->_entity_specs.%s = v;\n}"
+                % (name, typename, name))
+            print("")
+        # Compound types
+        elif _type.startswith("array"):
+            type_name = get_up_to_matching_paren(_type[len("array"):])
+            field_names = name.split(",")
+            if (len(field_names) == 1):
+                num_name = "num_" + name
+                list_name = name
+            elif (len(field_names) == 2):
+                num_name = field_names[0]
+                list_name = field_names[1]
+            else:
+                raise Exception(
+                    "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+                )
+
+            decls = print_type_and_name(type_name, "")
+            if len(decls) != 1:
+                raise Exception("Expecting one declaration")
+            (type_name, _name, _suffix, _k) = decls[0]
+
+            # These types cannot be compared in C
+            cannot_be_compared = [
+                "function_parameter_info_t", "gcc_attribute_t"
+            ]
+
+            print("// Multiple value attribute: '%s' " % (list_name))
+            if num_name != "num_" + name:
+                print(
+                    "// Note: The number of values of this attribute is stored in attribute '%s'"
+                    % (num_name))
+
+            print(
+                "static inline int symbol_entity_specs_get_%s(scope_entry_t* s)\n{\n    return s->_entity_specs.%s;\n}"
+                % (num_name, num_name))
+            print(
+                "static inline %s symbol_entity_specs_get_%s_num(scope_entry_t* s, int i)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n        i, s->_entity_specs.%s);\n    return s->_entity_specs.%s[i];\n}"
+                % (type_name, list_name, num_name, num_name, list_name))
+            print(
+                "static inline void symbol_entity_specs_set_%s_num(scope_entry_t* s, int i, %s v)\n{\n    ERROR_CONDITION(i >= s->_entity_specs.%s,\n        \"Invalid index %%d >= %%d\",\n         i, s->_entity_specs.%s);\n    s->_entity_specs.%s[i] = v;\n}"
+                % (list_name, type_name, num_name, num_name, list_name))
+            print(
+                "static inline void symbol_entity_specs_append_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}"
+                % (list_name, type_name, list_name, num_name))
+            if type_name not in cannot_be_compared:
+                print(
+                    "static inline void symbol_entity_specs_remove_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_REMOVE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}"
+                    % (list_name, type_name, list_name, num_name))
+                print(
+                    "static inline void symbol_entity_specs_insert_%s(scope_entry_t* s, %s item)\n{\n    P_LIST_ADD_ONCE(s->_entity_specs.%s, s->_entity_specs.%s, item);\n}"
+                    % (list_name, type_name, list_name, num_name))
+            print(
+                "static inline void symbol_entity_specs_remove_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_REMOVE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}"
+                % (list_name, type_name, type_name, type_name, list_name,
+                   num_name))
+            print(
+                "static inline void symbol_entity_specs_insert_%s_cmp(scope_entry_t* s, %s item,\n        char (*cmp)(%s, %s))\n{\n    P_LIST_ADD_ONCE_FUN(s->_entity_specs.%s, s->_entity_specs.%s, item, cmp);\n}"
+                % (list_name, type_name, type_name, type_name, list_name,
+                   num_name))
+            print(
+                "static inline void symbol_entity_specs_add_%s(scope_entry_t* s, %s item)\n{\n    symbol_entity_specs_append_%s(s, item);\n}"
+                % (list_name, type_name, list_name))
+            print(
+                "static inline void symbol_entity_specs_reserve_%s(scope_entry_t* s, int num)\n{\n    s->_entity_specs.%s = num;\n    s->_entity_specs.%s = NEW_VEC0(%s, num);\n}"
+                % (list_name, num_name, list_name, type_name))
+            # print "static inline void symbol_entity_specs_clear_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = NULL;\n    s->_entity_specs.%s = 0;\n}" % (list_name, list_name, num_name)
+            print(
+                "static inline void symbol_entity_specs_free_%s(scope_entry_t* s)\n{\n    s->_entity_specs.%s = 0;\n    DELETE(s->_entity_specs.%s);\n    s->_entity_specs.%s = NULL;\n}"
+                % (list_name, num_name, list_name, list_name))
+            print(
+                "static inline void symbol_entity_specs_copy_%s_from(scope_entry_t* dest, scope_entry_t* source)\n{\n    symbol_entity_specs_reserve_%s(dest, source->_entity_specs.%s);\n    memcpy(dest->_entity_specs.%s,\n        source->_entity_specs.%s,\n        dest->_entity_specs.%s\n        * (sizeof (*(dest->_entity_specs.%s))));\n} "
+                % (list_name, list_name, num_name, list_name, list_name,
+                   num_name, list_name))
+            print("")
+
+    print(
+        "static inline void symbol_entity_specs_copy_from(scope_entry_t* dest, scope_entry_t* source)"
+    )
     print("{")
     print("    dest->_entity_specs = source->_entity_specs;")
     # Now copy every list
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          name = name[1:]
-      if _type.startswith("array"):
-          type_name = get_up_to_matching_paren(_type[len("array"):])
-          field_names = name.split(",")
-          if (len(field_names) == 1):
-             num_name = "num_" + name
-             list_name = name
-          elif (len(field_names) == 2):
-              num_name = field_names[0]
-              list_name = field_names[1]
-          else:
-              raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-          print("    symbol_entity_specs_copy_%s_from(dest, source);" % (list_name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            name = name[1:]
+        if _type.startswith("array"):
+            type_name = get_up_to_matching_paren(_type[len("array"):])
+            field_names = name.split(",")
+            if (len(field_names) == 1):
+                num_name = "num_" + name
+                list_name = name
+            elif (len(field_names) == 2):
+                num_name = field_names[0]
+                list_name = field_names[1]
+            else:
+                raise Exception(
+                    "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+                )
+            print("    symbol_entity_specs_copy_%s_from(dest, source);" %
+                  (list_name))
     print("}")
     print("")
     print("static inline void symbol_entity_specs_free(scope_entry_t* symbol)")
     print("{")
     # Now copy every list
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          name = name[1:]
-      if _type.startswith("array"):
-          type_name = get_up_to_matching_paren(_type[len("array"):])
-          field_names = name.split(",")
-          if (len(field_names) == 1):
-             num_name = "num_" + name
-             list_name = name
-          elif (len(field_names) == 2):
-              num_name = field_names[0]
-              list_name = field_names[1]
-          else:
-              raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-          print("    symbol_entity_specs_free_%s(symbol);" % (list_name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            name = name[1:]
+        if _type.startswith("array"):
+            type_name = get_up_to_matching_paren(_type[len("array"):])
+            field_names = name.split(",")
+            if (len(field_names) == 1):
+                num_name = "num_" + name
+                list_name = name
+            elif (len(field_names) == 2):
+                num_name = field_names[0]
+                list_name = field_names[1]
+            else:
+                raise Exception(
+                    "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+                )
+            print("    symbol_entity_specs_free_%s(symbol);" % (list_name))
     print("}")
 
     print("#endif")
 
+
 def insert_extra_attr_code(_type, name, getter, getter_extra_args):
     _insert_code = []
-    if (_type == "integer") :
-        _insert_code.append("insert_extra_attr_int(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+    if (_type == "integer"):
+        _insert_code.append(
+            "insert_extra_attr_int(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "bool"):
-        _insert_code.append("insert_extra_attr_int(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_int(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "string"):
-        _insert_code.append("insert_extra_attr_string(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_string(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "AST"):
-        _insert_code.append("insert_extra_attr_ast(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_ast(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "nodecl"):
-        _insert_code.append("insert_extra_attr_nodecl(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_nodecl(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "type"):
-        _insert_code.append("insert_extra_attr_type(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_type(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type == "symbol"):
-        _insert_code.append("insert_extra_attr_symbol(handle, sym, \"%s\", %s(sym%s));" % (name, getter, getter_extra_args))
+        _insert_code.append(
+            "insert_extra_attr_symbol(handle, sym, \"%s\", %s(sym%s));" %
+            (name, getter, getter_extra_args))
     elif (_type.startswith("array")):
         type_name = get_up_to_matching_paren(_type[len("array"):])
         field_names = name.split(",")
         if (len(field_names) == 1):
-           num_name = "num_" + name
-           list_name = name
+            num_name = "num_" + name
+            list_name = name
         elif (len(field_names) == 2):
             num_name = field_names[0]
             list_name = field_names[1]
         else:
-            raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-        _insert_code.append("{ int i; for (i = 0; i < symbol_entity_specs_get_%s(sym); i++) {" % (num_name));
+            raise Exception(
+                "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+            )
         _insert_code.append(
-                    "\n".join(insert_extra_attr_code(type_name, list_name, "symbol_entity_specs_get_%s_num" % (list_name), ", i")))
-        _insert_code.append("} }");
+            "{ int i; for (i = 0; i < symbol_entity_specs_get_%s(sym); i++) {"
+            % (num_name))
+        _insert_code.append("\n".join(
+            insert_extra_attr_code(type_name, list_name,
+                                   "symbol_entity_specs_get_%s_num" % (
+                                       list_name), ", i")))
+        _insert_code.append("} }")
     elif (_type.startswith("typeof")):
         type_name = get_up_to_matching_paren(_type[len("typeof"):])
-        if type_name == "gcc_attribute_t" :
-            _insert_code.append("{");
-            _insert_code.append("gcc_attribute_t gcc_attr = %s(sym%s);" % (getter, getter_extra_args));
-            _insert_code.append("insert_extra_gcc_attr(handle, sym, \"%s\", &gcc_attr);" % (name))
+        if type_name == "gcc_attribute_t":
+            _insert_code.append("{")
+            _insert_code.append("gcc_attribute_t gcc_attr = %s(sym%s);" %
+                                (getter, getter_extra_args))
+            _insert_code.append(
+                "insert_extra_gcc_attr(handle, sym, \"%s\", &gcc_attr);" %
+                (name))
             _insert_code.append("}")
-        elif type_name == "default_argument_info_t*" :
-            _insert_code.append("{");
-            _insert_code.append("default_argument_info_t* default_arg = %s(sym%s);" % (getter, getter_extra_args))
+        elif type_name == "default_argument_info_t*":
+            _insert_code.append("{")
+            _insert_code.append(
+                "default_argument_info_t* default_arg = %s(sym%s);" %
+                (getter, getter_extra_args))
             _insert_code.append("insert_extra_attr_data(handle, sym, \"%s\", default_arg, "\
-                    "insert_default_argument_info_ptr);" % (name));
+                    "insert_default_argument_info_ptr);" % (name))
             _insert_code.append("}")
         elif type_name == "function_parameter_info_t":
-            _insert_code.append("function_parameter_info_t function_param = %s(sym%s);" % (getter, getter_extra_args))
-            _insert_code.append("insert_extra_function_parameter_info(handle, sym, \"%s\", &function_param);" % (name))
+            _insert_code.append(
+                "function_parameter_info_t function_param = %s(sym%s);" %
+                (getter, getter_extra_args))
+            _insert_code.append(
+                "insert_extra_function_parameter_info(handle, sym, \"%s\", &function_param);"
+                % (name))
         else:
-            sys.stderr.write("%s:%d: warning: typeof '%s' is not handled\n" % (sys.argv[0], lineno(), type_name))
+            sys.stderr.write("%s:%d: warning: typeof '%s' is not handled\n" %
+                             (sys.argv[0], lineno(), type_name))
     else:
         pass
     return _insert_code
 
+
 def get_extra_load_code(_type, num_name, list_name):
     result = []
     if (_type == "symbol"):
         result.append("{")
         result.append("extra_syms_t extra_syms;")
         result.append("memset(&extra_syms, 0, sizeof(extra_syms));")
-        result.append("extra_syms.handle = handle;");
-        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_syms, get_extra_syms);")
-        result.append("int i;");
+        result.append("extra_syms.handle = handle;")
+        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name
+                      + "\", &extra_syms, get_extra_syms);")
+        result.append("int i;")
         result.append("for (i = 0; i < extra_syms.num_syms; i++)")
         result.append("{")
-        result.append("symbol_entity_specs_append_%s(sym, extra_syms.syms[i]);" % (list_name))
+        result.append("symbol_entity_specs_append_%s(sym, extra_syms.syms[i]);"
+                      % (list_name))
         result.append("}")
         result.append("}")
     elif (_type == "type"):
         result.append("{")
         result.append("extra_types_t extra_types;")
         result.append("memset(&extra_types, 0, sizeof(extra_types));")
-        result.append("extra_types.handle = handle;");
-        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_types, get_extra_types);")
-        result.append("int i;");
+        result.append("extra_types.handle = handle;")
+        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name
+                      + "\", &extra_types, get_extra_types);")
+        result.append("int i;")
         result.append("for (i = 0; i < extra_types.num_types; i++)")
         result.append("{")
-        result.append("symbol_entity_specs_append_%s(sym, extra_types.types[i]);" % (list_name))
+        result.append(
+            "symbol_entity_specs_append_%s(sym, extra_types.types[i]);" %
+            (list_name))
         result.append("}")
         result.append("}")
     elif (_type == "AST"):
         result.append("{")
         result.append("extra_trees_t extra_trees;")
         result.append("memset(&extra_trees, 0, sizeof(extra_trees));")
-        result.append("extra_trees.handle = handle;");
-        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_trees, get_extra_trees);")
-        result.append("int i;");
+        result.append("extra_trees.handle = handle;")
+        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name
+                      + "\", &extra_trees, get_extra_trees);")
+        result.append("int i;")
         result.append("for (i = 0; i < extra_trees.num_trees; i++)")
         result.append("{")
-        result.append("symbol_entity_specs_append_%s(sym, extra_trees.trees[i]);" % (list_name))
+        result.append(
+            "symbol_entity_specs_append_%s(sym, extra_trees.trees[i]);" %
+            (list_name))
         result.append("}")
         result.append("}")
     elif (_type == "nodecl"):
         result.append("{")
         result.append("extra_nodecls_t extra_nodecls;")
         result.append("memset(&extra_nodecls, 0, sizeof(extra_nodecls));")
-        result.append("extra_nodecls.handle = handle;");
-        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_nodecls, get_extra_nodecls);")
-        result.append("int i;");
+        result.append("extra_nodecls.handle = handle;")
+        result.append("get_extended_attribute(handle, sym_oid, \"" + list_name
+                      + "\", &extra_nodecls, get_extra_nodecls);")
+        result.append("int i;")
         result.append("for (i = 0; i < extra_nodecls.num_nodecls; i++)")
         result.append("{")
-        result.append("symbol_entity_specs_append_%s(sym, extra_nodecls.nodecls[i]);" % (list_name))
+        result.append(
+            "symbol_entity_specs_append_%s(sym, extra_nodecls.nodecls[i]);" %
+            (list_name))
         result.append("}")
         result.append("}")
     elif (_type.startswith("typeof")):
         type_name = get_up_to_matching_paren(_type[len("typeof"):])
-        if type_name == "gcc_attribute_t" :
+        if type_name == "gcc_attribute_t":
             result.append("{")
-            result.append("extra_gcc_attrs_t extra_gcc_attrs;");
-            result.append("memset(&extra_gcc_attrs, 0, sizeof(extra_gcc_attrs));");
-            result.append("extra_gcc_attrs.handle = handle;");
-            result.append("extra_gcc_attrs.symbol = sym;");
-            result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_gcc_attrs, get_extra_gcc_attrs);");
+            result.append("extra_gcc_attrs_t extra_gcc_attrs;")
+            result.append(
+                "memset(&extra_gcc_attrs, 0, sizeof(extra_gcc_attrs));")
+            result.append("extra_gcc_attrs.handle = handle;")
+            result.append("extra_gcc_attrs.symbol = sym;")
+            result.append("get_extended_attribute(handle, sym_oid, \"" +
+                          list_name +
+                          "\", &extra_gcc_attrs, get_extra_gcc_attrs);")
             result.append("}")
-        elif type_name == "function_parameter_info_t" :
+        elif type_name == "function_parameter_info_t":
             result.append("{")
-            result.append("extra_gcc_attrs_t extra_gcc_attrs;");
-            result.append("memset(&extra_gcc_attrs, 0, sizeof(extra_gcc_attrs));");
-            result.append("extra_gcc_attrs.handle = handle;");
-            result.append("extra_gcc_attrs.symbol = sym;");
-            result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_gcc_attrs, get_extra_function_parameter_info);");
+            result.append("extra_gcc_attrs_t extra_gcc_attrs;")
+            result.append(
+                "memset(&extra_gcc_attrs, 0, sizeof(extra_gcc_attrs));")
+            result.append("extra_gcc_attrs.handle = handle;")
+            result.append("extra_gcc_attrs.symbol = sym;")
+            result.append(
+                "get_extended_attribute(handle, sym_oid, \"" + list_name +
+                "\", &extra_gcc_attrs, get_extra_function_parameter_info);")
             result.append("}")
-        elif type_name == "default_argument_info_t*" :
+        elif type_name == "default_argument_info_t*":
             result.append("{")
-            result.append("extra_default_argument_info_t extra_default_argument_info;")
-            result.append("memset(&extra_default_argument_info, 0, sizeof(extra_default_argument_info_t));")
-            result.append("extra_default_argument_info.handle = handle;");
-            result.append("extra_default_argument_info.symbol = sym;");
-            result.append("get_extended_attribute(handle, sym_oid, \"" + list_name + "\", &extra_default_argument_info, \
+            result.append(
+                "extra_default_argument_info_t extra_default_argument_info;")
+            result.append(
+                "memset(&extra_default_argument_info, 0, sizeof(extra_default_argument_info_t));"
+            )
+            result.append("extra_default_argument_info.handle = handle;")
+            result.append("extra_default_argument_info.symbol = sym;")
+            result.append("get_extended_attribute(handle, sym_oid, \"" +
+                          list_name + "\", &extra_default_argument_info, \
                     get_extra_default_argument_info);")
             result.append("}")
         else:
             pass
     else:
-        sys.stderr.write("%s:%d: warning: unknown array type '%s'\n" % (sys.argv[0], lineno(), _type))
-    return "\n".join(result);
+        sys.stderr.write("%s:%d: warning: unknown array type '%s'\n" %
+                         (sys.argv[0], lineno(), _type))
+    return "\n".join(result)
+
 
 def get_load_code(_type, name):
     result = []
-    result.append("{");
-    if (_type == "integer") :
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+    result.append("{")
+    if (_type == "integer"):
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, safe_atoull(values[i]));" % (name));
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, safe_atoull(values[i]));" %
+            (name))
         result.append("}")
     elif (_type == "string"):
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, uniquestr(values[i]));" % (name));
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, uniquestr(values[i]));" %
+            (name))
         result.append("}")
     elif (_type == "AST"):
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, load_ast(handle, safe_atoull(values[i])));" % (name))
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, load_ast(handle, safe_atoull(values[i])));"
+            % (name))
         result.append("}")
     elif (_type == "nodecl"):
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, load_nodecl(handle, safe_atoull(values[i])));" % (name))
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, load_nodecl(handle, safe_atoull(values[i])));"
+            % (name))
         result.append("}")
     elif (_type == "type"):
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, load_type(handle, safe_atoull(values[i])));" % (name))
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, load_type(handle, safe_atoull(values[i])));"
+            % (name))
         result.append("}")
     elif (_type == "symbol"):
-        result.append("int i;");
-        result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+        result.append("int i;")
+        result.append("if (query_contains_field(ncols, names, \"" + name +
+                      "\", &i))")
         result.append("{")
-        result.append("   symbol_entity_specs_set_%s(sym, load_symbol(handle, safe_atoull(values[i])));" % (name))
+        result.append(
+            "   symbol_entity_specs_set_%s(sym, load_symbol(handle, safe_atoull(values[i])));"
+            % (name))
         result.append("}")
     elif (_type.startswith("array")):
         type_name = get_up_to_matching_paren(_type[len("array"):])
         field_names = name.split(",")
         if (len(field_names) == 1):
-           num_name = "num_" + name
-           list_name = name
+            num_name = "num_" + name
+            list_name = name
         elif (len(field_names) == 2):
             num_name = field_names[0]
             list_name = field_names[1]
         else:
-            raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
+            raise Exception(
+                "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+            )
 
         result.append(get_extra_load_code(type_name, num_name, list_name))
     elif (_type.startswith("typeof")):
-        type_name = get_up_to_matching_paren(_type[len("typeof"):]).split(",")[0].strip()
+        type_name = get_up_to_matching_paren(
+            _type[len("typeof"):]).split(",")[0].strip()
         if type_name in ["intent_kind_t", "access_specifier_t", "_size_t"]:
-            result.append("int i;");
-            result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+            result.append("int i;")
+            result.append("if (query_contains_field(ncols, names, \"" + name +
+                          "\", &i))")
             result.append("{")
-            result.append("   symbol_entity_specs_set_%s(sym, safe_atoull(values[i]));" % (name));
+            result.append(
+                "   symbol_entity_specs_set_%s(sym, safe_atoull(values[i]));" %
+                (name))
             result.append("}")
         elif type_name == "simplify_function_t":
-            result.append("int i;");
-            result.append("if (query_contains_field(ncols, names, \"" + name + "\", &i))");
+            result.append("int i;")
+            result.append("if (query_contains_field(ncols, names, \"" + name +
+                          "\", &i))")
             result.append("{")
             result.append("   int id = safe_atoull(values[i]);")
-            result.append("   simplify_function_t fun = fortran_simplify_function_get_ptr(id);" )
+            result.append(
+                "   simplify_function_t fun = fortran_simplify_function_get_ptr(id);"
+            )
             result.append("   ERROR_CONDITION(fun == NULL && id != 0, " \
                 "\"Invalid identifier %d for simplification function.\\nYou may have to rebuild your Fortran modules\", id);")
-            result.append("   symbol_entity_specs_set_%s(sym, fortran_simplify_function_get_ptr(safe_atoull(values[i])));" % (name));
+            result.append(
+                "   symbol_entity_specs_set_%s(sym, fortran_simplify_function_get_ptr(safe_atoull(values[i])));"
+                % (name))
             result.append("}")
         else:
-            sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" % (sys.argv[0], lineno(), type_name))
+            sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" %
+                             (sys.argv[0], lineno(), type_name))
         pass
     elif (_type == "scope"):
-        result.append("// Scope is not stored (yet)");
-        result.append("symbol_entity_specs_set_%s(sym, CURRENT_COMPILED_FILE->global_decl_context;" % (name));
+        result.append("// Scope is not stored (yet)")
+        result.append(
+            "symbol_entity_specs_set_%s(sym, CURRENT_COMPILED_FILE->global_decl_context;"
+            % (name))
     elif (_type == "bool"):
         # Booleans are handled apart
         pass
-    else :
-        sys.stderr.write("%s:%d: warning: not handling '%s'\n" % (sys.argv[0], lineno(), type_name))
+    else:
+        sys.stderr.write("%s:%d: warning: not handling '%s'\n" %
+                         (sys.argv[0], lineno(), type_name))
         pass
-    result.append("}");
-    return "\n".join(result);
+    result.append("}")
+    return "\n".join(result)
 
 
 def print_fortran_modules_functions(lines):
     attr_names = []
     sprintf_arguments = []
     _format = []
-    _insert_code = [];
+    _insert_code = []
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if (name[0] == "*"):
-          continue
-      if (_type == "bool"):
-          # Booleans are handled different
-          pass
-      elif (_type == "integer"):
-          attr_names.append(name)
-          _format.append("%d")
-          sprintf_arguments.append("symbol_entity_specs_get_%s(sym)" % (name))
-      elif (_type == "AST"):
-          attr_names.append(name)
-          _format.append("%llu")
-          _insert_code.append("    insert_ast(handle, symbol_entity_specs_get_%s(sym));" % (name));
-          sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" % (name))
-      elif (_type == "nodecl"):
-          attr_names.append(name)
-          _format.append("%llu")
-          _insert_code.append("    insert_nodecl(handle, symbol_entity_specs_get_%s(sym));" % (name));
-          sprintf_arguments.append("P2ULL(nodecl_get_ast(symbol_entity_specs_get_%s(sym)))" % (name))
-      elif (_type == "type"):
-          attr_names.append(name)
-          _format.append("%llu")
-          _insert_code.append("    insert_type(handle, symbol_entity_specs_get_%s(sym));" % (name));
-          sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" % (name))
-      elif (_type == "symbol"):
-          attr_names.append(name)
-          _format.append("%llu")
-          _insert_code.append("    insert_symbol(handle, symbol_entity_specs_get_%s(sym));" % (name));
-          sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" % (name))
-      elif (_type == "string"):
-          attr_names.append(name)
-          _format.append("%Q")
-          sprintf_arguments.append("symbol_entity_specs_get_%s(sym)" % (name))
-      elif (_type.startswith("typeof")):
-            type_name = get_up_to_matching_paren(_type[len("typeof"):]).split(",")[0].strip()
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if (name[0] == "*"):
+            continue
+        if (_type == "bool"):
+            # Booleans are handled different
+            pass
+        elif (_type == "integer"):
+            attr_names.append(name)
+            _format.append("%d")
+            sprintf_arguments.append("symbol_entity_specs_get_%s(sym)" %
+                                     (name))
+        elif (_type == "AST"):
+            attr_names.append(name)
+            _format.append("%llu")
+            _insert_code.append(
+                "    insert_ast(handle, symbol_entity_specs_get_%s(sym));" %
+                (name))
+            sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" %
+                                     (name))
+        elif (_type == "nodecl"):
+            attr_names.append(name)
+            _format.append("%llu")
+            _insert_code.append(
+                "    insert_nodecl(handle, symbol_entity_specs_get_%s(sym));" %
+                (name))
+            sprintf_arguments.append(
+                "P2ULL(nodecl_get_ast(symbol_entity_specs_get_%s(sym)))" %
+                (name))
+        elif (_type == "type"):
+            attr_names.append(name)
+            _format.append("%llu")
+            _insert_code.append(
+                "    insert_type(handle, symbol_entity_specs_get_%s(sym));" %
+                (name))
+            sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" %
+                                     (name))
+        elif (_type == "symbol"):
+            attr_names.append(name)
+            _format.append("%llu")
+            _insert_code.append(
+                "    insert_symbol(handle, symbol_entity_specs_get_%s(sym));" %
+                (name))
+            sprintf_arguments.append("P2ULL(symbol_entity_specs_get_%s(sym))" %
+                                     (name))
+        elif (_type == "string"):
+            attr_names.append(name)
+            _format.append("%Q")
+            sprintf_arguments.append("symbol_entity_specs_get_%s(sym)" %
+                                     (name))
+        elif (_type.startswith("typeof")):
+            type_name = get_up_to_matching_paren(
+                _type[len("typeof"):]).split(",")[0].strip()
             if type_name == "intent_kind_t" or type_name == "access_specifier_t":
                 attr_names.append(name)
                 _format.append("%d")
-                sprintf_arguments.append("(int)symbol_entity_specs_get_%s(sym)" % (name))
+                sprintf_arguments.append("(int)symbol_entity_specs_get_%s(sym)"
+                                         % (name))
             elif type_name == "_size_t":
                 attr_names.append(name)
                 _format.append("%llu")
-                sprintf_arguments.append("(unsigned long long)symbol_entity_specs_get_%s(sym)" % (name))
+                sprintf_arguments.append(
+                    "(unsigned long long)symbol_entity_specs_get_%s(sym)" %
+                    (name))
             elif type_name == "simplify_function_t":
-                attr_names.append(name);
+                attr_names.append(name)
                 _format.append("%d")
-                sprintf_arguments.append("fortran_simplify_function_get_id(symbol_entity_specs_get_%s(sym))" % (name))
+                sprintf_arguments.append(
+                    "fortran_simplify_function_get_id(symbol_entity_specs_get_%s(sym))"
+                    % (name))
             else:
-                sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" % (sys.argv[0], lineno(), type_name))
-      else:
-          pass
+                sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" %
+                                 (sys.argv[0], lineno(), type_name))
+        else:
+            pass
     print("#ifndef FORTRAN03_MODULES_BITS_H")
     print("#define FORTRAN03_MODULES_BITS_H")
     print("")
-    print("static const char * attr_field_names = \"" + ", ".join(attr_names) + "\";");
-    print("static char * symbol_get_attribute_values(sqlite3* handle, scope_entry_t* sym)")
+    print("static const char * attr_field_names = \"" + ", ".join(attr_names) +
+          "\";")
+    print(
+        "static char * symbol_get_attribute_values(sqlite3* handle, scope_entry_t* sym)"
+    )
     print("{")
     print("    const char *format = \"" + ", ".join(_format) + "\";")
     print("")
-    print("\n".join(_insert_code));
+    print("\n".join(_insert_code))
     print("")
-    print("    char * result = sqlite3_mprintf(format, " + ", ".join(sprintf_arguments) + ");")
+    print("    char * result = sqlite3_mprintf(format, " + ", ".join(
+        sprintf_arguments) + ");")
     print("    return result;")
     print("}")
     _extra_attr_code = []
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          continue;
-      if (_type.startswith("array")):
-          _extra_attr_code = _extra_attr_code + insert_extra_attr_code(_type, name, "", "")
-      else:
-           pass
-    print("static void insert_extended_attributes(sqlite3* handle, scope_entry_t* sym)")
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            continue
+        if (_type.startswith("array")):
+            _extra_attr_code = _extra_attr_code + insert_extra_attr_code(
+                _type, name, "", "")
+        else:
+            pass
+    print(
+        "static void insert_extended_attributes(sqlite3* handle, scope_entry_t* sym)"
+    )
     print("{")
-    print("\n".join(_extra_attr_code));
+    print("\n".join(_extra_attr_code))
     print("}")
     print("")
-    print("static void get_extra_attributes(sqlite3* handle, int ncols, char **values, char **names, sqlite3_uint64 sym_oid, scope_entry_t* sym)")
+    print(
+        "static void get_extra_attributes(sqlite3* handle, int ncols, char **values, char **names, sqlite3_uint64 sym_oid, scope_entry_t* sym)"
+    )
     print("{")
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[0] == "*":
-          continue;
-      print(get_load_code(_type, name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[0] == "*":
+            continue
+        print(get_load_code(_type, name))
     print("}")
 
     print("typedef struct module_packed_bits_tag")
     print("{")
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[1] == "*":
-          continue;
-      if _type == "bool":
-          print("_Bool %s:1;" % (name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[1] == "*":
+            continue
+        if _type == "bool":
+            print("_Bool %s:1;" % (name))
     print("} module_packed_bits_t;")
 
-    print("static module_packed_bits_t synthesize_packed_bits(scope_entry_t* sym)")
+    print(
+        "static module_packed_bits_t synthesize_packed_bits(scope_entry_t* sym)"
+    )
     print("{")
     print("module_packed_bits_t result;")
     print("memset(&result, 0, sizeof(result));")
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[1] == "*":
-          continue;
-      if _type == "bool":
-          print("result.%s = symbol_entity_specs_get_%s(sym);" % (name, name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[1] == "*":
+            continue
+        if _type == "bool":
+            print("result.%s = symbol_entity_specs_get_%s(sym);" %
+                  (name, name))
     print("return result;")
     print("}")
 
@@ -643,15 +825,18 @@ def print_fortran_modules_functions(lines):
     #       print "_entity_specs->%s = bitpack.%s;" % (name, name)
     # print "}"
 
-    print("static void unpack_bits(scope_entry_t *sym, module_packed_bits_t bitpack)")
+    print(
+        "static void unpack_bits(scope_entry_t *sym, module_packed_bits_t bitpack)"
+    )
     print("{")
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if name[1] == "*":
-          continue;
-      if _type == "bool":
-          print("symbol_entity_specs_set_%s(sym, bitpack.%s);" % (name, name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if name[1] == "*":
+            continue
+        if _type == "bool":
+            print("symbol_entity_specs_set_%s(sym, bitpack.%s);" %
+                  (name, name))
     print("}")
 
     print("#endif // FORTRAN03_MODULES_BITS_H")
@@ -659,7 +844,9 @@ def print_fortran_modules_functions(lines):
 
 def print_deep_copy_entity_specs(lines):
     print("// DO NOT MODIFY THIS FILE.")
-    print("// It will be overwritten when gen-symbols-attrs.py or cxx-entity_specs.def are modified")
+    print(
+        "// It will be overwritten when gen-symbols-attrs.py or cxx-entity_specs.def are modified"
+    )
     print("#include \"cxx-scope.h\"")
     print("#include \"cxx-nodecl-deep-copy.h\"")
     print("#include \"cxx-typeutils.h\"")
@@ -673,86 +860,133 @@ def print_deep_copy_entity_specs(lines):
     {
     """)
     for l in lines:
-      fields = l.split("|");
-      (_type,language,name,description) = fields
-      if (name[0] == "*"):
-          name = name[1:]
-          continue
-      if name == "function_code":
-          print("// We do not copy function code!")
-          continue
-      if _type in ["bool", "integer"]:
-          print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
-      elif (_type == "scope"):
-          print("symbol_entity_specs_set_%s(dest, decl_context);")
-      elif (_type == "nodecl"):
-          print("symbol_entity_specs_set_%s(dest, nodecl_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name))
-      elif (_type == "type"):
-          print("symbol_entity_specs_set_%s(dest, type_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), /* symbol dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));" % (name, name))
-      elif (_type == "symbol"):
-          print("symbol_entity_specs_set_%s(dest, symbol_map->map(symbol_map, symbol_entity_specs_get_%s(source)));" % (name, name))
-      elif (_type == "string"):
-          print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
-      elif (_type.startswith("typeof")):
-            type_name = get_up_to_matching_paren(_type[len("typeof"):]).split(",")[0].strip()
-            if type_name in ["intent_kind_t", "access_specifier_t", "_size_t", "simplify_function_t"]:
-                print("symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));" % (name, name))
+        fields = l.split("|")
+        (_type, language, name, description) = fields
+        if (name[0] == "*"):
+            name = name[1:]
+            continue
+        if name == "function_code":
+            print("// We do not copy function code!")
+            continue
+        if _type in ["bool", "integer"]:
+            print(
+                "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));"
+                % (name, name))
+        elif (_type == "scope"):
+            print("symbol_entity_specs_set_%s(dest, decl_context);")
+        elif (_type == "nodecl"):
+            print(
+                "symbol_entity_specs_set_%s(dest, nodecl_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));"
+                % (name, name))
+        elif (_type == "type"):
+            print(
+                "symbol_entity_specs_set_%s(dest, type_deep_copy_compute_maps(symbol_entity_specs_get_%s(source), /* symbol dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map));"
+                % (name, name))
+        elif (_type == "symbol"):
+            print(
+                "symbol_entity_specs_set_%s(dest, symbol_map->map(symbol_map, symbol_entity_specs_get_%s(source)));"
+                % (name, name))
+        elif (_type == "string"):
+            print(
+                "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));"
+                % (name, name))
+        elif (_type.startswith("typeof")):
+            type_name = get_up_to_matching_paren(
+                _type[len("typeof"):]).split(",")[0].strip()
+            if type_name in [
+                    "intent_kind_t", "access_specifier_t", "_size_t",
+                    "simplify_function_t"
+            ]:
+                print(
+                    "symbol_entity_specs_set_%s(dest, symbol_entity_specs_get_%s(source));"
+                    % (name, name))
+            else:
+                sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" %
+                                 (sys.argv[0], lineno(), type_name))
+        elif (_type.startswith("array")):
+            type_name = get_up_to_matching_paren(_type[len("array"):])
+            field_names = name.split(",")
+            if (len(field_names) == 1):
+                num_name = "num_" + name
+                list_name = name
+            elif (len(field_names) == 2):
+                num_name = field_names[0]
+                list_name = field_names[1]
+            else:
+                raise Exception(
+                    "Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed"
+                )
+            if type_name.startswith("typeof"):
+                type_name = get_up_to_matching_paren(
+                    type_name[len("typeof"):]).split(",")[0].strip()
+            print("{")
+            print("symbol_entity_specs_free_%s(dest);" % (list_name))
+            print("int i, N = symbol_entity_specs_get_%s(source);" %
+                  (num_name))
+            print("for (i = 0; i < N; i++)")
+            print("{")
+            if type_name == "symbol":
+                print(
+                    "scope_entry_t* copied = symbol_map->map(symbol_map, symbol_entity_specs_get_%s_num(source, i));"
+                    % (list_name))
+                print("symbol_entity_specs_add_%s(dest, copied);" %
+                      (list_name))
+            elif type_name == "type":
+                print(
+                    "type_t* copied = type_deep_copy_compute_maps(symbol_entity_specs_get_%s_num(source, i), /* dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+                    % (list_name))
+                print("symbol_entity_specs_add_%s(dest, copied);" %
+                      (list_name))
+            elif type_name == "default_argument_info_t*":
+                print(
+                    "default_argument_info_t* source_default_arg = symbol_entity_specs_get_%s_num(source, i);"
+                    % (list_name))
+                print("default_argument_info_t* copied = NULL;")
+                print("if (source_default_arg != NULL)")
+                print("{")
+                print("  copied = NEW0(default_argument_info_t);")
+                print(
+                    "  copied->argument = nodecl_deep_copy_compute_maps(source_default_arg->argument, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+                )
+                print("  copied->context = decl_context;")
+                print("}")
+                print("symbol_entity_specs_add_%s(dest, copied);" %
+                      (list_name))
+            elif type_name == "gcc_attribute_t":
+                print(
+                    "gcc_attribute_t source_gcc_attr = symbol_entity_specs_get_%s_num(source, i);"
+                    % (list_name))
+                print("gcc_attribute_t copied;")
+                print(
+                    "copied.attribute_name = source_gcc_attr.attribute_name;")
+                print(
+                    "copied.expression_list = nodecl_deep_copy_compute_maps(source_gcc_attr.expression_list, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+                )
+                print("symbol_entity_specs_add_%s(dest, copied);" %
+                      (list_name))
+            elif type_name == "function_parameter_info_t":
+                print(
+                    "function_parameter_info_t param_info = symbol_entity_specs_get_%s_num(source, i);"
+                    % (list_name))
+                print(
+                    "param_info.function = symbol_map->map(symbol_map, param_info.function);"
+                )
+                print("symbol_entity_specs_add_%s(dest, param_info);" %
+                      (list_name))
             else:
-                sys.stderr.write("%s:%d: warning: not handling typeof '%s'\n" % (sys.argv[0], lineno(), type_name))
-      elif (_type.startswith("array")):
-          type_name = get_up_to_matching_paren(_type[len("array"):])
-          field_names = name.split(",")
-          if (len(field_names) == 1):
-             num_name = "num_" + name
-             list_name = name
-          elif (len(field_names) == 2):
-              num_name = field_names[0]
-              list_name = field_names[1]
-          else:
-              raise Exception("Invalid number of fields in array name. Only 1 or 2 comma-separated are allowed")
-          if type_name.startswith("typeof"):
-              type_name = get_up_to_matching_paren(type_name[len("typeof"):]).split(",")[0].strip()
-          print("{")
-          print("symbol_entity_specs_free_%s(dest);" % (list_name))
-          print("int i, N = symbol_entity_specs_get_%s(source);" % (num_name))
-          print("for (i = 0; i < N; i++)")
-          print("{")
-          if type_name == "symbol":
-              print("scope_entry_t* copied = symbol_map->map(symbol_map, symbol_entity_specs_get_%s_num(source, i));" % (list_name))
-              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name));
-          elif type_name == "type":
-              print("type_t* copied = type_deep_copy_compute_maps(symbol_entity_specs_get_%s_num(source, i), /* dest */ NULL, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (list_name))
-              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name));
-          elif type_name == "default_argument_info_t*":
-                  print("default_argument_info_t* source_default_arg = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
-                  print("default_argument_info_t* copied = NULL;")
-                  print("if (source_default_arg != NULL)")
-                  print("{")
-                  print("  copied = NEW0(default_argument_info_t);")
-                  print("  copied->argument = nodecl_deep_copy_compute_maps(source_default_arg->argument, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
-                  print("  copied->context = decl_context;")
-                  print("}")
-                  print("symbol_entity_specs_add_%s(dest, copied);" % (list_name))
-          elif type_name == "gcc_attribute_t":
-              print("gcc_attribute_t source_gcc_attr = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
-              print("gcc_attribute_t copied;")
-              print("copied.attribute_name = source_gcc_attr.attribute_name;")
-              print("copied.expression_list = nodecl_deep_copy_compute_maps(source_gcc_attr.expression_list, decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
-              print("symbol_entity_specs_add_%s(dest, copied);" % (list_name))
-          elif type_name == "function_parameter_info_t":
-              print("function_parameter_info_t param_info = symbol_entity_specs_get_%s_num(source, i);" % (list_name))
-              print("param_info.function = symbol_map->map(symbol_map, param_info.function);")
-              print("symbol_entity_specs_add_%s(dest, param_info);" % (list_name))
-          else:
-              sys.stderr.write("%s:%d: warning: not handling type array of type '%s'\n" % (sys.argv[0], lineno(), _type))
-          print("}")
-          print("}")
-      else:
-          sys.stderr.write("%s:%d: warning: not handling type '%s'\n" % (sys.argv[0], lineno(), _type))
+                sys.stderr.write(
+                    "%s:%d: warning: not handling type array of type '%s'\n" %
+                    (sys.argv[0], lineno(), _type))
+            print("}")
+            print("}")
+        else:
+            sys.stderr.write("%s:%d: warning: not handling type '%s'\n" %
+                             (sys.argv[0], lineno(), _type))
     print("""
     }
     """)
 
+
 lines = loadlines(f)
 check_file(lines)
 
diff --git a/src/frontend/nodecl-generator.py b/src/frontend/nodecl-generator.py
index 2a4ed9a9f..d7b69aa26 100755
--- a/src/frontend/nodecl-generator.py
+++ b/src/frontend/nodecl-generator.py
@@ -28,7 +28,8 @@ import sys
 import string
 import re
 
-NODECL_PREFIX="NODECL_"
+NODECL_PREFIX = "NODECL_"
+
 
 def loadlines(f):
     lines = f.readlines()
@@ -40,17 +41,19 @@ def loadlines(f):
         result.append(l)
     return result
 
+
 def find_matching_parentheses(s):
-    level = 0;
+    level = 0
     for i in range(0, len(s)):
         if s[i] == '(':
-           level = level + 1
+            level = level + 1
         elif s[i] == ')':
-           level = level - 1
-           if level == 0:
-              return i;
+            level = level - 1
+            if level == 0:
+                return i
     return -1
 
+
 def parse_rules(f):
     lines = loadlines(f)
 
@@ -59,20 +62,20 @@ def parse_rules(f):
     rule_name = ""
     rule_rhs = []
     for l in lines:
-       colon = l.find(":")
-       if (colon >= 0):
-           if (rule_name != "") :
-               rule_set.append( (rule_name, rule_rhs) )
-           rule_name = l[:colon].strip()
-           rule_rhs = [ l[colon + 1 :].strip() ]
-       elif l[0] == '|':
-           rule_rhs.append(l[1:].strip())
+        colon = l.find(":")
+        if (colon >= 0):
+            if (rule_name != ""):
+                rule_set.append((rule_name, rule_rhs))
+            rule_name = l[:colon].strip()
+            rule_rhs = [l[colon + 1:].strip()]
+        elif l[0] == '|':
+            rule_rhs.append(l[1:].strip())
     # Last rule
-    if (rule_name != "") :
-       rule_set.append( (rule_name, rule_rhs) )
+    if (rule_name != ""):
+        rule_set.append((rule_name, rule_rhs))
 
     regex_name = re.compile("\[([_A-Za-z][_*A-Za-z0-9]*)\]\s*([-_A-Za-z0-9]+)")
-    rule_map = { }
+    rule_map = {}
     rule_map["any"] = []
     for r in rule_set:
         (rule_name, rule_rhs) = r
@@ -86,16 +89,13 @@ def parse_rules(f):
                     raise Exception("invalid syntax, expecting (")
                 tree_ast = rhs[0:i].strip()
                 j = find_matching_parentheses(rhs[i:])
-                ast_args = rhs[i + 1 : i + j]
+                ast_args = rhs[i + 1:i + j]
                 ast_args = ast_args.strip()
-                remaining_flags = rhs[i+j+1:].split();
-                attributes = [
-                        ("symbol", "symbol"),
-                        ("type", "type"),
-                        ("text", "text"),
-                        ("cval", "const-value"),
-                        ("template_parameters", "template-parameters"),
-                        ("decl_context", "context")]
+                remaining_flags = rhs[i + j + 1:].split()
+                attributes = [("symbol", "symbol"), ("type", "type"),
+                              ("text", "text"), ("cval", "const-value"),
+                              ("template_parameters", "template-parameters"),
+                              ("decl_context", "context")]
 
                 # Mandatory values
                 # This exec below performs the following statements
@@ -103,7 +103,8 @@ def parse_rules(f):
                 #      needs_type = "type" in remaining_flags
                 #      ...
                 for (base_var_name, attr) in attributes:
-                    statement = "needs_%s = \"%s\" in remaining_flags" % (base_var_name, attr)
+                    statement = "needs_%s = \"%s\" in remaining_flags" % (
+                        base_var_name, attr)
                     exec(statement)
 
                 # Optional values
@@ -112,7 +113,8 @@ def parse_rules(f):
                 #      may_have_type = "type-opt" in remaining_flags
                 #      ...
                 for (base_var_name, attr) in attributes:
-                    statement = "may_have_%s = \"%s-opt\" in remaining_flags" % (base_var_name, attr)
+                    statement = "may_have_%s = \"%s-opt\" in remaining_flags" % (
+                        base_var_name, attr)
                     exec(statement)
 
                 # Module
@@ -123,9 +125,9 @@ def parse_rules(f):
                         if i < 0:
                             raise Exception("invalid syntax, expecting (")
                         j = find_matching_parentheses(flag[i:])
-                        module_name = flag[i+1: i + j].strip()
+                        module_name = flag[i + 1:i + j].strip()
 
-                if ast_args :
+                if ast_args:
                     ast_args_2 = [x.strip() for x in ast_args.split(",")]
                     ast_args_3 = []
                     i = 0
@@ -135,7 +137,9 @@ def parse_rules(f):
                             (r_label, r_ref) = m.groups()
                         else:
                             (r_label, r_ref) = (x, x)
-                            sys.stderr.write("Missing label for component %d in %s\n" % (i, rhs))
+                            sys.stderr.write(
+                                "Missing label for component %d in %s\n" %
+                                (i, rhs))
                         ast_args_3.append((r_label, r_ref))
                         i = i + 1
                     nodecl_structure = NodeclStructure(tree_ast, ast_args_3)
@@ -147,13 +151,16 @@ def parse_rules(f):
                     #needs_text, needs_cval, needs_template_parameters, needs_decl_context) )
 
                 for (base_var_name, attr) in attributes:
-                    setattr(nodecl_structure, "needs_%s" % (base_var_name), eval("needs_%s" % (base_var_name)))
-                    setattr(nodecl_structure, "may_have_%s" % (base_var_name), eval("may_have_%s" % (base_var_name)))
+                    setattr(nodecl_structure, "needs_%s" %
+                            (base_var_name), eval("needs_%s" %
+                                                  (base_var_name)))
+                    setattr(nodecl_structure, "may_have_%s" % (base_var_name),
+                            eval("may_have_%s" % (base_var_name)))
 
                 nodecl_structure.module_name = module_name
-                rule_map[rule_name].append( nodecl_structure )
+                rule_map[rule_name].append(nodecl_structure)
             else:
-                rule_map[rule_name].append( RuleRef(rhs) )
+                rule_map[rule_name].append(RuleRef(rhs))
 
     for current_rule_name in rule_map:
         can_be_seq = 1
@@ -163,9 +170,13 @@ def parse_rules(f):
         for rhs in rule_map[current_rule_name]:
             if rhs.__class__ == NodeclStructure:
                 if has_to_be_seq:
-                    raise Exception("inconsistent RHS: should generate a list, not a single node")
+                    raise Exception(
+                        "inconsistent RHS: should generate a list, not a single node"
+                    )
                 if has_to_be_opt:
-                    raise Exception("inconsistent RHS: should generate an optional node, not a single node")
+                    raise Exception(
+                        "inconsistent RHS: should generate an optional node, not a single node"
+                    )
                 can_be_seq = 0
                 can_be_opt = 0
             elif rhs.__class__ == RuleRef:
@@ -174,11 +185,13 @@ def parse_rules(f):
                 if not can_be_seq and current_is_seq:
                     raise Exception("inconsistent RHS: cannot generate a list")
                 if not can_be_opt and current_is_opt:
-                    raise Exception("inconsistent RHS: cannot generate an optional node")
+                    raise Exception(
+                        "inconsistent RHS: cannot generate an optional node")
                 if not current_is_seq and has_to_be_seq:
                     raise Exception("inconsistent RHS: must generate a list")
                 if not current_is_opt and has_to_be_opt:
-                    raise Exception("inconsistent RHS: must generate an optional node")
+                    raise Exception(
+                        "inconsistent RHS: must generate an optional node")
                 if current_is_seq:
                     has_to_be_seq = 1
                 if current_is_opt:
@@ -191,6 +204,7 @@ def parse_rules(f):
 class Variable:
     pass
 
+
 class NodeclStructure(Variable):
     def __init__(self, tree_kind, subtrees):
         self.tree_kind = tree_kind
@@ -199,94 +213,125 @@ class NodeclStructure(Variable):
 
     def name_to_underscore(self):
         return self.tree_kind.replace("-", "_").replace("*", "_")
+
     def name_to_underscore_lowercase(self):
         return self.name_to_underscore().lower()
 
-    def is_nullable(self, already_seen = []):
+    def is_nullable(self, already_seen=[]):
         return False
-    def first(self, already_seen = []) :
+
+    def first(self, already_seen=[]):
         return set([self.name_to_underscore()])
 
     def base_name(self):
         return self.tree_kind[len(NODECL_PREFIX):]
+
     def base_name_to_underscore(self):
         return self.base_name().replace("-", "_").replace("*", "_")
+
     def base_name_to_underscore_lowercase(self):
         return self.base_name_to_underscore().lower()
 
     def check_function_name(self):
         return "nodecl_check_%s" % (self.base_name_to_underscore())
+
     def c_name(self):
         return "nodecl_" + self.base_name_to_underscore_lowercase()
 
     def call_to_check(self, tree_name):
-        return "%s(%s);" % (self.check_function_name(), tree_name);
+        return "%s(%s);" % (self.check_function_name(), tree_name)
+
     def function_check_code(self):
         print("static void %s(nodecl_t n)" % (self.check_function_name()))
         print("{")
         print("ERROR_CONDITION(nodecl_is_null(n), \"Node is null\", 0);")
-        print("ERROR_CONDITION(nodecl_get_kind(n) != %s, \"Invalid node\", 0);" % self.name_to_underscore())
+        print("ERROR_CONDITION(nodecl_get_kind(n) != %s, \"Invalid node\", 0);"
+              % self.name_to_underscore())
         if (self.needs_symbol):
-           print("   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, \"Tree lacks a symbol\", 0);")
+            print(
+                "   ERROR_CONDITION(nodecl_get_symbol(n) == NULL, \"Tree lacks a symbol\", 0);"
+            )
         if (self.needs_type):
-           print("   ERROR_CONDITION(nodecl_get_type(n) == NULL, \"Tree lacks a type\", 0);")
+            print(
+                "   ERROR_CONDITION(nodecl_get_type(n) == NULL, \"Tree lacks a type\", 0);"
+            )
         if (self.needs_text):
-           print("   ERROR_CONDITION(nodecl_get_text(n) == NULL, \"Tree lacks an associated text\", 0);")
+            print(
+                "   ERROR_CONDITION(nodecl_get_text(n) == NULL, \"Tree lacks an associated text\", 0);"
+            )
         if (self.needs_cval):
-           print("   ERROR_CONDITION(nodecl_get_constant(n) == NULL, \"Tree lacks a constant value\", 0);")
+            print(
+                "   ERROR_CONDITION(nodecl_get_constant(n) == NULL, \"Tree lacks a constant value\", 0);"
+            )
         i = 0
         for subtree in self.subtrees:
-           (rule_label, rule_ref) = subtree
+            (rule_label, rule_ref) = subtree
 
-           current_rule = RuleRef(rule_ref)
+            current_rule = RuleRef(rule_ref)
 
-           print(current_rule.call_to_check("nodecl_get_child(n, %d)" % (i)));
+            print(current_rule.call_to_check("nodecl_get_child(n, %d)" % (i)))
 
-           i = i + 1
+            i = i + 1
         print("}")
 
+
 class RuleRef(Variable):
     def __init__(self, rule_ref):
         self.rule_ref = rule_ref
+
     def normalize_rule_name(self, rule_ref):
         is_seq = rule_ref.find("-seq") > 0
         is_opt = rule_ref.find("-opt") > 0
         rule_ref = rule_ref.replace("-seq", "").replace("-opt", "")
         rule_ref_c = rule_ref.replace("-", "_").replace("*", "_")
         return (rule_ref, rule_ref_c, is_seq, is_opt)
+
     def canonical_rule(self):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         return rule_ref
+
     def rule_c_name(self):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         return rule_ref_c
+
     def is_canonical_rule(self):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         return rule_ref == self.rule_ref
+
     def is_opt(self):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         return is_opt
+
     def is_seq(self):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         return is_seq
-    def is_nullable(self, _already_seen = []):
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+
+    def is_nullable(self, _already_seen=[]):
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         already_seen = _already_seen[:]
         if is_opt:
             return True
         if rule_ref in already_seen:
-           return False
+            return False
         already_seen.append(rule_ref)
         rule_set = rule_map[rule_ref]
         for rhs in rule_set:
-          if rhs.is_nullable(already_seen):
-            return True
+            if rhs.is_nullable(already_seen):
+                return True
         return False
-    def first(self, _already_seen = []) :
+
+    def first(self, _already_seen=[]):
         already_seen = _already_seen[:]
-        (rule_ref, rule_ref_c, is_seq, is_opt) = self.normalize_rule_name(self.rule_ref)
+        (rule_ref, rule_ref_c, is_seq,
+         is_opt) = self.normalize_rule_name(self.rule_ref)
         if rule_ref in already_seen:
-           return set([])
+            return set([])
         if is_seq:
             return set(["AST_NODE_LIST"])
         already_seen.append(rule_ref)
@@ -295,19 +340,25 @@ class RuleRef(Variable):
         for rhs in rule_set:
             s = s.union(rhs.first(already_seen))
         return s
+
     def check_function_name(self):
         return "nodecl_check_%s" % (self.rule_c_name())
+
     def call_to_check(self, tree_name):
         if self.is_nullable():
             if self.is_seq():
-               return "nodecl_check_nullable_list_rule(%s, %s);" % (tree_name, self.check_function_name())
+                return "nodecl_check_nullable_list_rule(%s, %s);" % (
+                    tree_name, self.check_function_name())
             else:
-               return "nodecl_check_nullable_rule(%s, %s);" % (tree_name, self.check_function_name())
+                return "nodecl_check_nullable_rule(%s, %s);" % (
+                    tree_name, self.check_function_name())
         else:
             if self.is_seq():
-               return "nodecl_check_list_rule(%s, %s);" % (tree_name, self.check_function_name())
+                return "nodecl_check_list_rule(%s, %s);" % (
+                    tree_name, self.check_function_name())
             else:
-               return "%s(%s);" % (self.check_function_name(), tree_name)
+                return "%s(%s);" % (self.check_function_name(), tree_name)
+
     def function_check_code(self):
         if not self.is_canonical_rule():
             raise Exception("Do not call this on non canonical rules")
@@ -321,23 +372,26 @@ class RuleRef(Variable):
         for rhs in rule_set:
             first_set = rhs.first()
             if not first_set:
-               raise Exception("First is empty!")
+                raise Exception("First is empty!")
             for first in first_set:
                 print("case %s:" % (first))
             print("{")
-            print(rhs.call_to_check("n"));
+            print(rhs.call_to_check("n"))
             print("break;")
             print("}")
 
         print("default:")
         print("{")
-        print("internal_error(\"Node of kind %s not valid\", ast_print_node_type(nodecl_get_kind(n)));")
+        print(
+            "internal_error(\"Node of kind %s not valid\", ast_print_node_type(nodecl_get_kind(n)));"
+        )
         print("break;")
         print("}")
         print("}")
 
         print("}")
 
+
 def get_all_nodecl_structs():
     node_kind_set = set([])
     nodes = []
@@ -350,23 +404,31 @@ def get_all_nodecl_structs():
                     nodes.append(rhs)
     return nodes
 
+
 def generate_check_routines(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("")
     print("#include \"cxx-nodecl.h\"")
     print("#include \"cxx-utils.h\"")
     print("#include \"cxx-exprtype.h\"")
     print("#include \"mem.h\"")
     print("")
-    print("static inline void nodecl_check_nullable_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print(
+        "static inline void nodecl_check_nullable_rule(nodecl_t n, void (*fun)(nodecl_t))"
+    )
     print("{")
     print("   if (nodecl_is_null(n)) return;")
     print("   fun(n);")
     print("}")
-    print("static inline void nodecl_check_list_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print(
+        "static inline void nodecl_check_list_rule(nodecl_t n, void (*fun)(nodecl_t))"
+    )
     print("{")
-    print("   ERROR_CONDITION(!nodecl_is_list(n), \"Node must be a list\", 0);")
+    print(
+        "   ERROR_CONDITION(!nodecl_is_list(n), \"Node must be a list\", 0);")
     print("   int num_items = 0;")
     print("   nodecl_t* list = nodecl_unpack_list(n, &num_items);")
     print("   int i;")
@@ -376,7 +438,9 @@ def generate_check_routines(rule_map):
     print("   }")
     print("   DELETE(list);")
     print("}")
-    print("static inline void nodecl_check_nullable_list_rule(nodecl_t n, void (*fun)(nodecl_t))")
+    print(
+        "static inline void nodecl_check_nullable_list_rule(nodecl_t n, void (*fun)(nodecl_t))"
+    )
     print("{")
     print("   if (nodecl_is_null(n)) return;")
     print("   nodecl_check_list_rule(n, fun);")
@@ -387,7 +451,8 @@ def generate_check_routines(rule_map):
         print("static void %s(nodecl_t);" % (node.check_function_name()))
 
     for rule_name in rule_map:
-        print("static void %s(nodecl_t);" % ( RuleRef(rule_name).check_function_name() ))
+        print("static void %s(nodecl_t);" %
+              (RuleRef(rule_name).check_function_name()))
     print("")
     for node in nodes:
         node.function_check_code()
@@ -413,6 +478,7 @@ def from_underscore_to_camel_case(x):
             result += c.lower()
     return result
 
+
 def from_underscore_to_camel_case_namespaces(x):
     result = ''
     namespaces = []
@@ -431,6 +497,7 @@ def from_underscore_to_camel_case_namespaces(x):
             result += c.lower()
     return (tuple(namespaces), result)
 
+
 def get_all_class_names(rule_map):
     classes = set([])
     for rule_name in rule_map:
@@ -440,15 +507,18 @@ def get_all_class_names(rule_map):
                 classes.add(from_underscore_to_camel_case(rhs.base_name()))
     return classes
 
+
 def get_all_class_names_and_namespaces(rule_map):
     classes = set([])
     for rule_name in rule_map:
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                classes.add(from_underscore_to_camel_case_namespaces(rhs.base_name()))
+                classes.add(
+                    from_underscore_to_camel_case_namespaces(rhs.base_name()))
     return classes
 
+
 def get_all_class_names_and_children_names(rule_map):
     result = []
     classes_set = set([])
@@ -460,9 +530,11 @@ def get_all_class_names_and_children_names(rule_map):
                 if class_name not in classes_set:
                     classes_set.add(class_name)
                     subtrees = [x[0] for x in rhs.subtrees]
-                    result.append((class_name, subtrees, rhs.name_to_underscore(), rhs))
+                    result.append(
+                        (class_name, subtrees, rhs.name_to_underscore(), rhs))
     return result
 
+
 def get_all_class_names_and_children_names_namespaces(rule_map):
     result = []
     classes_set = set([])
@@ -470,13 +542,16 @@ def get_all_class_names_and_children_names_namespaces(rule_map):
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                class_name = from_underscore_to_camel_case_namespaces(rhs.base_name())
+                class_name = from_underscore_to_camel_case_namespaces(
+                    rhs.base_name())
                 if class_name not in classes_set:
                     classes_set.add(class_name)
                     subtrees = [x[0] for x in rhs.subtrees]
-                    result.append((class_name, subtrees, rhs.name_to_underscore(), rhs))
+                    result.append(
+                        (class_name, subtrees, rhs.name_to_underscore(), rhs))
     return result
 
+
 def get_all_class_names_and_children_names_namespaces_and_modules(rule_map):
     result = []
     classes_set = set([])
@@ -484,17 +559,22 @@ def get_all_class_names_and_children_names_namespaces_and_modules(rule_map):
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                class_name = from_underscore_to_camel_case_namespaces(rhs.base_name())
+                class_name = from_underscore_to_camel_case_namespaces(
+                    rhs.base_name())
                 module_name = rhs.module_name
                 if class_name not in classes_set:
                     classes_set.add(class_name)
                     subtrees = [x[0] for x in rhs.subtrees]
-                    result.append((class_name, subtrees, rhs.name_to_underscore(), rhs, module_name))
+                    result.append((class_name, subtrees,
+                                   rhs.name_to_underscore(), rhs, module_name))
     return result
 
+
 def generate_nodecl_classes_fwd_decls(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("#ifndef TL_NODECL_FWD_HPP")
     print("#define TL_NODECL_FWD_HPP")
     print("")
@@ -513,12 +593,16 @@ def generate_nodecl_classes_fwd_decls(rule_map):
     print("} // Nodecl")
     print("#endif // TL_NODECL_FWD_HPP")
 
+
 def get_qualified_name(namespaces, name):
     return "::".join(list(namespaces) + [name])
 
+
 def generate_visitor_class_header(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("#ifndef TL_NODECL_VISITOR_HPP")
     print("#define TL_NODECL_VISITOR_HPP")
     print("")
@@ -540,10 +624,13 @@ def generate_visitor_class_header(rule_map):
     print("{")
     print("   public:")
     print("     typedef _Ret Ret;")
-    print("     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */")
+    print(
+        "     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */"
+    )
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print("     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name))
+        print("     virtual Ret visit(const Nodecl::%s &) = 0;" %
+              (qualified_name))
     print("   virtual _Ret join_list(TL::ObjectList<_Ret> &) = 0;")
     print("   virtual ~BaseNodeclVisitor() { }")
     print("};")
@@ -552,10 +639,13 @@ def generate_visitor_class_header(rule_map):
     print("{")
     print("   public:")
     print("     typedef void Ret;")
-    print("     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */")
+    print(
+        "     Ret walk(const NodeclBase&); /* If you override this member function you will be fired */"
+    )
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print("     virtual Ret visit(const Nodecl::%s &) = 0;" % (qualified_name))
+        print("     virtual Ret visit(const Nodecl::%s &) = 0;" %
+              (qualified_name))
     print("   virtual ~BaseNodeclVisitor() { }")
     print("};")
     print("template <typename _Ret>")
@@ -563,10 +653,14 @@ def generate_visitor_class_header(rule_map):
     print("{")
     print("   public:")
     print("     typedef typename BaseNodeclVisitor<_Ret>::Ret Ret;")
-    print("   virtual Ret unhandled_node(const Nodecl::NodeclBase &) { return Ret(); }")
+    print(
+        "   virtual Ret unhandled_node(const Nodecl::NodeclBase &) { return Ret(); }"
+    )
     for (namespaces, class_name) in classes:
         qualified_name = get_qualified_name(namespaces, class_name)
-        print("     virtual Ret visit(const Nodecl::%s & n) { return this->unhandled_node(n); }" % (qualified_name))
+        print(
+            "     virtual Ret visit(const Nodecl::%s & n) { return this->unhandled_node(n); }"
+            % (qualified_name))
     print("   virtual ~UnhandledNodeclVisitor() { }")
     print("};")
     print("template <typename _Ret>")
@@ -576,14 +670,22 @@ def generate_visitor_class_header(rule_map):
     print("     typedef typename UnhandledNodeclVisitor<_Ret>::Ret Ret;")
     print("};")
     print("template <typename _Ret>")
-    print("class NodeclVisitor<TL::ObjectList<_Ret> > : public UnhandledNodeclVisitor<TL::ObjectList<_Ret> >")
+    print(
+        "class NodeclVisitor<TL::ObjectList<_Ret> > : public UnhandledNodeclVisitor<TL::ObjectList<_Ret> >"
+    )
     print("{")
     print("   public:")
-    print("     typedef typename UnhandledNodeclVisitor<TL::ObjectList<_Ret> >::Ret Ret;")
-    print("     TL::ObjectList<_Ret> join_list(TL::ObjectList<TL::ObjectList<_Ret> > &list)")
+    print(
+        "     typedef typename UnhandledNodeclVisitor<TL::ObjectList<_Ret> >::Ret Ret;"
+    )
+    print(
+        "     TL::ObjectList<_Ret> join_list(TL::ObjectList<TL::ObjectList<_Ret> > &list)"
+    )
     print("     {")
     print("TL::ObjectList<_Ret> result;")
-    print("for (typename TL::ObjectList<TL::ObjectList<_Ret> >::iterator it = list.begin(); it != list.end(); it++)")
+    print(
+        "for (typename TL::ObjectList<TL::ObjectList<_Ret> >::iterator it = list.begin(); it != list.end(); it++)"
+    )
     print("{")
     print("TL::ObjectList<_Ret> &o_list(*it);")
     print("result.append(o_list);")
@@ -592,12 +694,18 @@ def generate_visitor_class_header(rule_map):
     print("     }")
     print("};")
     print("template <>")
-    print("class NodeclVisitor<Nodecl::NodeclBase> : public UnhandledNodeclVisitor<Nodecl::NodeclBase>")
+    print(
+        "class NodeclVisitor<Nodecl::NodeclBase> : public UnhandledNodeclVisitor<Nodecl::NodeclBase>"
+    )
     print("{")
     print("   public:")
     print("     // Only GCC 4.6 can compile this typedef")
-    print("     // typedef typename UnhandledNodeclVisitor<Nodecl::NodeclBase>::Ret Ret;")
-    print("     virtual Nodecl::NodeclBase join_list(TL::ObjectList<Nodecl::NodeclBase> &list)")
+    print(
+        "     // typedef typename UnhandledNodeclVisitor<Nodecl::NodeclBase>::Ret Ret;"
+    )
+    print(
+        "     virtual Nodecl::NodeclBase join_list(TL::ObjectList<Nodecl::NodeclBase> &list)"
+    )
     print("     {")
     print("         return Nodecl::List::make(list);")
     print("     }")
@@ -608,22 +716,30 @@ def generate_visitor_class_header(rule_map):
     print("{")
     print("public:")
     print("     typedef typename NodeclVisitor<_Ret>::Ret Ret;")
-    classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(rule_map)
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class, module_name) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("     virtual Ret visit_pre(const Nodecl::%s & n) { return Ret(); }" % (qualified_name))
-         print("     virtual Ret visit_post(const Nodecl::%s & n) { return Ret(); }" % (qualified_name))
-         print("     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name))
-         print("     {")
-         print("        TL::ObjectList<Ret> values;")
-         print("        values.append(this->visit_pre(n));")
-         child_num = 0
-         for child_name in children_name:
-              print("        values.append(this->walk(n.get_%s()));" % (child_name))
-              child_num = child_num + 1
-         print("        values.append(this->visit_post(n));")
-         print("        return this->join_list(values);")
-         print("     }")
+    classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind, nodecl_class,
+         module_name) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print(
+            "     virtual Ret visit_pre(const Nodecl::%s & n) { return Ret(); }"
+            % (qualified_name))
+        print(
+            "     virtual Ret visit_post(const Nodecl::%s & n) { return Ret(); }"
+            % (qualified_name))
+        print("     virtual Ret visit(const Nodecl::%s & n)" %
+              (qualified_name))
+        print("     {")
+        print("        TL::ObjectList<Ret> values;")
+        print("        values.append(this->visit_pre(n));")
+        child_num = 0
+        for child_name in children_name:
+            print("        values.append(this->walk(n.get_%s()));" %
+                  (child_name))
+            child_num = child_num + 1
+        print("        values.append(this->visit_post(n));")
+        print("        return this->join_list(values);")
+        print("     }")
     print("};")
     # ExhaustiveVisitor<void>
     print("template <>")
@@ -631,24 +747,31 @@ def generate_visitor_class_header(rule_map):
     print("{")
     print("public:")
     print("     typedef NodeclVisitor<void>::Ret Ret;")
-    classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(rule_map)
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class, module_name) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("     virtual Ret visit_pre(const Nodecl::%s & n) { }" % (qualified_name))
-         print("     virtual Ret visit_post(const Nodecl::%s & n) { }" % (qualified_name))
-         print("     virtual Ret visit(const Nodecl::%s & n)" % (qualified_name))
-         print("     {")
-         print("        this->visit_pre(n);")
-         child_num = 0
-         for child_name in children_name:
-              print("        this->walk(n.get_%s());" % (child_name))
-              child_num = child_num + 1
-         print("        this->visit_post(n);")
-         print("     }")
+    classes_and_children = get_all_class_names_and_children_names_namespaces_and_modules(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind, nodecl_class,
+         module_name) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print("     virtual Ret visit_pre(const Nodecl::%s & n) { }" %
+              (qualified_name))
+        print("     virtual Ret visit_post(const Nodecl::%s & n) { }" %
+              (qualified_name))
+        print("     virtual Ret visit(const Nodecl::%s & n)" %
+              (qualified_name))
+        print("     {")
+        print("        this->visit_pre(n);")
+        child_num = 0
+        for child_name in children_name:
+            print("        this->walk(n.get_%s());" % (child_name))
+            child_num = child_num + 1
+        print("        this->visit_post(n);")
+        print("     }")
     print("};")
     print("")
     print("template <typename _Ret>")
-    print("typename BaseNodeclVisitor<_Ret>::Ret BaseNodeclVisitor<_Ret>::walk(const NodeclBase& n)")
+    print(
+        "typename BaseNodeclVisitor<_Ret>::Ret BaseNodeclVisitor<_Ret>::walk(const NodeclBase& n)"
+    )
     print("{")
     print("""
     if (n.is_null())
@@ -663,9 +786,13 @@ NodeclBase nb(::_nodecl_wrap(elem)); result.append(this->walk(nb)); } return thi
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                node_kind.add((rhs.name_to_underscore(), from_underscore_to_camel_case_namespaces(rhs.base_name().lower())))
+                node_kind.add((rhs.name_to_underscore(),
+                               from_underscore_to_camel_case_namespaces(
+                                   rhs.base_name().lower())))
     for (kind_name, (namespaces, class_name)) in node_kind:
-        print("       case %s: { return this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name)))
+        print(
+            "       case %s: { return this->visit(static_cast<const Nodecl::%s &>(n)); break; }"
+            % (kind_name, get_qualified_name(namespaces, class_name)))
     print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(n.get_kind())); }
@@ -677,11 +804,14 @@ NodeclBase nb(::_nodecl_wrap(elem)); result.append(this->walk(nb)); } return thi
     print("} /* namespace Nodecl */")
     print("#endif")
 
+
 def generate_visitor_class_impl(rule_map):
     print("#ifndef TL_NODECL_VISITOR_CPP")
     print("#define TL_NODECL_VISITOR_CPP")
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("#include <tl-nodecl-visitor.hpp>")
     print("#include <tl-nodecl.hpp>")
     print("#include \"cxx-utils.h\"")
@@ -689,7 +819,9 @@ def generate_visitor_class_impl(rule_map):
     print("")
     print("namespace Nodecl {")
     print("")
-    print("BaseNodeclVisitor<void>::Ret BaseNodeclVisitor<void>::walk(const NodeclBase& n)")
+    print(
+        "BaseNodeclVisitor<void>::Ret BaseNodeclVisitor<void>::walk(const NodeclBase& n)"
+    )
     print("{")
     print("""
     if (n.is_null())
@@ -704,9 +836,13 @@ NodeclBase nb(::_nodecl_wrap(elem)); this->walk(nb); } break; }
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                node_kind.add((rhs.name_to_underscore(), from_underscore_to_camel_case_namespaces(rhs.base_name().lower())))
+                node_kind.add((rhs.name_to_underscore(),
+                               from_underscore_to_camel_case_namespaces(
+                                   rhs.base_name().lower())))
     for (kind_name, (namespaces, class_name)) in node_kind:
-        print("       case %s: { this->visit(static_cast<const Nodecl::%s &>(n)); break; }" % (kind_name, get_qualified_name(namespaces, class_name)))
+        print(
+            "       case %s: { this->visit(static_cast<const Nodecl::%s &>(n)); break; }"
+            % (kind_name, get_qualified_name(namespaces, class_name)))
     print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(n.get_kind())); }
@@ -716,9 +852,12 @@ NodeclBase nb(::_nodecl_wrap(elem)); this->walk(nb); } break; }
     print("} /* namespace Nodecl */")
     print("#endif // TL_NODECL_VISITOR_CPP")
 
+
 def generate_copy_visitor_class_header(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("#ifndef TL_NODECL_COPY_VISITOR_HPP")
     print("#define TL_NODECL_COPY_VISITOR_HPP")
     print("")
@@ -730,400 +869,496 @@ def generate_copy_visitor_class_header(rule_map):
     print("   class ShallowCopyVisitor : public CopyVisitorBase")
     print("   {")
     print("      public:")
-    classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name))
+    classes_and_children = get_all_class_names_and_children_names_namespaces(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print("        virtual Ret visit(const Nodecl::%s & n);" %
+              (qualified_name))
     print("   };")
     print("   struct SymbolMap")
     print("   {")
     print("       virtual TL::Symbol map(TL::Symbol sym) = 0;")
-    print("       virtual void add_map(TL::Symbol source, TL::Symbol target) = 0;")
+    print(
+        "       virtual void add_map(TL::Symbol source, TL::Symbol target) = 0;"
+    )
     print("   };")
     print("   class DeepCopyVisitorBase : public CopyVisitorBase")
     print("   {")
     print("      protected:")
     print("         SymbolMap &_map_symbol;")
     print("      public:")
-    print("          DeepCopyVisitorBase(SymbolMap &map_symbol) : _map_symbol(map_symbol) { }")
-    classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("        virtual Ret visit(const Nodecl::%s & n);" % (qualified_name))
+    print(
+        "          DeepCopyVisitorBase(SymbolMap &map_symbol) : _map_symbol(map_symbol) { }"
+    )
+    classes_and_children = get_all_class_names_and_children_names_namespaces(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print("        virtual Ret visit(const Nodecl::%s & n);" %
+              (qualified_name))
     print("   };")
     print("}")
     print("#endif // TL_NODECL_COPY_VISITOR_HPP")
 
+
 def generate_copy_visitor_class_impl(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("#include \"tl-nodecl-copy-visitor.hpp\"")
     print("")
     print("namespace Nodecl {")
-    classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("  ShallowCopyVisitor::Ret ShallowCopyVisitor::visit(const Nodecl::%s & n)" % (qualified_name))
-         print("  {")
-
-         factory_arguments = []
-         for child_name in children_name:
-             print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name))
-             factory_arguments.append("child_%s" % (child_name))
-
-         if nodecl_class.needs_symbol:
-             print("TL::Symbol symbol = n.get_symbol();")
-             factory_arguments.append("symbol")
-         if nodecl_class.needs_type:
-             print("TL::Type type = n.get_type();");
-             factory_arguments.append("type")
-         if nodecl_class.needs_text:
-             print("const std::string& text = n.get_text();")
-             factory_arguments.append("text")
-         if nodecl_class.needs_cval:
-             print("const_value_t* cval = n.get_constant();")
-             factory_arguments.append("cval")
-         if nodecl_class.needs_template_parameters:
-             print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());")
-             factory_arguments.append("template_parameters")
-         if nodecl_class.needs_decl_context:
-             print("TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());")
-             factory_arguments.append("sc")
-
-         print("const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());")
-         factory_arguments.append("location")
-
-         print("return %s::make(%s);" % (qualified_name, ", ".join(factory_arguments)))
-
-         print("  }")
-    for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-         qualified_name = get_qualified_name(namespaces, class_name)
-         print("  DeepCopyVisitorBase::Ret DeepCopyVisitorBase::visit(const Nodecl::%s & n)" % (qualified_name))
-         print("  {")
-
-         factory_arguments = []
-         for child_name in children_name:
-             print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" % (child_name, child_name))
-             factory_arguments.append("child_%s" % (child_name))
-
-         if nodecl_class.needs_symbol:
-             print("TL::Symbol symbol = _map_symbol.map( n.get_symbol() );")
-             factory_arguments.append("symbol")
-         if nodecl_class.needs_type:
-             print("TL::Type type = n.get_type();");
-             factory_arguments.append("type")
-         if nodecl_class.needs_text:
-             print("const std::string& text = n.get_text();")
-             factory_arguments.append("text")
-         if nodecl_class.needs_cval:
-             print("const_value_t* cval = n.get_constant();")
-             factory_arguments.append("cval")
-         if nodecl_class.needs_template_parameters:
-             print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());")
-             factory_arguments.append("template_parameters")
-         if nodecl_class.needs_decl_context:
-             print("TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());");
-             factory_arguments.append("sc")
-
-         print("const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());")
-         factory_arguments.append("location")
-
-         print("return %s::make(%s);" % (qualified_name, ", ".join(factory_arguments)))
-
-         print("  }")
+    classes_and_children = get_all_class_names_and_children_names_namespaces(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print(
+            "  ShallowCopyVisitor::Ret ShallowCopyVisitor::visit(const Nodecl::%s & n)"
+            % (qualified_name))
+        print("  {")
+
+        factory_arguments = []
+        for child_name in children_name:
+            print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" %
+                  (child_name, child_name))
+            factory_arguments.append("child_%s" % (child_name))
+
+        if nodecl_class.needs_symbol:
+            print("TL::Symbol symbol = n.get_symbol();")
+            factory_arguments.append("symbol")
+        if nodecl_class.needs_type:
+            print("TL::Type type = n.get_type();")
+            factory_arguments.append("type")
+        if nodecl_class.needs_text:
+            print("const std::string& text = n.get_text();")
+            factory_arguments.append("text")
+        if nodecl_class.needs_cval:
+            print("const_value_t* cval = n.get_constant();")
+            factory_arguments.append("cval")
+        if nodecl_class.needs_template_parameters:
+            print(
+                "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());"
+            )
+            factory_arguments.append("template_parameters")
+        if nodecl_class.needs_decl_context:
+            print(
+                "TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());"
+            )
+            factory_arguments.append("sc")
+
+        print(
+            "const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());"
+        )
+        factory_arguments.append("location")
+
+        print("return %s::make(%s);" %
+              (qualified_name, ", ".join(factory_arguments)))
+
+        print("  }")
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print(
+            "  DeepCopyVisitorBase::Ret DeepCopyVisitorBase::visit(const Nodecl::%s & n)"
+            % (qualified_name))
+        print("  {")
+
+        factory_arguments = []
+        for child_name in children_name:
+            print("Nodecl::NodeclBase child_%s = walk(n.get_%s());" %
+                  (child_name, child_name))
+            factory_arguments.append("child_%s" % (child_name))
+
+        if nodecl_class.needs_symbol:
+            print("TL::Symbol symbol = _map_symbol.map( n.get_symbol() );")
+            factory_arguments.append("symbol")
+        if nodecl_class.needs_type:
+            print("TL::Type type = n.get_type();")
+            factory_arguments.append("type")
+        if nodecl_class.needs_text:
+            print("const std::string& text = n.get_text();")
+            factory_arguments.append("text")
+        if nodecl_class.needs_cval:
+            print("const_value_t* cval = n.get_constant();")
+            factory_arguments.append("cval")
+        if nodecl_class.needs_template_parameters:
+            print(
+                "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n.get_internal_nodecl());"
+            )
+            factory_arguments.append("template_parameters")
+        if nodecl_class.needs_decl_context:
+            print(
+                "TL::Scope sc = nodecl_get_decl_context(n.get_internal_nodecl());"
+            )
+            factory_arguments.append("sc")
+
+        print(
+            "const locust_t* &location = nodecl_get_locus(n.get_internal_nodecl());"
+        )
+        factory_arguments.append("location")
+
+        print("return %s::make(%s);" %
+              (qualified_name, ", ".join(factory_arguments)))
+
+        print("  }")
     print("}")
 
+
 def generate_nodecl_classes_base(rule_map):
-   print("/* Autogenerated file. DO NOT MODIFY. */")
-   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
-   print("#ifndef TL_NODECL_HPP")
-   print("#define TL_NODECL_HPP")
-   print("")
-   print("#include <string>")
-   print("#include \"tl-nodecl-base.hpp\"")
-   print("#include \"mem.h\"")
-
-   print("namespace Nodecl {")
-
-   classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
-   for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-       qualified_name = get_qualified_name(namespaces, class_name)
-       print("class %s : public NodeclBase" % (qualified_name))
-       print("{")
-       print("    private:")
-       print("       static const int _kind = ::%s;" % (tree_kind))
-       print("       friend class NodeclBase;")
-       print("    public:")
-       print("    %s() : NodeclBase() { }" %(class_name))
-       print("    %s(const nodecl_t& a) : NodeclBase(a) { }" %(class_name))
-       print("")
-
-       factory_parameters = []
-       for child_name in children_name:
-           factory_parameters.append("Nodecl::NodeclBase child_%s" % (child_name))
-       if nodecl_class.needs_symbol:
-           factory_parameters.append("TL::Symbol symbol");
-       if nodecl_class.needs_type:
-           factory_parameters.append("TL::Type type");
-       if nodecl_class.needs_text:
-           factory_parameters.append("const std::string& text");
-       if nodecl_class.needs_cval:
-           factory_parameters.append("const_value_t* cval");
-       if nodecl_class.needs_template_parameters:
-           factory_parameters.append("template_parameter_list_t* template_parameters");
-       if nodecl_class.needs_decl_context:
-           factory_parameters.append("TL::Scope scope");
-
-       factory_parameters.append("const locus_t *location = ::make_locus(\"\", 0, 0)");
-
-       print("    // Factory method")
-       print("    static %s make(%s);" % (class_name, ", ".join(factory_parameters)))
-       print("")
-
-       if children_name:
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
+    print("#ifndef TL_NODECL_HPP")
+    print("#define TL_NODECL_HPP")
+    print("")
+    print("#include <string>")
+    print("#include \"tl-nodecl-base.hpp\"")
+    print("#include \"mem.h\"")
+
+    print("namespace Nodecl {")
+
+    classes_and_children = get_all_class_names_and_children_names_namespaces(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print("class %s : public NodeclBase" % (qualified_name))
+        print("{")
+        print("    private:")
+        print("       static const int _kind = ::%s;" % (tree_kind))
+        print("       friend class NodeclBase;")
+        print("    public:")
+        print("    %s() : NodeclBase() { }" % (class_name))
+        print("    %s(const nodecl_t& a) : NodeclBase(a) { }" % (class_name))
+        print("")
+
+        factory_parameters = []
+        for child_name in children_name:
+            factory_parameters.append("Nodecl::NodeclBase child_%s" %
+                                      (child_name))
+        if nodecl_class.needs_symbol:
+            factory_parameters.append("TL::Symbol symbol")
+        if nodecl_class.needs_type:
+            factory_parameters.append("TL::Type type")
+        if nodecl_class.needs_text:
+            factory_parameters.append("const std::string& text")
+        if nodecl_class.needs_cval:
+            factory_parameters.append("const_value_t* cval")
+        if nodecl_class.needs_template_parameters:
+            factory_parameters.append(
+                "template_parameter_list_t* template_parameters")
+        if nodecl_class.needs_decl_context:
+            factory_parameters.append("TL::Scope scope")
+
+        factory_parameters.append(
+            "const locus_t *location = ::make_locus(\"\", 0, 0)")
+
+        print("    // Factory method")
+        print("    static %s make(%s);" %
+              (class_name, ", ".join(factory_parameters)))
+        print("")
+
+        if children_name:
             print("    // Children getters and setters ")
-       child_num = 0
-       for child_name in children_name:
-            print("    NodeclBase get_%s() const { return NodeclBase(nodecl_get_child(_n, %d)); } " % (child_name, child_num))
-            print("    void set_%s(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, %d, n.get_internal_nodecl()); } " % (child_name, child_num))
+        child_num = 0
+        for child_name in children_name:
+            print(
+                "    NodeclBase get_%s() const { return NodeclBase(nodecl_get_child(_n, %d)); } "
+                % (child_name, child_num))
+            print(
+                "    void set_%s(const Nodecl::NodeclBase &n) { nodecl_set_child(_n, %d, n.get_internal_nodecl()); } "
+                % (child_name, child_num))
             child_num = child_num + 1
-       print("};")
-   print("")
-   print("} /* namespace Nodecl */")
-   print("#endif")
+        print("};")
+    print("")
+    print("} /* namespace Nodecl */")
+    print("#endif")
+
 
 def generate_nodecl_classes_specs(rule_map):
-   print("/* Autogenerated file. DO NOT MODIFY. */")
-   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
-   print("#include \"cxx-utils.h\"")
-   print("#include \"tl-nodecl.hpp\"")
-   print("#include \"mem.h\"")
-   print("")
-   print("namespace Nodecl {")
-   classes_and_children = get_all_class_names_and_children_names_namespaces(rule_map)
-   for ((namespaces, class_name), children_name, tree_kind, nodecl_class) in classes_and_children:
-
-       factory_parameters = []
-       factory_arguments = []
-       for child_name in children_name:
-           factory_parameters.append("Nodecl::NodeclBase child_%s" % (child_name))
-           factory_arguments.append("child_%s.get_internal_nodecl()" % (child_name))
-       if nodecl_class.needs_symbol:
-           factory_parameters.append("TL::Symbol symbol");
-           factory_arguments.append("symbol.get_internal_symbol()");
-       if nodecl_class.needs_type:
-           factory_parameters.append("TL::Type type");
-           factory_arguments.append("type.get_internal_type()");
-       if nodecl_class.needs_text:
-           factory_parameters.append("const std::string& text");
-           factory_arguments.append("::uniquestr(text.c_str())");
-       if nodecl_class.needs_cval:
-           factory_parameters.append("const_value_t* cval");
-           factory_arguments.append("cval");
-       if nodecl_class.needs_template_parameters:
-           factory_parameters.append("template_parameter_list_t* template_parameters");
-           factory_arguments.append("template_parameters");
-       if nodecl_class.needs_decl_context:
-           factory_parameters.append("TL::Scope scope");
-           factory_arguments.append("scope.get_decl_context()");
-
-       factory_parameters.append("const locus_t* location")
-       factory_arguments.append("location");
-
-       nodecl_make_name = "nodecl_make_%s" % (nodecl_class.base_name_to_underscore_lowercase())
-
-       qualified_name = get_qualified_name(namespaces, class_name)
-       print("%s %s::make(%s)" % (qualified_name, qualified_name, ", ".join(factory_parameters)))
-       print("{")
-       print("    return ::%s(%s);" % (nodecl_make_name, ", ".join(factory_arguments)))
-       print("}")
-
-   print("} /* namespace Nodecl */")
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
+    print("#include \"cxx-utils.h\"")
+    print("#include \"tl-nodecl.hpp\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("namespace Nodecl {")
+    classes_and_children = get_all_class_names_and_children_names_namespaces(
+        rule_map)
+    for ((namespaces, class_name), children_name, tree_kind,
+         nodecl_class) in classes_and_children:
+
+        factory_parameters = []
+        factory_arguments = []
+        for child_name in children_name:
+            factory_parameters.append("Nodecl::NodeclBase child_%s" %
+                                      (child_name))
+            factory_arguments.append("child_%s.get_internal_nodecl()" %
+                                     (child_name))
+        if nodecl_class.needs_symbol:
+            factory_parameters.append("TL::Symbol symbol")
+            factory_arguments.append("symbol.get_internal_symbol()")
+        if nodecl_class.needs_type:
+            factory_parameters.append("TL::Type type")
+            factory_arguments.append("type.get_internal_type()")
+        if nodecl_class.needs_text:
+            factory_parameters.append("const std::string& text")
+            factory_arguments.append("::uniquestr(text.c_str())")
+        if nodecl_class.needs_cval:
+            factory_parameters.append("const_value_t* cval")
+            factory_arguments.append("cval")
+        if nodecl_class.needs_template_parameters:
+            factory_parameters.append(
+                "template_parameter_list_t* template_parameters")
+            factory_arguments.append("template_parameters")
+        if nodecl_class.needs_decl_context:
+            factory_parameters.append("TL::Scope scope")
+            factory_arguments.append("scope.get_decl_context()")
+
+        factory_parameters.append("const locus_t* location")
+        factory_arguments.append("location")
+
+        nodecl_make_name = "nodecl_make_%s" % (
+            nodecl_class.base_name_to_underscore_lowercase())
+
+        qualified_name = get_qualified_name(namespaces, class_name)
+        print("%s %s::make(%s)" %
+              (qualified_name, qualified_name, ", ".join(factory_parameters)))
+        print("{")
+        print("    return ::%s(%s);" %
+              (nodecl_make_name, ", ".join(factory_arguments)))
+        print("}")
+
+    print("} /* namespace Nodecl */")
+
 
 def generate_routines_header(rule_map):
-   print("/* Autogenerated file. DO NOT MODIFY. */")
-   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
-   print("#ifndef CXX_NODECL_OUTPUT_H")
-   print("#define CXX_NODECL_OUTPUT_H")
-   print("")
-   print("#include \"cxx-macros.h\"")
-   print("#include \"cxx-nodecl.h\"")
-   print("#include \"cxx-type-fwd.h\"")
-   print("#include \"cxx-cexpr-fwd.h\"")
-   print("#include \"cxx-scope-decls.h\"")
-   print("#include \"mem.h\"")
-   print("")
-   print("MCXX_BEGIN_DECLS")
-   print("")
-
-   for i in range(1, 7):
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
+    print("#ifndef CXX_NODECL_OUTPUT_H")
+    print("#define CXX_NODECL_OUTPUT_H")
+    print("")
+    print("#include \"cxx-macros.h\"")
+    print("#include \"cxx-nodecl.h\"")
+    print("#include \"cxx-type-fwd.h\"")
+    print("#include \"cxx-cexpr-fwd.h\"")
+    print("#include \"cxx-scope-decls.h\"")
+    print("#include \"mem.h\"")
+    print("")
+    print("MCXX_BEGIN_DECLS")
+    print("")
+
+    for i in range(1, 7):
         params = ["nodecl_t element%d" % (x) for x in range(0, i)]
         print("nodecl_t nodecl_make_list_%d(%s);" % (i, ", ".join(params)))
-   print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items);")
-   print("")
-   classes = {}
-   for rule_name in rule_map:
-       rule_rhs = rule_map[rule_name]
-       for rhs in rule_rhs:
-           if rhs.__class__ == NodeclStructure:
-               classes[rhs.base_name_to_underscore_lowercase()] = rhs
-   for (key, rhs_rule) in classes.items() :
-       param_list_nodecl = ["nodecl_t" for x in rhs_rule.subtrees]
-       if rhs_rule.needs_symbol:
-           param_list_nodecl.append("scope_entry_t*");
-       if rhs_rule.needs_type:
-           param_list_nodecl.append("type_t*");
-       if rhs_rule.needs_text:
-           param_list_nodecl.append("const char*");
-       if rhs_rule.needs_cval:
-           param_list_nodecl.append("const_value_t*");
-       if rhs_rule.needs_template_parameters:
-           param_list_nodecl.append("template_parameter_list_t*");
-       if rhs_rule.needs_decl_context:
-           param_list_nodecl.append("const decl_context_t*");
-       param_list_nodecl.append("const locus_t* location");
-
-       print("nodecl_t nodecl_make_%s(%s);" % (key, ", ".join(param_list_nodecl)))
-   print("")
-   print("MCXX_END_DECLS")
-   print("")
-   print("#endif // CXX_NODECL_OUTPUT_H")
+    print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items);")
+    print("")
+    classes = {}
+    for rule_name in rule_map:
+        rule_rhs = rule_map[rule_name]
+        for rhs in rule_rhs:
+            if rhs.__class__ == NodeclStructure:
+                classes[rhs.base_name_to_underscore_lowercase()] = rhs
+    for (key, rhs_rule) in classes.items():
+        param_list_nodecl = ["nodecl_t" for x in rhs_rule.subtrees]
+        if rhs_rule.needs_symbol:
+            param_list_nodecl.append("scope_entry_t*")
+        if rhs_rule.needs_type:
+            param_list_nodecl.append("type_t*")
+        if rhs_rule.needs_text:
+            param_list_nodecl.append("const char*")
+        if rhs_rule.needs_cval:
+            param_list_nodecl.append("const_value_t*")
+        if rhs_rule.needs_template_parameters:
+            param_list_nodecl.append("template_parameter_list_t*")
+        if rhs_rule.needs_decl_context:
+            param_list_nodecl.append("const decl_context_t*")
+        param_list_nodecl.append("const locus_t* location")
+
+        print("nodecl_t nodecl_make_%s(%s);" %
+              (key, ", ".join(param_list_nodecl)))
+    print("")
+    print("MCXX_END_DECLS")
+    print("")
+    print("#endif // CXX_NODECL_OUTPUT_H")
+
+
 # print "key %s -> value %s" % (repr(key), repr(value))
 
 
 def generate_routines_impl(rule_map):
-   print("/* Autogenerated file. DO NOT MODIFY. */")
-   print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
-   print("#include <stdlib.h>")
-   print("#include \"cxx-nodecl-output.h\"")
-   print("#include \"cxx-exprtype.h\"")
-   print("#include \"cxx-utils.h\"")
-   print("#include \"mem.h\"")
-   print("")
-   for i in range(2, 7):
+    print("/* Autogenerated file. DO NOT MODIFY. */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
+    print("#include <stdlib.h>")
+    print("#include \"cxx-nodecl-output.h\"")
+    print("#include \"cxx-exprtype.h\"")
+    print("#include \"cxx-utils.h\"")
+    print("#include \"mem.h\"")
+    print("")
+    for i in range(2, 7):
         params = ["nodecl_t element%d" % (x) for x in range(0, i)]
         args = ["element%d" % (x) for x in range(0, i)]
         print("nodecl_t nodecl_make_list_%d(%s)" % (i, ", ".join(params)))
         print("{")
-        print("  return nodecl_append_to_list(nodecl_make_list_%d(%s), %s);" % (i-1, ", ".join(args[:-1]), args[-1]))
+        print("  return nodecl_append_to_list(nodecl_make_list_%d(%s), %s);" %
+              (i - 1, ", ".join(args[:-1]), args[-1]))
         print("}")
-   print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items)")
-   print("{")
-   print("   int i;")
-   print("   nodecl_t result = nodecl_null();")
-   print("   for (i = 0; i < num_items; i++) result = nodecl_append_to_list(result, items[i]);")
-   print("   return result;")
-   print("}")
-
-   classes = {}
-   for rule_name in rule_map:
-       rule_rhs = rule_map[rule_name]
-       for rhs in rule_rhs:
-           if rhs.__class__ == NodeclStructure:
-               classes[rhs.base_name_to_underscore_lowercase()] = rhs
-   for (key, rhs_rule) in classes.items() :
-       param_list_nodecl = []
-       param_name_list = []
-       for item in rhs_rule.subtrees:
-           i = 0
-           pattern = item[1].replace("-", "_").replace("*", "_") + "_%d"
-           while (pattern % i) in param_name_list:
-               i = i + 1
-           param_name = pattern % i
-           param_name_list.append(param_name)
-           param_list_nodecl.append("nodecl_t %s" % (param_name))
-       if rhs_rule.needs_symbol:
-           param_list_nodecl.append("scope_entry_t* symbol");
-       if rhs_rule.needs_type:
-           param_list_nodecl.append("type_t* type");
-       if rhs_rule.needs_text:
-           param_list_nodecl.append("const char* text");
-       if rhs_rule.needs_cval:
-           param_list_nodecl.append("const_value_t* cval");
-       if rhs_rule.needs_template_parameters:
-           param_list_nodecl.append("template_parameter_list_t* template_parameters");
-       if rhs_rule.needs_decl_context:
-           param_list_nodecl.append("const decl_context_t* decl_context");
-       param_list_nodecl.append("const locus_t* location");
-       if not param_list_nodecl:
-           raise Exception("Empty list!")
-
-       print("nodecl_t nodecl_make_%s(%s)" % (key, ", ".join(param_list_nodecl)))
-       print("{")
-       # Inline check
-       i = 0
-       for subrule in rhs_rule.subtrees:
-          subrule_ref = RuleRef(subrule[1])
-          first_set = RuleRef(subrule_ref.canonical_rule()).first();
-
-          print("{")
-          print("nodecl_t checked_tree = %s;" % (param_name_list[i]))
-          if not subrule_ref.is_nullable():
-              print("if (nodecl_is_null(checked_tree))")
-              print("{")
-              print("  internal_error(\"Null node not allowed in node %d nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key))
-              print("}")
-          if subrule_ref.is_nullable():
-             print("if (!nodecl_is_null(checked_tree))")
-             print("{")
-          if subrule_ref.is_seq():
-             print(" if (!nodecl_is_list(checked_tree))")
-             print(" {")
-             print("  internal_error(\"Node must be a list in node %d of nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));" % (i, key))
-             print(" }")
-             print("AST list = nodecl_get_ast(checked_tree), it;")
-             print("for_each_element(list, it)")
-             print("{")
-             print("  checked_tree = _nodecl_wrap(ASTSon1(it));")
-          if first_set :
-              checks = ["(nodecl_get_kind(checked_tree) != %s)" % (x) for x in first_set]
-              print("if (%s)" % ("\n&& ".join(checks)))
-              print("{")
-              print("  internal_error(\"Invalid node %d of type %%s in nodecl_make_%s. Location: %%s\\n\", ast_print_node_type(nodecl_get_kind(checked_tree)), locus_to_str(location));" % (i, key))
-              print("}")
-          if subrule_ref.is_seq():
-             print("}")
-          if subrule_ref.is_nullable():
-             print("}")
-          i = i + 1
-          print("}")
-
-       if rhs_rule.needs_text:
-           print("  if (text == NULL) internal_error(\"This node requires a text. Location: %s\", locus_to_str(location));")
-           text_value = "text";
-       else:
-           text_value = "NULL"
-
-       # Build the node
-       print("  nodecl_t result = nodecl_null();")
-       num_children = len(rhs_rule.subtrees)
-       if num_children == 0:
-          print("  result.tree = ASTLeaf(%s, location, %s);" % (rhs_rule.name_to_underscore(), text_value))
-       else:
-          print("  result.tree = ASTMake%d(%s, %s, location, %s);" % (num_children, rhs_rule.name_to_underscore(), \
-                 ", ".join([x + ".tree" for x in param_name_list]), text_value));
-
-       if rhs_rule.needs_symbol:
-           print("  if (symbol == NULL) internal_error(\"Node requires a symbol. Location: %s\", locus_to_str(location));")
-           print("  nodecl_set_symbol(result, symbol);")
-       if rhs_rule.needs_type:
-           print("  if (type == NULL) internal_error(\"This node requires a type. Location: %s\", locus_to_str(location));")
-           print("  nodecl_set_type(result, type);")
-       if rhs_rule.needs_cval:
-           print("  if (cval == NULL) internal_error(\"This node requires a constant value. Location: %s\", locus_to_str(location));")
-           print("  nodecl_set_constant(result, cval);")
-       if rhs_rule.needs_template_parameters:
-           print("  nodecl_set_template_parameters(result, template_parameters);")
-       if rhs_rule.needs_decl_context:
-           print("  nodecl_set_decl_context(result, decl_context);")
-
-       print("  return result;")
-       print("}")
-       print("")
+    print("nodecl_t nodecl_make_list_n(int num_items, nodecl_t* items)")
+    print("{")
+    print("   int i;")
+    print("   nodecl_t result = nodecl_null();")
+    print(
+        "   for (i = 0; i < num_items; i++) result = nodecl_append_to_list(result, items[i]);"
+    )
+    print("   return result;")
+    print("}")
+
+    classes = {}
+    for rule_name in rule_map:
+        rule_rhs = rule_map[rule_name]
+        for rhs in rule_rhs:
+            if rhs.__class__ == NodeclStructure:
+                classes[rhs.base_name_to_underscore_lowercase()] = rhs
+    for (key, rhs_rule) in classes.items():
+        param_list_nodecl = []
+        param_name_list = []
+        for item in rhs_rule.subtrees:
+            i = 0
+            pattern = item[1].replace("-", "_").replace("*", "_") + "_%d"
+            while (pattern % i) in param_name_list:
+                i = i + 1
+            param_name = pattern % i
+            param_name_list.append(param_name)
+            param_list_nodecl.append("nodecl_t %s" % (param_name))
+        if rhs_rule.needs_symbol:
+            param_list_nodecl.append("scope_entry_t* symbol")
+        if rhs_rule.needs_type:
+            param_list_nodecl.append("type_t* type")
+        if rhs_rule.needs_text:
+            param_list_nodecl.append("const char* text")
+        if rhs_rule.needs_cval:
+            param_list_nodecl.append("const_value_t* cval")
+        if rhs_rule.needs_template_parameters:
+            param_list_nodecl.append(
+                "template_parameter_list_t* template_parameters")
+        if rhs_rule.needs_decl_context:
+            param_list_nodecl.append("const decl_context_t* decl_context")
+        param_list_nodecl.append("const locus_t* location")
+        if not param_list_nodecl:
+            raise Exception("Empty list!")
+
+        print("nodecl_t nodecl_make_%s(%s)" %
+              (key, ", ".join(param_list_nodecl)))
+        print("{")
+        # Inline check
+        i = 0
+        for subrule in rhs_rule.subtrees:
+            subrule_ref = RuleRef(subrule[1])
+            first_set = RuleRef(subrule_ref.canonical_rule()).first()
+
+            print("{")
+            print("nodecl_t checked_tree = %s;" % (param_name_list[i]))
+            if not subrule_ref.is_nullable():
+                print("if (nodecl_is_null(checked_tree))")
+                print("{")
+                print(
+                    "  internal_error(\"Null node not allowed in node %d nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));"
+                    % (i, key))
+                print("}")
+            if subrule_ref.is_nullable():
+                print("if (!nodecl_is_null(checked_tree))")
+                print("{")
+            if subrule_ref.is_seq():
+                print(" if (!nodecl_is_list(checked_tree))")
+                print(" {")
+                print(
+                    "  internal_error(\"Node must be a list in node %d of nodecl_make_%s. Location: %%s\\n\", locus_to_str(location));"
+                    % (i, key))
+                print(" }")
+                print("AST list = nodecl_get_ast(checked_tree), it;")
+                print("for_each_element(list, it)")
+                print("{")
+                print("  checked_tree = _nodecl_wrap(ASTSon1(it));")
+            if first_set:
+                checks = [
+                    "(nodecl_get_kind(checked_tree) != %s)" % (x)
+                    for x in first_set
+                ]
+                print("if (%s)" % ("\n&& ".join(checks)))
+                print("{")
+                print(
+                    "  internal_error(\"Invalid node %d of type %%s in nodecl_make_%s. Location: %%s\\n\", ast_print_node_type(nodecl_get_kind(checked_tree)), locus_to_str(location));"
+                    % (i, key))
+                print("}")
+            if subrule_ref.is_seq():
+                print("}")
+            if subrule_ref.is_nullable():
+                print("}")
+            i = i + 1
+            print("}")
+
+        if rhs_rule.needs_text:
+            print(
+                "  if (text == NULL) internal_error(\"This node requires a text. Location: %s\", locus_to_str(location));"
+            )
+            text_value = "text"
+        else:
+            text_value = "NULL"
+
+        # Build the node
+        print("  nodecl_t result = nodecl_null();")
+        num_children = len(rhs_rule.subtrees)
+        if num_children == 0:
+            print("  result.tree = ASTLeaf(%s, location, %s);" %
+                  (rhs_rule.name_to_underscore(), text_value))
+        else:
+            print("  result.tree = ASTMake%d(%s, %s, location, %s);" % (num_children, rhs_rule.name_to_underscore(), \
+                   ", ".join([x + ".tree" for x in param_name_list]), text_value))
+
+        if rhs_rule.needs_symbol:
+            print(
+                "  if (symbol == NULL) internal_error(\"Node requires a symbol. Location: %s\", locus_to_str(location));"
+            )
+            print("  nodecl_set_symbol(result, symbol);")
+        if rhs_rule.needs_type:
+            print(
+                "  if (type == NULL) internal_error(\"This node requires a type. Location: %s\", locus_to_str(location));"
+            )
+            print("  nodecl_set_type(result, type);")
+        if rhs_rule.needs_cval:
+            print(
+                "  if (cval == NULL) internal_error(\"This node requires a constant value. Location: %s\", locus_to_str(location));"
+            )
+            print("  nodecl_set_constant(result, cval);")
+        if rhs_rule.needs_template_parameters:
+            print(
+                "  nodecl_set_template_parameters(result, template_parameters);"
+            )
+        if rhs_rule.needs_decl_context:
+            print("  nodecl_set_decl_context(result, decl_context);")
+
+        print("  return result;")
+        print("}")
+        print("")
+
 
 def generate_c_visitor_decl(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("""
 #ifndef CXX_NODECL_VISITOR_H
 #define CXX_NODECL_VISITOR_H
@@ -1146,7 +1381,8 @@ struct nodecl_external_visitor_tag
             if rhs.__class__ == NodeclStructure:
                 node_kind.add(rhs.base_name_to_underscore_lowercase())
     for node in node_kind:
-        print("void (*visit_%s)(nodecl_external_visitor_t*, nodecl_t a);" % ( node ))
+        print("void (*visit_%s)(nodecl_external_visitor_t*, nodecl_t a);" %
+              (node))
 
     print("""
 };
@@ -1163,9 +1399,12 @@ MCXX_END_DECLS
 #endif // CXX_NODECL_VISITOR_H
 """)
 
+
 def generate_c_visitor_def(rule_map):
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
     print("""
 #include "cxx-nodecl-visitor.h"
 #include "cxx-utils.h"
@@ -1185,9 +1424,12 @@ void nodecl_walk(nodecl_external_visitor_t* external_visitor, nodecl_t n)
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                node_kind.add((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower()))
+                node_kind.add((rhs.name_to_underscore(),
+                               rhs.base_name_to_underscore().lower()))
     for node in node_kind:
-        print("       case %s: { if (external_visitor->visit_%s != NULL) external_visitor->visit_%s(external_visitor, n); break; }" % (node[0], node[1], node[1]))
+        print(
+            "       case %s: { if (external_visitor->visit_%s != NULL) external_visitor->visit_%s(external_visitor, n); break; }"
+            % (node[0], node[1], node[1]))
     print("""
        default:
            { internal_error("Unexpected tree kind '%s'\\n", ast_print_node_type(ASTKind(tree))); }
@@ -1203,6 +1445,7 @@ void nodecl_init_walker(nodecl_external_visitor_t* external_visitor, void (*defa
 }
 """)
 
+
 def generate_asttypes(rule_map):
     node_kind = set([])
     for rule_name in rule_map:
@@ -1215,6 +1458,7 @@ def generate_asttypes(rule_map):
     for kind_name in l:
         print(kind_name)
 
+
 def generate_c_shallow_copy_def(rule_map):
     print("#include \"cxx-nodecl.h\"")
     print("#include \"cxx-nodecl-output.h\"")
@@ -1222,7 +1466,9 @@ def generate_c_shallow_copy_def(rule_map):
     print("#include \"cxx-utils.h\"")
     print("#include \"mem.h\"")
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
 
     print("""
 nodecl_t nodecl_shallow_copy(nodecl_t n)
@@ -1252,7 +1498,8 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                node_kind.append((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower(), rhs))
+                node_kind.append((rhs.name_to_underscore(),
+                                  rhs.base_name_to_underscore().lower(), rhs))
     for node in node_kind:
         nodecl_class = node[2]
         print("       case %s:" % (node[0]))
@@ -1264,16 +1511,20 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
             current_rule = RuleRef(rule_ref)
 
             if current_rule.canonical_rule() != "any":
-                print("nodecl_t child_%d = nodecl_shallow_copy(nodecl_get_child(n, %d));" % (i, i))
+                print(
+                    "nodecl_t child_%d = nodecl_shallow_copy(nodecl_get_child(n, %d));"
+                    % (i, i))
             else:
-                print("nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i))
+                print(
+                    "nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));"
+                    % (i, i))
 
             factory_arguments.append("child_%d" % (i))
             i = i + 1
 
-        needs_attr = lambda x : getattr(nodecl_class, "needs_%s" % (x))
-        may_have_attr = lambda x : getattr(nodecl_class, "may_have_%s" % (x))
-        has_attr = lambda x : needs_attr(x) or may_have_attr(x)
+        needs_attr = lambda x: getattr(nodecl_class, "needs_%s" % (x))
+        may_have_attr = lambda x: getattr(nodecl_class, "may_have_%s" % (x))
+        has_attr = lambda x: needs_attr(x) or may_have_attr(x)
 
         if has_attr("symbol"):
             print("scope_entry_t* symbol = nodecl_get_symbol(n);")
@@ -1296,18 +1547,23 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
             factory_arguments.append("cval")
 
         if has_attr("template_parameters"):
-            print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);")
+            print(
+                "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);"
+            )
         if needs_attr("template_parameters"):
             factory_arguments.append("template_parameters")
 
         if has_attr("decl_context"):
-            print("const decl_context_t* decl_context = nodecl_get_decl_context(n);");
+            print(
+                "const decl_context_t* decl_context = nodecl_get_decl_context(n);"
+            )
         if needs_attr("decl_context"):
             factory_arguments.append("decl_context")
 
         print("const locus_t* location = nodecl_get_locus(n);")
         factory_arguments.append("location")
-        print("nodecl_t result = nodecl_make_%s(%s);" % (node[1], ", ".join(factory_arguments)))
+        print("nodecl_t result = nodecl_make_%s(%s);" %
+              (node[1], ", ".join(factory_arguments)))
 
         if may_have_attr("symbol"):
             print("nodecl_set_symbol(result, symbol);")
@@ -1322,16 +1578,21 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
             print("nodecl_set_constant(result, cval);")
 
         if may_have_attr("template_parameters"):
-            print("nodecl_set_template_parameters(result, template_parameters);")
+            print(
+                "nodecl_set_template_parameters(result, template_parameters);")
 
         if may_have_attr("decl_context"):
             print("nodecl_set_decl_context(result, decl_context);")
 
         # Extra attributes from expressions
-        print("nodecl_expr_set_is_value_dependent(result, nodecl_expr_is_value_dependent(n));")
-        print("nodecl_expr_set_is_type_dependent(result, nodecl_expr_is_type_dependent(n));")
-
-        print("       return result;");
+        print(
+            "nodecl_expr_set_is_value_dependent(result, nodecl_expr_is_value_dependent(n));"
+        )
+        print(
+            "nodecl_expr_set_is_type_dependent(result, nodecl_expr_is_type_dependent(n));"
+        )
+
+        print("       return result;")
         print("       break;")
         print("       }")
     print("""
@@ -1342,6 +1603,7 @@ nodecl_t nodecl_shallow_copy(nodecl_t n)
 }
 """)
 
+
 def generate_c_deep_copy_def(rule_map):
     print("#include \"cxx-nodecl.h\"")
     print("#include \"cxx-nodecl-deep-copy.h\"")
@@ -1353,7 +1615,9 @@ def generate_c_deep_copy_def(rule_map):
     print("#include \"cxx-utils.h\"")
     print("#include \"mem.h\"")
     print("/* Autogenerated file. DO NOT MODIFY. */")
-    print("/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */")
+    print(
+        "/* Changes in nodecl-generator.py or cxx-nodecl.def will overwrite this file */"
+    )
 
     print("""
 extern nodecl_t nodecl_deep_copy_context(nodecl_t n, const decl_context_t* new_decl_context,
@@ -1405,21 +1669,30 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
         rule_rhs = rule_map[rule_name]
         for rhs in rule_rhs:
             if rhs.__class__ == NodeclStructure:
-                node_kind.append((rhs.name_to_underscore(), rhs.base_name_to_underscore().lower(), rhs))
+                node_kind.append((rhs.name_to_underscore(),
+                                  rhs.base_name_to_underscore().lower(), rhs))
     for node in node_kind:
         nodecl_class = node[2]
         print("       case %s:" % (node[0]))
         print("       {")
 
         if node[0] == "NODECL_CONTEXT":
-            print("          result = nodecl_deep_copy_context(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
-            print("          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);")
+            print(
+                "          result = nodecl_deep_copy_context(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+            )
+            print(
+                "          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);"
+            )
             print("          return result;")
             print("       }")
             continue
         elif node[0] == "NODECL_FUNCTION_CODE":
-            print("          result = nodecl_deep_copy_function_code(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
-            print("          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);")
+            print(
+                "          result = nodecl_deep_copy_function_code(n, new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+            )
+            print(
+                "          nodecl_deep_copy_map_add(nodecl_deep_copy_map, n, result);"
+            )
             print("          return result;")
             print("       }")
             continue
@@ -1431,26 +1704,34 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
             current_rule = RuleRef(rule_ref)
 
             if current_rule.canonical_rule() != "any":
-                print("nodecl_t child_%d = nodecl_deep_copy_rec(nodecl_get_child(n, %d), new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);" % (i, i))
+                print(
+                    "nodecl_t child_%d = nodecl_deep_copy_rec(nodecl_get_child(n, %d), new_decl_context, (*synth_symbol_map), synth_symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+                    % (i, i))
             else:
-                print("nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));" % (i, i));
+                print(
+                    "nodecl_t child_%d = _nodecl_wrap(ast_copy(nodecl_get_ast(nodecl_get_child(n, %d))));"
+                    % (i, i))
 
             factory_arguments.append("child_%d" % (i))
             i = i + 1
 
-        needs_attr = lambda x : getattr(nodecl_class, "needs_%s" % (x))
-        may_have_attr = lambda x : getattr(nodecl_class, "may_have_%s" % (x))
-        has_attr = lambda x : needs_attr(x) or may_have_attr(x)
+        needs_attr = lambda x: getattr(nodecl_class, "needs_%s" % (x))
+        may_have_attr = lambda x: getattr(nodecl_class, "may_have_%s" % (x))
+        has_attr = lambda x: needs_attr(x) or may_have_attr(x)
 
         if has_attr("symbol"):
-            print("scope_entry_t* symbol = (*synth_symbol_map)->map(*synth_symbol_map, nodecl_get_symbol(n));")
+            print(
+                "scope_entry_t* symbol = (*synth_symbol_map)->map(*synth_symbol_map, nodecl_get_symbol(n));"
+            )
         if needs_attr("symbol"):
             factory_arguments.append("symbol")
 
         # FIXME - The type may have to be regenerated as well
         if has_attr("type"):
             print("type_t* type = nodecl_get_type(n);")
-            print("type = type_deep_copy_compute_maps(type, /* dest */ NULL, new_decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);")
+            print(
+                "type = type_deep_copy_compute_maps(type, /* dest */ NULL, new_decl_context, symbol_map, nodecl_deep_copy_map, symbol_deep_copy_map);"
+            )
         if needs_attr("type"):
             factory_arguments.append("type")
 
@@ -1460,24 +1741,31 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
             factory_arguments.append("text")
 
         if has_attr("cval"):
-            print("const_value_t* cval = const_value_deep_copy(nodecl_get_constant(n), *synth_symbol_map);")
+            print(
+                "const_value_t* cval = const_value_deep_copy(nodecl_get_constant(n), *synth_symbol_map);"
+            )
         if needs_attr("cval"):
             factory_arguments.append("cval")
 
         if has_attr("template_parameters"):
-            print("template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);")
+            print(
+                "template_parameter_list_t* template_parameters = nodecl_get_template_parameters(n);"
+            )
         if needs_attr("template_parameters"):
             factory_arguments.append("template_parameters")
 
         if has_attr("decl_context"):
-            print("const decl_context_t* decl_context = nodecl_get_decl_context(n);");
+            print(
+                "const decl_context_t* decl_context = nodecl_get_decl_context(n);"
+            )
         if needs_attr("decl_context"):
             factory_arguments.append("decl_context")
 
         print("const locus_t* location = nodecl_get_locus(n);")
         factory_arguments.append("location")
 
-        print("result = nodecl_make_%s(%s);" % (node[1], ", ".join(factory_arguments)))
+        print("result = nodecl_make_%s(%s);" %
+              (node[1], ", ".join(factory_arguments)))
 
         if may_have_attr("symbol"):
             print("nodecl_set_symbol(result, symbol);")
@@ -1492,7 +1780,8 @@ nodecl_t nodecl_deep_copy_rec(nodecl_t n, const decl_context_t* new_decl_context
             print("nodecl_set_constant(result, cval);")
 
         if may_have_attr("template_parameters"):
-            print("nodecl_set_template_parameters(result, template_parameters);")
+            print(
+                "nodecl_set_template_parameters(result, template_parameters);")
 
         if may_have_attr("decl_context"):
             print("nodecl_set_decl_context(n, decl_context);")
-- 
2.37.3


From 181049accdf390e972955eca81db573941f933e3 Mon Sep 17 00:00:00 2001
From: Roger Ferrer Ibanez <roger.ferrer@bsc.es>
Date: Fri, 12 Jul 2019 18:57:56 +0200
Subject: [PATCH 4/5] Prioritize Python 3.0 in a better way

---
 configure.ac | 15 ++++-----------
 1 file changed, 4 insertions(+), 11 deletions(-)

diff --git a/configure.ac b/configure.ac
index 0cb148c79..1c58e5124 100644
--- a/configure.ac
+++ b/configure.ac
@@ -78,17 +78,10 @@ AX_CXX_COMPILE_STDCXX_11([noext],[optional])
 dnl Check GNU Bash.
 AC_PATH_PROG([BASH], [bash], [])
 
-dnl Prioritize Python 3.x
-AM_PATH_PYTHON([3.0],, [:])
-
-dnl Fallback to 2.7
-if test "$PYTHON" = ":"; then
-   # The earlier result is cached which would make the next check a no-op
-   unset PYTHON
-   unset ac_cv_path_PYTHON
-   unset am_cv_pathless_PYTHON
-   AM_PATH_PYTHON([2.7])
-fi
+# Prioritize Python 3.x
+AM_PYTHON_CHECK_VERSION([$PYTHON], [3.0],
+  [AM_PATH_PYTHON([3.0])],
+  [AM_PATH_PYTHON([2.7])])
 
 if test x$BASH = x; then
   # If GNU Bash isn't available, use the current shell and hope for
-- 
2.37.3


From 2a98963e7ff28f70cf2a8bcf42a792a1420f36e3 Mon Sep 17 00:00:00 2001
From: Roger Ferrer Ibanez <roger.ferrer@bsc.es>
Date: Fri, 12 Jul 2019 19:05:04 +0200
Subject: [PATCH 5/5] Fix previous commit

We weren't prioritising Python 3.0 with the earlier approach
---
 configure.ac | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 1c58e5124..b602e7266 100644
--- a/configure.ac
+++ b/configure.ac
@@ -79,9 +79,24 @@ dnl Check GNU Bash.
 AC_PATH_PROG([BASH], [bash], [])
 
 # Prioritize Python 3.x
-AM_PYTHON_CHECK_VERSION([$PYTHON], [3.0],
-  [AM_PATH_PYTHON([3.0])],
-  [AM_PATH_PYTHON([2.7])])
+if test -n "$PYTHON"; then
+  # When PYTHON is not empty, AM_PATH_PYTHON always fails with a hard error
+  # if the Python is too old so we first check if will fail or not.
+  AM_PYTHON_CHECK_VERSION([$PYTHON], [3.0],
+    [AM_PATH_PYTHON([3.0])],
+    [AM_PATH_PYTHON([2.7])])
+else
+  AM_PATH_PYTHON([3.0],, [:])
+  dnl Fallback to 2.7
+  if test "$PYTHON" = ":"; then
+     # The earlier result is cached which would make the next check a no-op
+     unset PYTHON
+     unset ac_cv_path_PYTHON
+     unset am_cv_pathless_PYTHON
+     AM_PATH_PYTHON([2.7])
+  fi
+fi
+
 
 if test x$BASH = x; then
   # If GNU Bash isn't available, use the current shell and hope for
-- 
2.37.3

