From 1b1af8cf91e0ccdd2e02b0460c67d0be7a042d77 Mon Sep 17 00:00:00 2001
From: Darshit Shah <darnir@gmail.com>
Date: Mon, 2 May 2016 11:42:21 +0200
Subject: [PATCH 2/4] Add Sidebar support to Mutt

---
 Makefile.am    |   1 +
 OPS            |   5 +
 PATCHES        |   1 +
 buffy.c        | 151 ++++++++++++++++++++-
 buffy.h        |   6 +
 color.c        |   2 +
 compose.c      |  26 ++--
 configure.ac   |   2 +
 curs_main.c    |  37 +++++-
 flags.c        |   3 +
 functions.h    |  10 ++
 globals.h      |   6 +
 handler.c      |  34 +++++
 imap/command.c |   7 +
 imap/imap.c    |   2 +-
 init.h         |  48 +++++++
 mailbox.h      |   1 +
 main.c         |  11 +-
 mbox.c         |   2 +
 menu.c         |  20 +--
 mh.c           |  26 ++++
 mutt.h         |   6 +
 mutt_curses.h  |   3 +
 mutt_menu.h    |   1 +
 muttlib.c      |  48 +++++++
 mx.c           |  24 +++-
 mx.h           |   1 +
 pager.c        |  43 ++++--
 pattern.c      |  38 ++++++
 protos.h       |   7 +
 sidebar.c      | 405 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 sidebar.h      |  36 +++++
 32 files changed, 971 insertions(+), 42 deletions(-)
 create mode 100644 sidebar.c
 create mode 100644 sidebar.h

diff --git a/Makefile.am b/Makefile.am
index 9ee3fae..6076f84 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -34,6 +34,7 @@ mutt_SOURCES = \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c mbyte.c \
+	sidebar.c \
 	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
 
 nodist_mutt_SOURCES = $(BUILT_SOURCES)
diff --git a/OPS b/OPS
index 8414a8b..ef14453 100644
--- a/OPS
+++ b/OPS
@@ -179,3 +179,8 @@ OP_WHAT_KEY "display the keycode for a key press"
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
+OP_SIDEBAR_SCROLL_UP "scroll the mailbox pane up 1 page"
+OP_SIDEBAR_SCROLL_DOWN "scroll the mailbox pane down 1 page"
+OP_SIDEBAR_NEXT "go down to next mailbox"
+OP_SIDEBAR_PREV "go to previous mailbox"
+OP_SIDEBAR_OPEN "open hilighted mailbox"
diff --git a/PATCHES b/PATCHES
index 6a47dd7..a17259d 100644
--- a/PATCHES
+++ b/PATCHES
@@ -1 +1,2 @@
+patch-1.5.23.sidebar.20140412.txt
 patch-1.5.16hg.cd.trash_folder.vl.1
diff --git a/buffy.c b/buffy.c
index dd3def0..65cd659 100644
--- a/buffy.c
+++ b/buffy.c
@@ -161,6 +161,49 @@ void mutt_buffy_cleanup (const char *buf, struct stat *st)
   }
 }
 
+static int buffy_compare_name(const void *a, const void *b) {
+  const BUFFY *b1 = * (BUFFY * const *) a;
+  const BUFFY *b2 = * (BUFFY * const *) b;
+
+  return mutt_strcoll(b1->path, b2->path);
+}
+
+static BUFFY *buffy_sort(BUFFY *b)
+{
+  BUFFY *tmp = b;
+  int buffycount = 0;
+  BUFFY **ary;
+  int i;
+
+  if (!option(OPTSIDEBARSORT))
+    return b;
+
+  for (; tmp != NULL; tmp = tmp->next)
+    buffycount++;
+
+  ary = (BUFFY **) safe_calloc(buffycount, sizeof (*ary));
+
+  tmp = b;
+  for (i = 0; tmp != NULL; tmp = tmp->next, i++) {
+    ary[i] = tmp;
+  }
+
+  qsort(ary, buffycount, sizeof(*ary), buffy_compare_name);
+
+  for (i = 0; i < buffycount - 1; i++) {
+    ary[i]->next = ary[i+1];
+  }
+  ary[buffycount - 1]->next = NULL;
+  for (i = 1; i < buffycount; i++) {
+    ary[i]->prev = ary[i-1];
+  }
+  ary[0]->prev = NULL;
+
+  tmp = ary[0];
+  free(ary);
+  return tmp;
+}
+
 BUFFY *mutt_find_mailbox (const char *path)
 {
   BUFFY *tmp = NULL;
@@ -196,9 +239,13 @@ void mutt_update_mailbox (BUFFY * b)
 static BUFFY *buffy_new (const char *path)
 {
   BUFFY* buffy;
+  char rp[PATH_MAX];
+  char *r;
 
   buffy = (BUFFY *) safe_calloc (1, sizeof (BUFFY));
   strfcpy (buffy->path, path, sizeof (buffy->path));
+  r = realpath(path, rp);
+  strfcpy (buffy->realpath, r ? rp : path, sizeof (buffy->realpath));
   buffy->next = NULL;
   buffy->magic = 0;
 
@@ -243,8 +290,8 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
     p = realpath (buf, f1);
     for (tmp = &Incoming; *tmp; tmp = &((*tmp)->next))
     {
-      q = realpath ((*tmp)->path, f2);
-      if (mutt_strcmp (p ? p : buf, q ? q : (*tmp)->path) == 0)
+      q = (*tmp)->realpath;
+      if (mutt_strcmp (p ? p : buf, q) == 0)
       {
 	dprint(3,(debugfile,"mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
 	break;
@@ -282,6 +329,7 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
     else
       (*tmp)->size = 0;
   }
+  Incoming = buffy_sort(Incoming);
   return 0;
 }
 
@@ -306,6 +354,11 @@ static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
       return 0;
   }
 
+  if (option(OPTSIDEBAR) && mailbox->msg_unread > 0) {
+      mailbox->new = 1;
+      return 1;
+  }
+
   if ((dirp = opendir (path)) == NULL)
   {
     mailbox->magic = 0;
@@ -340,6 +393,72 @@ static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
   return rc;
 }
 
+ /* update message counts for the sidebar */
+ void buffy_maildir_update (BUFFY* mailbox)
+ {
+   char path[_POSIX_PATH_MAX];
+   DIR *dirp;
+   struct dirent *de;
+   char *p;
+
+   if(!option(OPTSIDEBAR))
+       return;
+
+   mailbox->msgcount = 0;
+   mailbox->msg_unread = 0;
+   mailbox->msg_flagged = 0;
+
+   snprintf (path, sizeof (path), "%s/new", mailbox->path);
+
+   if ((dirp = opendir (path)) == NULL)
+   {
+     mailbox->magic = 0;
+     return;
+   }
+
+   while ((de = readdir (dirp)) != NULL)
+   {
+     if (*de->d_name == '.')
+       continue;
+
+     if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+       mailbox->new = 1;
+       mailbox->msgcount++;
+       mailbox->msg_unread++;
+     }
+   }
+
+   closedir (dirp);
+   snprintf (path, sizeof (path), "%s/cur", mailbox->path);
+
+   if ((dirp = opendir (path)) == NULL)
+   {
+     mailbox->magic = 0;
+     return;
+   }
+
+   while ((de = readdir (dirp)) != NULL)
+   {
+     if (*de->d_name == '.')
+       continue;
+
+     if (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')) {
+       mailbox->msgcount++;
+       if ((p = strstr (de->d_name, ":2,"))) {
+         if (!strchr (p + 3, 'T')) {
+           if (!strchr (p + 3, 'S'))
+             mailbox->msg_unread++;
+           if (strchr(p + 3, 'F'))
+             mailbox->msg_flagged++;
+         }
+       }
+     }
+   }
+
+   mailbox->sb_last_checked = time(NULL);
+   closedir (dirp);
+ }
+
 /* returns 1 if maildir has new mail */
 static int buffy_maildir_hasnew (BUFFY* mailbox)
 {
@@ -368,7 +487,7 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
   else
     statcheck = sb->st_mtime > sb->st_atime
       || (mailbox->newly_created && sb->st_ctime == sb->st_mtime && sb->st_ctime == sb->st_atime);
-  if (statcheck)
+  if ((!option(OPTSIDEBAR) && statcheck) || (option(OPTSIDEBAR) && mailbox->msg_unread > 0))
   {
     if (!option(OPTMAILCHECKRECENT) || sb->st_mtime > mailbox->last_visited)
     {
@@ -388,6 +507,27 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
   return rc;
 }
 
+/* update message counts for the sidebar */
+void buffy_mbox_update (BUFFY* mailbox, struct stat *sb)
+{
+  CONTEXT *ctx = NULL;
+
+  if(!option(OPTSIDEBAR))
+      return;
+  if(mailbox->sb_last_checked > sb->st_mtime && mailbox->msgcount != 0)
+      return; /* no check necessary */
+
+  ctx = mx_open_mailbox(mailbox->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+  if(ctx)
+  {
+    mailbox->msgcount = ctx->msgcount;
+    mailbox->msg_unread = ctx->unread;
+    mailbox->msg_flagged = ctx->flagged;
+    mailbox->sb_last_checked = time(NULL);
+    mx_close_mailbox(ctx, 0);
+  }
+}
+
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
@@ -461,17 +601,20 @@ int mutt_buffy_check (int force)
       {
       case M_MBOX:
       case M_MMDF:
+	buffy_mbox_update (tmp, &sb);
 	if (buffy_mbox_hasnew (tmp, &sb) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MAILDIR:
+	buffy_maildir_update (tmp);
 	if (buffy_maildir_hasnew (tmp) > 0)
 	  BuffyCount++;
 	break;
 
       case M_MH:
-	mh_buffy(tmp);
+	mh_buffy_update (tmp->path, &tmp->msgcount, &tmp->msg_unread, &tmp->msg_flagged, &tmp->sb_last_checked);
+    mh_buffy(tmp);
 	if (tmp->new)
 	  BuffyCount++;
 	break;
diff --git a/buffy.h b/buffy.h
index 9aa8e51..03c37df 100644
--- a/buffy.h
+++ b/buffy.h
@@ -23,13 +23,19 @@
 typedef struct buffy_t
 {
   char path[_POSIX_PATH_MAX];
+  char realpath[_POSIX_PATH_MAX];
   off_t size;
   struct buffy_t *next;
+  struct buffy_t *prev;
   short new;			/* mailbox has new mail */
+  int msgcount;			/* total number of messages */
+  int msg_unread;		/* number of unread messages */
+  int msg_flagged;		/* number of flagged messages */
   short notified;		/* user has been notified */
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
   time_t last_visited;		/* time of last exit from this mailbox */
+  time_t sb_last_checked;      /* time of last buffy check from sidebar */
 }
 BUFFY;
 
diff --git a/color.c b/color.c
index 6e29603..19d4734 100644
--- a/color.c
+++ b/color.c
@@ -93,6 +93,8 @@ static const struct mapping_t Fields[] =
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "sidebar_new",	MT_COLOR_NEW },
+  { "sidebar_flagged",	MT_COLOR_FLAGGED },
   { "prompt",		MT_COLOR_PROMPT },
   { NULL,		0 }
 };
diff --git a/compose.c b/compose.c
index 7b9cf7d..ed4d438 100644
--- a/compose.c
+++ b/compose.c
@@ -72,7 +72,7 @@ enum
 
 #define HDR_XOFFSET 10
 #define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
-#define W (MuttIndexWindow->cols - HDR_XOFFSET)
+#define W (MuttIndexWindow->cols - HDR_XOFFSET - SidebarWidth)
 
 static const char * const Prompts[] =
 {
@@ -110,7 +110,7 @@ static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 
 static void redraw_crypt_lines (HEADER *msg)
 {
-  mutt_window_mvaddstr (MuttIndexWindow, HDR_CRYPT, 0, "Security: ");
+  mutt_window_mvaddstr (MuttIndexWindow, HDR_CRYPT, SidebarWidth, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -145,7 +145,7 @@ static void redraw_crypt_lines (HEADER *msg)
       addstr (_(" (OppEnc mode)"));
 
   mutt_window_clrtoeol (MuttIndexWindow);
-  mutt_window_move (MuttIndexWindow, HDR_CRYPTINFO, 0);
+  mutt_window_move (MuttIndexWindow, HDR_CRYPTINFO, SidebarWidth);
   mutt_window_clrtoeol (MuttIndexWindow);
 
   if ((WithCrypto & APPLICATION_PGP)
@@ -162,7 +162,7 @@ static void redraw_crypt_lines (HEADER *msg)
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-    mutt_window_mvprintw (MuttIndexWindow, HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+    mutt_window_mvprintw (MuttIndexWindow, HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
   }
 }
@@ -175,7 +175,7 @@ static void redraw_mix_line (LIST *chain)
   int c;
   char *t;
 
-  mutt_window_mvaddstr (MuttIndexWindow, HDR_MIX, 0,     "     Mix: ");
+  mutt_window_mvaddstr (MuttIndexWindow, HDR_MIX, SidebarWidth,     "     Mix: ");
 
   if (!chain)
   {
@@ -190,7 +190,7 @@ static void redraw_mix_line (LIST *chain)
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
     
-    if (c + mutt_strlen (t) + 2 >= MuttIndexWindow->cols)
+    if (c + mutt_strlen (t) + 2 >= MuttIndexWindow->cols - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -242,7 +242,7 @@ static void draw_envelope_addr (int line, ADDRESS *addr)
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mutt_window_mvprintw (MuttIndexWindow, line, 0, TITLE_FMT, Prompts[line]);
+  mutt_window_mvprintw (MuttIndexWindow, line, SidebarWidth, TITLE_FMT, Prompts[line]);
   mutt_paddstr (W, buf);
 }
 
@@ -252,10 +252,10 @@ static void draw_envelope (HEADER *msg, char *fcc)
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
-  mutt_window_mvprintw (MuttIndexWindow, HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT]);
+  mutt_window_mvprintw (MuttIndexWindow, HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
-  mutt_window_mvprintw (MuttIndexWindow, HDR_FCC, 0, TITLE_FMT, Prompts[HDR_FCC]);
+  mutt_window_mvprintw (MuttIndexWindow, HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC]);
   mutt_paddstr (W, fcc);
 
   if (WithCrypto)
@@ -266,7 +266,7 @@ static void draw_envelope (HEADER *msg, char *fcc)
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mutt_window_mvaddstr (MuttIndexWindow, HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mutt_window_mvaddstr (MuttIndexWindow, HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   mutt_window_clrtoeol (MuttIndexWindow);
 
   NORMAL_COLOR;
@@ -302,7 +302,7 @@ static int edit_address_list (int line, ADDRESS **addr)
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  mutt_window_move (MuttIndexWindow, line, HDR_XOFFSET);
+  mutt_window_move (MuttIndexWindow, line, HDR_XOFFSET + SidebarWidth);
   mutt_paddstr (W, buf);
   
   return 0;
@@ -564,7 +564,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  mutt_window_move (MuttIndexWindow, HDR_SUBJECT, HDR_XOFFSET);
+	  mutt_window_move (MuttIndexWindow, HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
 	  else
@@ -582,7 +582,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
-	  mutt_window_move (MuttIndexWindow, HDR_FCC, HDR_XOFFSET);
+	  mutt_window_move (MuttIndexWindow, HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
 	}
diff --git a/configure.ac b/configure.ac
index 6096dbb..481ca63 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1308,6 +1308,8 @@ if test $mutt_cv_langinfo_yesexpr = yes; then
   AC_DEFINE(HAVE_LANGINFO_YESEXPR,1,[ Define if you have <langinfo.h> and nl_langinfo(YESEXPR). ])
 fi
 
+AC_CHECK_FUNCS(fmemopen open_memstream)
+
 dnl Documentation tools
 have_openjade="no"
 AC_PATH_PROG([OSPCAT], [ospcat], [none])
diff --git a/curs_main.c b/curs_main.c
index 280b7b4..beac144 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -26,7 +26,9 @@
 #include "mailbox.h"
 #include "mapping.h"
 #include "sort.h"
+#include "buffy.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_POP
 #include "pop.h"
@@ -593,20 +595,31 @@ int mutt_index_menu (void)
        menu->redraw |= REDRAW_STATUS;
      if (do_buffy_notify)
      {
-       if (mutt_buffy_notify () && option (OPTBEEPNEW))
- 	beep ();
+       if (mutt_buffy_notify ())
+       {
+         menu->redraw |= REDRAW_STATUS;
+         if (option (OPTBEEPNEW))
+           beep ();
+       }
      }
      else
        do_buffy_notify = 1;
     }
 
+    if(option(OPTSIDEBAR))
+        menu->redraw |= REDRAW_SIDEBAR;
+
     if (op != -1)
       mutt_curs_set (0);
 
     if (menu->redraw & REDRAW_FULL)
     {
       menu_redraw_full (menu);
+      draw_sidebar(menu->menu);
       mutt_show_error ();
+    } else if(menu->redraw & REDRAW_SIDEBAR) {
+        draw_sidebar(menu->menu);
+        menu->redraw &= ~REDRAW_SIDEBAR;
     }
 
     if (menu->menu == MENU_MAIN)
@@ -628,9 +641,12 @@ int mutt_index_menu (void)
 
       if (menu->redraw & REDRAW_STATUS)
       {
+        DrawFullLine = 1;
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+        DrawFullLine = 0;
         mutt_window_move (MuttStatusWindow, 0, 0);
 	SETCOLOR (MT_COLOR_STATUS);
+        set_buffystats(Context);
 	mutt_paddstr (MuttStatusWindow->cols, buf);
 	NORMAL_COLOR;
 	menu->redraw &= ~REDRAW_STATUS;
@@ -650,7 +666,7 @@ int mutt_index_menu (void)
 	menu->oldcurrent = -1;
 
       if (option (OPTARROWCURSOR))
-	mutt_window_move (MuttIndexWindow, menu->current - menu->top + menu->offset, 2);
+	mutt_window_move (MuttIndexWindow, menu->current - menu->top + menu->offset, SidebarWidth + 2);
       else if (option (OPTBRAILLEFRIENDLY))
 	mutt_window_move (MuttIndexWindow, menu->current - menu->top + menu->offset, 0);
       else
@@ -1090,6 +1106,7 @@ int mutt_index_menu (void)
 	  break;
 
 	CHECK_MSGCOUNT;
+        CHECK_VISIBLE;
 	CHECK_READONLY;
 	{
 	  int oldvcount = Context->vcount;
@@ -1149,6 +1166,7 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_SIDEBAR_OPEN:
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
 
@@ -1180,7 +1198,11 @@ int mutt_index_menu (void)
 	{
 	  mutt_buffy (buf, sizeof (buf));
 
-	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+          if ( op == OP_SIDEBAR_OPEN ) {
+              if(!CurBuffy)
+                break;
+            strncpy( buf, CurBuffy->path, sizeof(buf) );
+	    } else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
 	  {
 	    if (menu->menu == MENU_PAGER)
 	    {
@@ -1198,6 +1220,7 @@ int mutt_index_menu (void)
 	}
 
 	mutt_expand_path (buf, sizeof (buf));
+        set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
 	{
 	  mutt_error (_("%s is not a mailbox."), buf);
@@ -2309,6 +2332,12 @@ int mutt_index_menu (void)
 	mutt_what_key();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+        scroll_sidebar(op, menu->menu);
+        break;
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff --git a/flags.c b/flags.c
index 4ce8b42..5389243 100644
--- a/flags.c
+++ b/flags.c
@@ -22,8 +22,10 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mutt_menu.h"
 #include "sort.h"
 #include "mx.h"
+#include "sidebar.h"
 
 void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
 {
@@ -280,6 +282,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
    */
   if (h->searched && (changed != h->changed || deleted != ctx->deleted || tagged != ctx->tagged || flagged != ctx->flagged))
     h->searched = 0;
+	draw_sidebar(0);
 }
 
 void mutt_tag_set_flag (int flag, int bf)
diff --git a/functions.h b/functions.h
index 7a1c5a9..39dc50b 100644
--- a/functions.h
+++ b/functions.h
@@ -169,6 +169,11 @@ const struct binding_t OpMain[] = { /* map: index */
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
 
 
+ { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+ { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+ { "sidebar-next",		OP_SIDEBAR_NEXT, NULL },
+ { "sidebar-prev",		OP_SIDEBAR_PREV, NULL },
+ { "sidebar-open",		OP_SIDEBAR_OPEN, NULL },
   { NULL,			0,				NULL }
 };
 
@@ -272,6 +277,11 @@ const struct binding_t OpPager[] = { /* map: pager */
 
   { "what-key",		OP_WHAT_KEY,		NULL },
 
+  { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+  { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+  { "sidebar-next",	OP_SIDEBAR_NEXT, NULL },
+  { "sidebar-prev",	OP_SIDEBAR_PREV, NULL },
+  { "sidebar-open", OP_SIDEBAR_OPEN, NULL },
   { NULL,		0,				NULL }
 };
 
diff --git a/globals.h b/globals.h
index 241758d..92de9db 100644
--- a/globals.h
+++ b/globals.h
@@ -118,6 +118,9 @@ WHERE short SearchContext;
 WHERE char *SendCharset;
 WHERE char *Sendmail;
 WHERE char *Shell;
+WHERE char *SidebarDelim;
+WHERE char *SidebarFormat;
+WHERE char *SidebarIndentStr;
 WHERE char *Signature;
 WHERE char *SimpleSearch;
 #if USE_SMTP
@@ -215,6 +218,9 @@ WHERE short ScoreThresholdDelete;
 WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
+WHERE struct buffy_t *CurBuffy INITVAL(0);
+WHERE short DrawFullLine INITVAL(0);
+WHERE short SidebarWidth;
 #ifdef USE_IMAP
 WHERE short ImapKeepalive;
 WHERE short ImapPipelineDepth;
diff --git a/handler.c b/handler.c
index 670b27b..07fa561 100644
--- a/handler.c
+++ b/handler.c
@@ -1602,6 +1602,11 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
   int decode = 0;
   int rc = 0;
 
+#ifdef HAVE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
+
   fseeko (s->fpin, b->offset, 0);
 
   /* see if we need to decode this part before processing it */
@@ -1619,6 +1624,14 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
     {
       /* decode to a tempfile, saving the original destination */
       fp = s->fpout;
+#ifdef HAVE_FMEMOPEN
+	if ((s->fpout = open_memstream(&temp, &tempsize)) == NULL)
+	{
+	  mutt_error _("Unable to open memory stream!");
+	  dprint (1, (debugfile, "Can't open memory stream.\n"));
+	  return -1;
+	}
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s->fpout = safe_fopen (tempfile, "w")) == NULL)
       {
@@ -1626,6 +1639,7 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
         dprint (1, (debugfile, "Can't open %s.\n", tempfile));
         return -1;
       }
+#endif
       /* decoding the attachment changes the size and offset, so save a copy
         * of the "real" values now, and restore them after processing
         */
@@ -1654,8 +1668,19 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
       /* restore final destination and substitute the tempfile for input */
       s->fpout = fp;
       fp = s->fpin;
+#ifdef HAVE_FMEMOPEN
+	if(tempsize)
+		s->fpin = fmemopen(temp, tempsize, "r");
+	else /* fmemopen cannot handle zero-length buffers */
+		s->fpin = safe_fopen ("/dev/null", "r");
+	if(s->fpin == NULL) {
+		mutt_perror("failed to re-open memstream!");
+		return (-1);
+	}
+#else
       s->fpin = fopen (tempfile, "r");
       unlink (tempfile);
+#endif
 
       /* restore the prefix */
       s->prefix = savePrefix;
@@ -1681,6 +1706,10 @@ static int run_decode_and_handler (BODY *b, STATE *s, handler_t handler, int pla
 
       /* restore the original source stream */
       safe_fclose (&s->fpin);
+#ifdef HAVE_FMEMOPEN
+	if(tempsize)
+	    FREE(&temp);
+#endif
       s->fpin = fp;
     }
   }
@@ -1720,6 +1749,11 @@ int mutt_body_handler (BODY *b, STATE *s)
   handler_t handler = NULL;
   int rc = 0;
 
+#ifdef HAVE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
+
   int oflags = s->flags;
   
   /* first determine which handler to use to process this part */
diff --git a/imap/command.c b/imap/command.c
index d99a99a..5068fca 100644
--- a/imap/command.c
+++ b/imap/command.c
@@ -1016,6 +1016,13 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s)
 	     opened */
 	  status->uidnext = oldun;
 
+        /* Added to make the sidebar show the correct numbers */
+        if (status->messages)
+        {
+          inc->msgcount = status->messages;
+          inc->msg_unread = status->unseen;
+        }
+
         FREE (&value);
         return;
       }
diff --git a/imap/imap.c b/imap/imap.c
index 1b63b3a..c11b993 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -1535,7 +1535,7 @@ int imap_buffy_check (int force)
 
     imap_munge_mbox_name (idata, munged, sizeof (munged), name);
     snprintf (command, sizeof (command),
-	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)", munged);
+	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)", munged);
 
     if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
     {
diff --git a/init.h b/init.h
index 728bfb7..48c02fe 100644
--- a/init.h
+++ b/init.h
@@ -2050,6 +2050,54 @@ struct option_t MuttVars[] = {
   ** not used.
   ** (PGP only)
   */
+  {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, UL "|"},
+  /*
+  ** .pp
+  ** This specifies the delimiter between the sidebar (if visible) and
+  ** other screens.
+  */
+  {"sidebar_indentstr", DT_STR, R_BOTH, UL &SidebarIndentStr, UL " "},
+  /*
+  ** .pp
+  ** This specifies the string that is used to indent items
+  ** with sidebar_folderindent= yes
+  */
+  { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show sidebar (left-side list of folders).
+  */
+  { "sidebar_sort", DT_BOOL, R_BOTH, OPTSIDEBARSORT, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to sort the sidebar alphabetically.
+  */
+  { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** The width of the sidebar.
+  */
+  { "sidebar_shortpath", DT_BOOL, R_BOTH, OPTSIDEBARSHORTPATH, 0 },
+  /*
+  ** .pp
+  ** Should the sidebar shorten the path showed.
+  */
+  {"sidebar_format", DT_STR, R_NONE, UL &SidebarFormat, UL "%B%?F? [%F]?%* %?N?%N/?%4S"},
+  /*
+  ** .pp
+  ** Format string for the sidebar. The sequences `%N', `%F' and `%S'
+  ** will be replaced by the number of new or flagged messages or the total
+  ** size of them mailbox. `%B' will be replaced with the name of the mailbox.
+  ** The `%!' sequence will be expanded to `!' if there is one flagged message;
+  ** to `!!' if there are two flagged messages; and to `n!' for n flagged
+  ** messages, n>2.
+  */
+  { "sidebar_folderindent", DT_BOOL, R_BOTH, OPTSIDEBARFOLDERINDENT, 0 },
+  /*
+  ** .pp
+  ** Should folders be indented in the sidebar.
+  */
+
   { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
   /*
   ** .pp
diff --git a/mailbox.h b/mailbox.h
index 2b2c9a1..000503d 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -27,6 +27,7 @@
 #define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
 				* safe_fopen() for mbox-style folders.
 				*/
+#define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
 
 /* mx_open_new_message() */
 #define M_ADD_FROM	(1<<0)	/* add a From_ line */
diff --git a/main.c b/main.c
index 82fd46d..5434610 100644
--- a/main.c
+++ b/main.c
@@ -50,6 +50,7 @@
 #include <unistd.h>
 #include <errno.h>
 #include <sys/stat.h>
+#include <limits.h>
 #include <sys/utsname.h>
 
 #ifdef HAVE_GETOPT_H
@@ -558,7 +559,7 @@ init_extended_keys();
 
 int main (int argc, char **argv)
 {
-  char folder[_POSIX_PATH_MAX] = "";
+  char folder[PATH_MAX] = "";
   char *subject = NULL;
   char *includeFile = NULL;
   char *draftFile = NULL;
@@ -1189,6 +1190,13 @@ int main (int argc, char **argv)
       strfcpy (folder, NONULL(Spoolfile), sizeof (folder));
     mutt_expand_path (folder, sizeof (folder));
 
+    {
+      char tmpfolder[PATH_MAX];
+      strfcpy (tmpfolder, folder, sizeof (tmpfolder));
+      if(!realpath(tmpfolder, folder))
+          strfcpy (folder, tmpfolder, sizeof (tmpfolder));
+    }
+
     mutt_str_replace (&CurrentFolder, folder);
     mutt_str_replace (&LastFolder, folder);
 
@@ -1211,6 +1219,7 @@ int main (int argc, char **argv)
     if((Context = mx_open_mailbox (folder, ((flags & M_RO) || option (OPTREADONLY)) ? M_READONLY : 0, NULL))
        || !explicit_folder)
     {
+      set_curbuffy(folder);
       mutt_index_menu ();
       if (Context)
 	FREE (&Context);
diff --git a/mbox.c b/mbox.c
index 95cba65..3e85518 100644
--- a/mbox.c
+++ b/mbox.c
@@ -100,6 +100,7 @@ int mmdf_parse_mailbox (CONTEXT *ctx)
     mutt_perror (ctx->path);
     return (-1);
   }
+  ctx->atime = sb.st_atime;
   ctx->mtime = sb.st_mtime;
   ctx->size = sb.st_size;
 
@@ -251,6 +252,7 @@ int mbox_parse_mailbox (CONTEXT *ctx)
 
   ctx->size = sb.st_size;
   ctx->mtime = sb.st_mtime;
+  ctx->atime = sb.st_atime;
 
 #ifdef NFS_ATTRIBUTE_HACK
   if (sb.st_mtime > sb.st_atime)
diff --git a/menu.c b/menu.c
index a715fb9..efe7eec 100644
--- a/menu.c
+++ b/menu.c
@@ -24,6 +24,7 @@
 #include "mutt_curses.h"
 #include "mutt_menu.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 char* SearchBuffers[MENU_MAX];
 
@@ -184,7 +185,7 @@ static void menu_pad_string (MUTTMENU *menu, char *s, size_t n)
 {
   char *scratch = safe_strdup (s);
   int shift = option (OPTARROWCURSOR) ? 3 : 0;
-  int cols = menu->indexwin->cols - shift;
+  int cols = menu->indexwin->cols - shift - SidebarWidth;
 
   mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
   s[n - 1] = 0;
@@ -235,6 +236,7 @@ void menu_redraw_index (MUTTMENU *menu)
   int do_color;
   int attr;
 
+  draw_sidebar(1);
   for (i = menu->top; i < menu->top + menu->pagelen; i++)
   {
     if (i < menu->max)
@@ -245,7 +247,7 @@ void menu_redraw_index (MUTTMENU *menu)
       menu_pad_string (menu, buf, sizeof (buf));
 
       ATTRSET(attr);
-      mutt_window_move (menu->indexwin, i - menu->top + menu->offset, 0);
+      mutt_window_move (menu->indexwin, i - menu->top + menu->offset, SidebarWidth);
       do_color = 1;
 
       if (i == menu->current)
@@ -268,7 +270,7 @@ void menu_redraw_index (MUTTMENU *menu)
     else
     {
       NORMAL_COLOR;
-      mutt_window_clearline (menu->indexwin, i - menu->top + menu->offset);
+      CLEARLINE_WIN (menu->indexwin, i - menu->top + menu->offset);
     }
   }
   NORMAL_COLOR;
@@ -285,7 +287,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     return;
   }
   
-  mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, 0);
+  mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   ATTRSET(menu->color (menu->oldcurrent));
 
   if (option (OPTARROWCURSOR))
@@ -297,13 +299,13 @@ void menu_redraw_motion (MUTTMENU *menu)
     {
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (menu, buf, sizeof (buf));
-      mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, 3);
+      mutt_window_move (menu->indexwin, menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
       print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
     SETCOLOR(MT_COLOR_INDICATOR);
-    mutt_window_mvaddstr (menu->indexwin, menu->current + menu->offset - menu->top, 0, "->");
+    mutt_window_mvaddstr (menu->indexwin, menu->current + menu->offset - menu->top, SidebarWidth, "->");
   }
   else
   {
@@ -316,7 +318,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (menu, buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
-    mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, 0);
+    mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, SidebarWidth);
     print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
@@ -328,7 +330,7 @@ void menu_redraw_current (MUTTMENU *menu)
   char buf[LONG_STRING];
   int attr = menu->color (menu->current);
 
-  mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, 0);
+  mutt_window_move (menu->indexwin, menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (menu, buf, sizeof (buf));
 
@@ -875,7 +877,7 @@ int mutt_menuLoop (MUTTMENU *menu)
     
     
     if (option (OPTARROWCURSOR))
-      mutt_window_move (menu->indexwin, menu->current - menu->top + menu->offset, 2);
+      mutt_window_move (menu->indexwin, menu->current - menu->top + menu->offset, SidebarWidth + 2);
     else if (option (OPTBRAILLEFRIENDLY))
       mutt_window_move (menu->indexwin, menu->current - menu->top + menu->offset, 0);
     else
diff --git a/mh.c b/mh.c
index bc87660..3121fca 100644
--- a/mh.c
+++ b/mh.c
@@ -295,6 +295,32 @@ void mh_buffy(BUFFY *b)
   mhs_free_sequences (&mhs);
 }
 
+void mh_buffy_update (const char *path, int *msgcount, int *msg_unread, int *msg_flagged, time_t *sb_last_checked)
+{
+  int i;
+  struct mh_sequences mhs;
+  memset (&mhs, 0, sizeof (mhs));
+
+  if(!option(OPTSIDEBAR))
+      return;
+
+  if (mh_read_sequences (&mhs, path) < 0)
+    return;
+
+  msgcount = 0;
+  msg_unread = 0;
+  msg_flagged = 0;
+  for (i = 0; i <= mhs.max; i++)
+    msgcount++;
+    if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN) {
+      msg_unread++;
+    }
+    if (mhs_check (&mhs, i) & MH_SEQ_FLAGGED)
+      msg_flagged++;
+  mhs_free_sequences (&mhs);
+  *sb_last_checked = time(NULL);
+}
+
 static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
 {
   int fd;
diff --git a/mutt.h b/mutt.h
index 4505ba2..cf742b2 100644
--- a/mutt.h
+++ b/mutt.h
@@ -429,6 +429,10 @@ enum
   OPTSAVEEMPTY,
   OPTSAVENAME,
   OPTSCORE,
+  OPTSIDEBAR,
+  OPTSIDEBARSHORTPATH,
+  OPTSIDEBARSORT,
+  OPTSIDEBARFOLDERINDENT,
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
@@ -874,6 +878,7 @@ typedef struct _context
 {
   char *path;
   FILE *fp;
+  time_t atime;
   time_t mtime;
   off_t size;
   off_t vsize;
@@ -909,6 +914,7 @@ typedef struct _context
   unsigned int quiet : 1;	/* inhibit status messages? */
   unsigned int collapsed : 1;   /* are all threads collapsed? */
   unsigned int closing : 1;	/* mailbox is being closed */
+  unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
   /* driver hooks */
   void *data;			/* driver specific data */
diff --git a/mutt_curses.h b/mutt_curses.h
index d3efd70..b1d61b2 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -66,6 +66,7 @@
 
 #define CLEARLINE(win,x) mutt_window_clearline(win, x)
 #define CENTERLINE(win,x,y) mutt_window_move(win, y, (win->cols-strlen(x))/2), addstr(x)
+#define CLEARLINE_WIN(win, x) mutt_window_move(win, x,SidebarWidth), mutt_window_clrtoeol(win)
 #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
 
 #if ! (defined(USE_SLANG_CURSES) || defined(HAVE_CURS_SET))
@@ -122,6 +123,8 @@ enum
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
   MT_COLOR_INDEX,
+  MT_COLOR_NEW,
+  MT_COLOR_FLAGGED,
   MT_COLOR_PROMPT,
   MT_COLOR_MAX
 };
diff --git a/mutt_menu.h b/mutt_menu.h
index 6f4ed74..f4c9b9b 100644
--- a/mutt_menu.h
+++ b/mutt_menu.h
@@ -35,6 +35,7 @@
 #define REDRAW_FULL		(1<<5)
 #define REDRAW_BODY		(1<<6)
 #define REDRAW_SIGWINCH		(1<<7)
+#define REDRAW_SIDEBAR		(1<<8)
 
 #define M_MODEFMT "-- Mutt: %s"
 
diff --git a/muttlib.c b/muttlib.c
index bad91d3..d806730 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -1283,6 +1283,8 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  pl = pw = 1;
 
 	/* see if there's room to add content, else ignore */
+        if ( DrawFullLine )
+        {
 	if ((col < cols && wlen < destlen) || soft)
 	{
 	  int pad;
@@ -1347,6 +1349,52 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  col += wid;
 	  src += pl;
 	}
+        }
+        else
+        {
+	if ((col < COLS-SidebarWidth && wlen < destlen) || soft)
+        {
+	  int pad;
+
+	  /* get contents after padding */
+	  mutt_FormatString (buf, sizeof (buf), 0, cols,  src + pl, callback, data, flags);
+	  len = mutt_strlen (buf);
+	  wid = mutt_strwidth (buf);
+
+	  /* try to consume as many columns as we can, if we don't have
+	   * memory for that, use as much memory as possible */
+	  pad = (COLS - SidebarWidth - col - wid) / pw;
+	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+	    pad = ((signed)(destlen - wlen - len)) / pl;
+	  if (pad > 0)
+	  {
+	    while (pad--)
+	    {
+	      memcpy (wptr, src, pl);
+	      wptr += pl;
+	      wlen += pl;
+	      col += pw;
+	    }
+	  }
+	  else if (soft && pad < 0)
+	  {
+	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+	    *wptr = 0;
+	    /* make sure right part is at most as wide as display */
+	    len = mutt_wstr_trunc (buf, destlen, COLS, &wid);
+	    /* truncate left so that right part fits completely in */
+	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad, &col);
+	    wptr = dest + wlen;
+	  }
+	  if (len + wlen > destlen)
+	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - SidebarWidth - col, NULL);
+	  memcpy (wptr, buf, len);
+	  wptr += len;
+	  wlen += len;
+	  col += wid;
+	  src += pl;
+	}
+        }
 	break; /* skip rest of input */
       }
       else if (ch == '|')
diff --git a/mx.c b/mx.c
index 3af4ded..1b93c21 100644
--- a/mx.c
+++ b/mx.c
@@ -580,6 +580,7 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
  *		M_APPEND	open mailbox for appending
  *		M_READONLY	open mailbox in read-only mode
  *		M_QUIET		only print error messages
+ *		M_PEEK		revert atime where applicable
  *	ctx	if non-null, context struct to use
  */
 CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
@@ -602,6 +603,8 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
     ctx->quiet = 1;
   if (flags & M_READONLY)
     ctx->readonly = 1;
+  if (flags & M_PEEK)
+    ctx->peekonly = 1;
 
   if (flags & (M_APPEND|M_NEWFOLDER))
   {
@@ -701,13 +704,26 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
 void mx_fastclose_mailbox (CONTEXT *ctx)
 {
   int i;
+#ifndef BUFFY_SIZE
+  struct utimbuf ut;
+#endif
 
   if(!ctx) 
     return;
+#ifndef BUFFY_SIZE
+  /* fix up the times so buffy won't get confused */
+  if (ctx->peekonly && ctx->path && ctx->mtime > ctx->atime)
+  {
+    ut.actime = ctx->atime;
+    ut.modtime = ctx->mtime;
+    utime (ctx->path, &ut);
+  }
+#endif
 
   /* never announce that a mailbox we've just left has new mail. #3290
    * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
-  mutt_buffy_setnotified(ctx->path);
+  if(!ctx->peekonly)
+    mutt_buffy_setnotified(ctx->path);
 
   if (ctx->mx_close)
     ctx->mx_close (ctx);
@@ -719,6 +735,8 @@ void mx_fastclose_mailbox (CONTEXT *ctx)
   mutt_clear_threads (ctx);
   for (i = 0; i < ctx->msgcount; i++)
     mutt_free_header (&ctx->hdrs[i]);
+  ctx->msgcount -= ctx->deleted;
+  set_buffystats(ctx);
   FREE (&ctx->hdrs);
   FREE (&ctx->v2r);
   FREE (&ctx->path);
@@ -859,6 +877,10 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
         && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED)))
       read_msgs++;
+    if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->read)
+      ctx->unread--;
+    if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->flagged)
+      ctx->flagged--;
   }
 
   if (read_msgs && quadoption (OPT_MOVE) != M_NO)
diff --git a/mx.h b/mx.h
index dd77ba4..9cf1193 100644
--- a/mx.h
+++ b/mx.h
@@ -57,6 +57,7 @@ void mbox_reset_atime (CONTEXT *, struct stat *);
 int mh_read_dir (CONTEXT *, const char *);
 int mh_sync_mailbox (CONTEXT *, int *);
 int mh_check_mailbox (CONTEXT *, int *);
+void mh_buffy_update (const char *, int *, int *, int *, time_t *);
 int mh_check_empty (const char *);
 
 int maildir_read_dir (CONTEXT *);
diff --git a/pager.c b/pager.c
index d47842a..234fc20 100644
--- a/pager.c
+++ b/pager.c
@@ -29,6 +29,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include "mutt_crypt.h"
 
@@ -1102,6 +1103,7 @@ static int format_line (struct line_t **lineInfo, int n, unsigned char *buf,
   wchar_t wc;
   mbstate_t mbstate;
   int wrap_cols = mutt_window_wrap_cols (pager_window, (flags & M_PAGER_NOWRAP) ? 0 : Wrap);
+  wrap_cols -= SidebarWidth;
 
   if (check_attachment_marker ((char *)buf) == 0)
     wrap_cols = pager_window->cols;
@@ -1585,6 +1587,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
   mutt_window_t *index_window = NULL;
   mutt_window_t *pager_status_window = NULL;
   mutt_window_t *pager_window = NULL;
+  int statuswidth;
 
   MUTTMENU *index = NULL;		/* the Pager Index (PI) */
   int indexlen = PagerIndexLines;	/* indexlen not always == PIL */
@@ -1773,7 +1776,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-        mutt_window_move (pager_window, 0, 0);
+        mutt_window_move (pager_window, 0, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1787,7 +1790,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
                             pager_window) > 0)
 	    lines++;
 	  curline++;
-          mutt_window_move (pager_window, lines, 0);
+          mutt_window_move (pager_window, lines, SidebarWidth);
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1799,7 +1802,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	if (option (OPTTILDE))
 	  addch ('~');
 	lines++;
-        mutt_window_move (pager_window, lines, 0);
+        mutt_window_move (pager_window, lines, SidebarWidth);
       }
       NORMAL_COLOR;
 
@@ -1817,29 +1820,39 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       hfi.ctx = Context;
       hfi.pager_progress = pager_progress_str;
 
+      statuswidth = COLS - (option(OPTSTATUSONTOP) && PagerIndexLines > 0 ? SidebarWidth : 0);
+
       if (last_pos < sb.st_size - 1)
 	snprintf(pager_progress_str, sizeof(pager_progress_str), OFF_T_FMT "%%", (100 * last_offset / sb.st_size));
       else
 	strfcpy(pager_progress_str, (topline == 0) ? "all" : "end", sizeof(pager_progress_str));
 
       /* print out the pager status bar */
-      mutt_window_move (pager_status_window, 0, 0);
+      mutt_window_move (pager_status_window, 0, SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
+      if(option(OPTSTATUSONTOP) && PagerIndexLines > 0) {
+          CLEARLINE_WIN (pager_status_window, 0);
+      } else {
+          CLEARLINE (pager_status_window, 0);
+          DrawFullLine = 1; /* for mutt_make_string_info */
+      }
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = pager_status_window->cols * MB_LEN_MAX;
+	size_t l1 = statuswidth * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (pager_status_window->cols, buffer);
+	mutt_paddstr (statuswidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (pager_status_window->cols, bn);
+	mutt_paddstr (statuswidth, bn);
       }
+      if(!option(OPTSTATUSONTOP) || PagerIndexLines == 0)
+          DrawFullLine = 0; /* reset */
       NORMAL_COLOR;
       if (option(OPTTSENABLED) && TSSupported)
       {
@@ -1856,16 +1869,21 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
        * flags for this message might have changed. */
       if (index_window->rows > 0)
         menu_redraw_current (index);
+      draw_sidebar(MENU_PAGER);
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      mutt_window_move (index_status_window, 0, 0);
+      mutt_window_move (index_status_window, 0, (option(OPTSTATUSONTOP) ? 0 : SidebarWidth));
       SETCOLOR (MT_COLOR_STATUS);
-      mutt_paddstr (index_status_window->cols, buffer);
+      mutt_paddstr (index_status_window->cols - (option(OPTSTATUSONTOP) ? 0 : SidebarWidth), buffer);
       NORMAL_COLOR;
     }
 
+    /* if we're not using the index, update every time */
+    if ( index == 0 )
+      draw_sidebar(MENU_PAGER);
+
     redraw = 0;
 
     if (option(OPTBRAILLEFRIENDLY)) {
@@ -2807,6 +2825,13 @@ search_next:
 	mutt_what_key ();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+	scroll_sidebar(ch, MENU_PAGER);
+	break;
+
       default:
 	ch = -1;
 	break;
diff --git a/pattern.c b/pattern.c
index d954cdc..eb13a21 100644
--- a/pattern.c
+++ b/pattern.c
@@ -154,6 +154,10 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
   HEADER *h = ctx->hdrs[msgno];
   char *buf;
   size_t blen;
+#ifdef HAVE_FMEMOPEN
+  char *temp;
+  size_t tempsize;
+#endif
 
   if ((msg = mx_open_message (ctx, msgno)) != NULL)
   {
@@ -163,12 +167,20 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
       memset (&s, 0, sizeof (s));
       s.fpin = msg->fp;
       s.flags = M_CHARCONV;
+#ifdef HAVE_FMEMOPEN
+      if((s.fpout = open_memstream(&temp, &tempsize)) == NULL)
+      {
+	mutt_perror ("Error opening memstream");
+	return (0);
+      }
+#else
       mutt_mktemp (tempfile, sizeof (tempfile));
       if ((s.fpout = safe_fopen (tempfile, "w+")) == NULL)
       {
 	mutt_perror (tempfile);
 	return (0);
       }
+#endif
 
       if (pat->op != M_BODY)
 	mutt_copy_header (msg->fp, h, s.fpout, CH_FROM | CH_DECODE, NULL);
@@ -184,7 +196,11 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	  if (s.fpout)
 	  {
 	    safe_fclose (&s.fpout);
+#ifdef HAVE_FMEMOPEN
+            FREE(&temp);
+#else
 	    unlink (tempfile);
+#endif
 	  }
 	  return (0);
 	}
@@ -193,11 +209,28 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
 	mutt_body_handler (h->content, &s);
       }
 
+#ifdef HAVE_FMEMOPEN
+      fclose(s.fpout);
+      lng = tempsize;
+
+      if(tempsize) {
+          if ((fp = fmemopen(temp, tempsize, "r")) == NULL) {
+            mutt_perror ("Error re-opening memstream");
+            return (0);
+          }
+      } else { /* fmemopen cannot handle empty buffers */
+          if ((fp = safe_fopen ("/dev/null", "r")) == NULL) {
+            mutt_perror ("Error opening /dev/null");
+            return (0);
+          }
+      }
+#else
       fp = s.fpout;
       fflush (fp);
       fseek (fp, 0, 0);
       fstat (fileno (fp), &st);
       lng = (long) st.st_size;
+#endif
     }
     else
     {
@@ -244,7 +277,12 @@ msg_search (CONTEXT *ctx, pattern_t* pat, int msgno)
     if (option (OPTTHOROUGHSRC))
     {
       safe_fclose (&fp);
+#ifdef HAVE_FMEMOPEN
+      if(tempsize)
+          FREE (&temp);
+#else
       unlink (tempfile);
+#endif
     }
   }
 
diff --git a/protos.h b/protos.h
index 0eebe95..b32de91 100644
--- a/protos.h
+++ b/protos.h
@@ -36,6 +36,13 @@ struct hdr_format_info
   const char *pager_progress;
 };
 
+struct sidebar_entry {
+    char                box[SHORT_STRING];
+    unsigned int        size;
+    unsigned int        new;
+    unsigned int        flagged;
+};
+
 void mutt_make_string_info (char *, size_t, const char *, struct hdr_format_info *, format_flag);
 
 int mutt_extract_token (BUFFER *, BUFFER *, int);
diff --git a/sidebar.c b/sidebar.c
new file mode 100644
index 0000000..7c262ab
--- /dev/null
+++ b/sidebar.c
@@ -0,0 +1,405 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */
+
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "mutt_menu.h"
+#include "mutt_curses.h"
+#include "sidebar.h"
+#include "buffy.h"
+#include <libgen.h>
+#include "keymap.h"
+#include <stdbool.h>
+
+/*BUFFY *CurBuffy = 0;*/
+static BUFFY *TopBuffy = 0;
+static BUFFY *BottomBuffy = 0;
+static int known_lines = 0;
+
+void calc_boundaries() {
+
+    BUFFY *tmp = Incoming;
+
+	int count = LINES - 2 - (option(OPTHELP) ? 1 : 0);
+
+	if ( known_lines != LINES ) {
+		TopBuffy = BottomBuffy = 0;
+		known_lines = LINES;
+	}
+	for ( ; tmp->next != 0; tmp = tmp->next )
+		tmp->next->prev = tmp;
+
+	if ( TopBuffy == 0 && BottomBuffy == 0 )
+		TopBuffy = Incoming;
+	if ( BottomBuffy == 0 ) {
+		BottomBuffy = TopBuffy;
+		while ( --count && BottomBuffy->next )
+			BottomBuffy = BottomBuffy->next;
+	}
+	else if ( TopBuffy == CurBuffy->next ) {
+		BottomBuffy = CurBuffy;
+		tmp = BottomBuffy;
+		while ( --count && tmp->prev)
+			tmp = tmp->prev;
+		TopBuffy = tmp;
+	}
+	else if ( BottomBuffy == CurBuffy->prev ) {
+		TopBuffy = CurBuffy;
+		tmp = TopBuffy;
+		while ( --count && tmp->next )
+			tmp = tmp->next;
+		BottomBuffy = tmp;
+	}
+}
+
+static const char *
+sidebar_format_str (char *dest,
+			size_t destlen,
+			size_t col,
+			int cols,
+			char op,
+			const char *src,
+			const char *prefix,
+			const char *ifstring,
+			const char *elsestring,
+			unsigned long data,
+			format_flag flags)
+{
+/* casting from unsigned long - srsly?! */
+struct sidebar_entry *sbe = (struct sidebar_entry *) data;
+unsigned int optional;
+char fmt[SHORT_STRING], buf[SHORT_STRING];
+
+optional = flags & M_FORMAT_OPTIONAL;
+
+switch(op) {
+	case 'F':
+		if(!optional) {
+			snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+			snprintf (dest, destlen, fmt, sbe->flagged);
+		} else if(sbe->flagged == 0) {
+			optional = 0;
+		}
+		break;
+
+	case '!':
+		if(sbe->flagged == 0)
+			mutt_format_s(dest, destlen, prefix, "");
+		if(sbe->flagged == 1)
+			mutt_format_s(dest, destlen, prefix, "!");
+		if(sbe->flagged == 2)
+			mutt_format_s(dest, destlen, prefix, "!!");
+		if(sbe->flagged > 2) {
+			snprintf (buf, sizeof (buf), "%d!", sbe->flagged);
+			mutt_format_s(dest, destlen, prefix, buf);
+		}
+		break;
+
+	case 'S':
+		snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+		snprintf (dest, destlen, fmt, sbe->size);
+		break;
+
+	case 'N':
+		if(!optional) {
+			snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+			snprintf (dest, destlen, fmt, sbe->new);
+		} else if(sbe->new == 0) {
+			optional = 0;
+		}
+		break;
+
+	case 'B':
+		mutt_format_s(dest, destlen, prefix, sbe->box);
+		break;
+	}
+
+	if(optional)
+		mutt_FormatString (dest, destlen, col, cols, ifstring, sidebar_format_str, (unsigned long) sbe, flags);
+	else if (flags & M_FORMAT_OPTIONAL)
+		mutt_FormatString (dest, destlen, col, cols, elsestring, sidebar_format_str, (unsigned long) sbe, flags);
+
+	return (src);
+}
+
+char *make_sidebar_entry(char *box, unsigned int size, unsigned int new, unsigned int flagged) {
+    static char *entry = 0;
+    struct sidebar_entry sbe;
+    int SBvisual;
+
+    SBvisual = SidebarWidth - strlen(SidebarDelim);
+    if (SBvisual < 1)
+        return NULL;
+
+    sbe.new = new;
+    sbe.flagged = flagged;
+    sbe.size = size;
+    strncpy(sbe.box, box, 31);
+
+    safe_realloc(&entry, SBvisual + 2);
+    entry[SBvisual + 1] = '\0';
+
+    mutt_FormatString (entry, SBvisual+1, 0, SidebarWidth,  SidebarFormat, sidebar_format_str, (unsigned long) &sbe, 0);
+
+    return entry;
+}
+
+void set_curbuffy(char buf[LONG_STRING])
+{
+  BUFFY* tmp = CurBuffy = Incoming;
+
+  if (!Incoming)
+    return;
+
+  while(1) {
+    if(!strcmp(tmp->path, buf) || !strcmp(tmp->realpath, buf)) {
+      CurBuffy = tmp;
+      break;
+    }
+
+    if(tmp->next)
+      tmp = tmp->next;
+    else
+      break;
+  }
+}
+
+int draw_sidebar(int menu) {
+
+	BUFFY *tmp;
+#ifndef USE_SLANG_CURSES
+        attr_t attrs;
+#endif
+        short delim_len = strlen(SidebarDelim);
+        short color_pair;
+
+        static bool initialized = false;
+        static int prev_show_value;
+        static short saveSidebarWidth;
+        int lines = 0;
+        int SidebarHeight;
+
+        if(option(OPTSTATUSONTOP) || option(OPTHELP))
+                lines++; /* either one will occupy the first line */
+
+        /* initialize first time */
+        if(!initialized) {
+                prev_show_value = option(OPTSIDEBAR);
+                saveSidebarWidth = SidebarWidth;
+                if(!option(OPTSIDEBAR)) SidebarWidth = 0;
+                initialized = true;
+        }
+
+        /* save or restore the value SidebarWidth */
+        if(prev_show_value != option(OPTSIDEBAR)) {
+                if(prev_show_value && !option(OPTSIDEBAR)) {
+                        saveSidebarWidth = SidebarWidth;
+                        SidebarWidth = 0;
+                } else if(!prev_show_value && option(OPTSIDEBAR)) {
+                        mutt_buffy_check(1); /* we probably have bad or no numbers */
+                        SidebarWidth = saveSidebarWidth;
+                }
+                prev_show_value = option(OPTSIDEBAR);
+        }
+
+
+/*	if ( SidebarWidth == 0 ) return 0; */
+       if (SidebarWidth > 0 && option (OPTSIDEBAR)
+           && delim_len >= SidebarWidth) {
+         unset_option (OPTSIDEBAR);
+         /* saveSidebarWidth = SidebarWidth; */
+         if (saveSidebarWidth > delim_len) {
+           SidebarWidth = saveSidebarWidth;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar."));
+           sleep (2);
+         } else {
+           SidebarWidth = 0;
+           mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar. Please set your sidebar_width to a sane value."));
+           sleep (4); /* the advise to set a sane value should be seen long enough */
+         }
+         saveSidebarWidth = 0;
+         return (0);
+       }
+
+    if ( SidebarWidth == 0 || !option(OPTSIDEBAR)) {
+      if (SidebarWidth > 0) {
+        saveSidebarWidth = SidebarWidth;
+        SidebarWidth = 0;
+      }
+      unset_option(OPTSIDEBAR);
+      return 0;
+    }
+
+        /* get attributes for divider */
+	SETCOLOR(MT_COLOR_STATUS);
+#ifndef USE_SLANG_CURSES
+        attr_get(&attrs, &color_pair, 0);
+#else
+        color_pair = attr_get();
+#endif
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	/* draw the divider */
+
+	SidebarHeight =  LINES - 1;
+	if(option(OPTHELP) || !option(OPTSTATUSONTOP))
+		SidebarHeight--;
+
+	for ( ; lines < SidebarHeight; lines++ ) {
+		move(lines, SidebarWidth - delim_len);
+		addstr(NONULL(SidebarDelim));
+#ifndef USE_SLANG_CURSES
+                mvchgat(lines, SidebarWidth - delim_len, delim_len, 0, color_pair, NULL);
+#endif
+	}
+
+	if ( Incoming == 0 ) return 0;
+        lines = 0;
+        if(option(OPTSTATUSONTOP) || option(OPTHELP))
+                lines++; /* either one will occupy the first line */
+
+	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 )
+		calc_boundaries();
+	if ( CurBuffy == 0 ) CurBuffy = Incoming;
+
+	tmp = TopBuffy;
+
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	for ( ; tmp && lines < SidebarHeight; tmp = tmp->next ) {
+		if ( tmp == CurBuffy )
+			SETCOLOR(MT_COLOR_INDICATOR);
+		else if ( tmp->msg_unread > 0 )
+			SETCOLOR(MT_COLOR_NEW);
+		else if ( tmp->msg_flagged > 0 )
+		        SETCOLOR(MT_COLOR_FLAGGED);
+		else
+			SETCOLOR(MT_COLOR_NORMAL);
+
+		move( lines, 0 );
+		if ( Context && (!strcmp(tmp->path, Context->path)||
+				 !strcmp(tmp->realpath, Context->path)) ) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+			tmp->msg_flagged = Context->flagged;
+		}
+		/* check whether Maildir is a prefix of the current folder's path */
+		short maildir_is_prefix = 0;
+		if ( (strlen(tmp->path) > strlen(Maildir)) &&
+			(strncmp(Maildir, tmp->path, strlen(Maildir)) == 0) )
+			maildir_is_prefix = 1;
+		/* calculate depth of current folder and generate its display name with indented spaces */
+		int sidebar_folder_depth = 0;
+		char *sidebar_folder_name;
+		sidebar_folder_name = option(OPTSIDEBARSHORTPATH) ? (char *) mutt_basename(tmp->path) : tmp->path + maildir_is_prefix*(strlen(Maildir) + 1);
+		if ( maildir_is_prefix && option(OPTSIDEBARFOLDERINDENT) ) {
+			char *tmp_folder_name;
+			int i;
+			tmp_folder_name = tmp->path + strlen(Maildir) + 1;
+			for (i = 0; i < strlen(tmp->path) - strlen(Maildir); i++) {
+				if (tmp_folder_name[i] == '/'  || tmp_folder_name[i] == '.') sidebar_folder_depth++;
+			}
+			if (sidebar_folder_depth > 0) {
+				if (option(OPTSIDEBARSHORTPATH)) {
+					tmp_folder_name = strrchr(tmp->path, '.');
+					if (tmp_folder_name == NULL)
+						tmp_folder_name = (char *) mutt_basename(tmp->path);
+					else
+						tmp_folder_name++;
+				}
+				else
+					tmp_folder_name = tmp->path + strlen(Maildir) + 1;
+				sidebar_folder_name = malloc(strlen(tmp_folder_name) + sidebar_folder_depth*strlen(NONULL(SidebarIndentStr)) + 1);
+				sidebar_folder_name[0]=0;
+				for (i=0; i < sidebar_folder_depth; i++)
+					strncat(sidebar_folder_name, NONULL(SidebarIndentStr), strlen(NONULL(SidebarIndentStr)));
+				strncat(sidebar_folder_name, tmp_folder_name, strlen(tmp_folder_name));
+			}
+		}
+		printw( "%.*s", SidebarWidth - delim_len + 1,
+			make_sidebar_entry(sidebar_folder_name, tmp->msgcount,
+			tmp->msg_unread, tmp->msg_flagged));
+		if (sidebar_folder_depth > 0)
+		        free(sidebar_folder_name);
+		lines++;
+	}
+	SETCOLOR(MT_COLOR_NORMAL);
+	for ( ; lines < SidebarHeight; lines++ ) {
+		int i = 0;
+		move( lines, 0 );
+		for ( ; i < SidebarWidth - delim_len; i++ )
+			addch(' ');
+	}
+	return 0;
+}
+
+
+void set_buffystats(CONTEXT* Context)
+{
+        BUFFY *tmp = Incoming;
+        while(tmp) {
+                if(Context && (!strcmp(tmp->path, Context->path) ||
+                               !strcmp(tmp->realpath, Context->path))) {
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+			tmp->msg_flagged = Context->flagged;
+                        break;
+                }
+                tmp = tmp->next;
+        }
+}
+
+void scroll_sidebar(int op, int menu)
+{
+        if(!SidebarWidth) return;
+        if(!CurBuffy) return;
+
+	switch (op) {
+		case OP_SIDEBAR_NEXT:
+			if ( CurBuffy->next == NULL ) return;
+			CurBuffy = CurBuffy->next;
+			break;
+		case OP_SIDEBAR_PREV:
+			if ( CurBuffy->prev == NULL ) return;
+			CurBuffy = CurBuffy->prev;
+			break;
+		case OP_SIDEBAR_SCROLL_UP:
+			CurBuffy = TopBuffy;
+			if ( CurBuffy != Incoming ) {
+				calc_boundaries();
+				CurBuffy = CurBuffy->prev;
+			}
+			break;
+		case OP_SIDEBAR_SCROLL_DOWN:
+			CurBuffy = BottomBuffy;
+			if ( CurBuffy->next ) {
+				calc_boundaries();
+				CurBuffy = CurBuffy->next;
+			}
+			break;
+		default:
+			return;
+	}
+	calc_boundaries();
+	draw_sidebar(menu);
+}
diff --git a/sidebar.h b/sidebar.h
new file mode 100644
index 0000000..c11d46d
--- /dev/null
+++ b/sidebar.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */
+
+#ifndef SIDEBAR_H
+#define SIDEBAR_H
+
+struct MBOX_LIST {
+	char *path;
+	int msgcount;
+	int new;
+} MBLIST;
+
+/* parameter is whether or not to go to the status line */
+/* used for omitting the last | that covers up the status bar in the index */
+int draw_sidebar(int);
+void scroll_sidebar(int, int);
+void set_curbuffy(char*);
+void set_buffystats(CONTEXT*);
+
+#endif /* SIDEBAR_H */
-- 
2.8.2

