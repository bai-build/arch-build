From 0fbcb07da5e540e51a1865cb57d3bdfddbcabeee Mon Sep 17 00:00:00 2001
From: Marian Postevca <posteuca@mutex.one>
Date: Mon, 5 Sep 2022 17:25:07 +0300
Subject: [PATCH 1/4] Working version of AMD es8336 machine driver

Signed-off-by: Marian Postevca <posteuca@mutex.one>
---
 sound/soc/amd/Kconfig           |  13 +
 sound/soc/amd/Makefile          |   2 +
 sound/soc/amd/acp3x-es8336.c    | 430 ++++++++++++++++++++++++++++++++
 sound/soc/amd/raven/pci-acp3x.c |   4 +-
 sound/soc/codecs/es8316.c       |  64 +++--
 5 files changed, 489 insertions(+), 24 deletions(-)
 create mode 100644 sound/soc/amd/acp3x-es8336.c

diff --git a/sound/soc/amd/Kconfig b/sound/soc/amd/Kconfig
index 150786279..da8c6c024 100644
--- a/sound/soc/amd/Kconfig
+++ b/sound/soc/amd/Kconfig
@@ -54,6 +54,19 @@ config SND_SOC_AMD_RV_RT5682_MACH
 	help
 	 This option enables machine driver for RT5682 and MAX9835.
 
+config SND_SOC_AMD_ACP3x_ES8336_MACH
+	tristate "AMD ACP3x support for ES8336"
+	select SND_SOC_ACPI if ACPI
+	select SND_SOC_ES8316
+	depends on ACPI
+	depends on I2C
+	depends on SND_SOC_AMD_ACP3x
+	help
+	 This option enables machine driver for ACP3x platform
+	 using es8336 codec.
+	 Say m if you have such a device.
+	 If unsure select "N".
+	 
 config SND_SOC_AMD_RENOIR
 	tristate "AMD Audio Coprocessor - Renoir support"
 	select SND_AMD_ACP_CONFIG
diff --git a/sound/soc/amd/Makefile b/sound/soc/amd/Makefile
index 82e1cf864..9d7924ebe 100644
--- a/sound/soc/amd/Makefile
+++ b/sound/soc/amd/Makefile
@@ -4,6 +4,7 @@ snd-soc-acp-da7219mx98357-mach-objs := acp-da7219-max98357a.o
 snd-soc-acp-rt5645-mach-objs := acp-rt5645.o
 snd-soc-acp-es8336-mach-objs := acp-es8336.o
 snd-soc-acp-rt5682-mach-objs := acp3x-rt5682-max9836.o
+snd-soc-acp3x-es8336-mach-objs := acp3x-es8336.o
 snd-acp-config-objs := acp-config.o
 
 obj-$(CONFIG_SND_SOC_AMD_ACP) += acp_audio_dma.o
@@ -12,6 +13,7 @@ obj-$(CONFIG_SND_SOC_AMD_CZ_RT5645_MACH) += snd-soc-acp-rt5645-mach.o
 obj-$(CONFIG_SND_SOC_AMD_ST_ES8336_MACH) += snd-soc-acp-es8336-mach.o
 obj-$(CONFIG_SND_SOC_AMD_ACP3x) += raven/
 obj-$(CONFIG_SND_SOC_AMD_RV_RT5682_MACH) += snd-soc-acp-rt5682-mach.o
+obj-$(CONFIG_SND_SOC_AMD_ACP3x_ES8336_MACH) += snd-soc-acp3x-es8336-mach.o
 obj-$(CONFIG_SND_SOC_AMD_RENOIR) += renoir/
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += vangogh/
 obj-$(CONFIG_SND_SOC_AMD_ACP6x) += yc/
diff --git a/sound/soc/amd/acp3x-es8336.c b/sound/soc/amd/acp3x-es8336.c
new file mode 100644
index 000000000..68c7cf0fd
--- /dev/null
+++ b/sound/soc/amd/acp3x-es8336.c
@@ -0,0 +1,430 @@
+// SPDX-License-Identifier: GPL-2.0+
+//
+// Machine driver for AMD ACP Audio engine using DA7219 & MAX98357 codec.
+//
+//Copyright 2016 Advanced Micro Devices, Inc.
+
+#include <sound/core.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc-dapm.h>
+#include <sound/jack.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/io.h>
+#include <linux/acpi.h>
+#include <linux/dmi.h>
+
+#include "raven/acp3x.h"
+
+#define DRV_NAME        "amd-acp3x-essx8336"
+#define SND_CARD_NAME   DRV_NAME
+#define DUAL_CHANNEL	2
+
+struct acp3x_es8336_private {
+	/* struct acp3x_platform_info machine must always be
+	 * the first entry in the structure,
+	 * the acp3x-i2s driver casts the card private data to
+	 * struct acp3x_platform_info
+	 */
+	struct acp3x_platform_info machine;
+	struct device *codec_dev;
+	struct gpio_desc *gpio_speakers;
+	bool speaker_en;
+};
+
+static const unsigned int channels[] = {
+	DUAL_CHANNEL,
+};
+
+static const unsigned int rates[] = {
+	48000,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_rates = {
+	.count = ARRAY_SIZE(rates),
+	.list  = rates,
+	.mask = 0,
+};
+
+static const struct snd_pcm_hw_constraint_list constraints_channels = {
+	.count = ARRAY_SIZE(channels),
+	.list = channels,
+	.mask = 0,
+};
+#define ES8336_MCLK_FREQ (48000 * 256)
+
+static int acp3x_es8336_codec_startup(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	struct snd_soc_pcm_runtime *rtd;
+	struct acp3x_platform_info *machine;
+	struct acp3x_es8336_private *priv;
+	struct snd_soc_dai *codec_dai;
+	int ret;
+
+	runtime = substream->runtime;
+	rtd = asoc_substream_to_rtd(substream);
+	priv = snd_soc_card_get_drvdata(rtd->card);
+	machine = &priv->machine;
+	codec_dai = asoc_rtd_to_codec(rtd, 0);
+
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, ES8336_MCLK_FREQ, SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		dev_err(rtd->dev, "can't set codec sysclk: %d\n", ret);
+		return ret;
+	}
+
+	ret =  snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF
+	                           | SND_SOC_DAIFMT_CBP_CFP);
+	if (ret < 0) {
+		dev_err(rtd->dev, "failed to set DAI fmt: %d\n", ret);
+		return ret;
+	}
+	/* Report to userspace ALSA that we don't support suspending and resuming pcm streams,
+	 * this means that during suspends and resumes of the PC, pulseaudio will not try to resume
+	 * the substream, but will drop the connection and establish a new one.
+	 * This is needed because sometimes after resume pulseaudio is unable to resume the stream
+	 * and no sound can be heard. As a workaround for this issue, pulseaudio needs to be restarted.
+	 */
+	runtime->hw.info &= ~(SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME);
+
+	runtime->hw.channels_max = DUAL_CHANNEL;
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_CHANNELS,
+	                           &constraints_channels);
+	snd_pcm_hw_constraint_list(runtime, 0, SNDRV_PCM_HW_PARAM_RATE,
+	                           &constraints_rates);
+	runtime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;
+	machine->play_i2s_instance = I2S_SP_INSTANCE;
+
+	return 0;
+}
+
+static int acp3x_es8336_speaker_power_event(struct snd_soc_dapm_widget *w,
+                                            struct snd_kcontrol *kcontrol, int event);
+
+static struct snd_soc_jack es8336_jack;
+
+static struct snd_soc_jack_pin es8336_jack_pins[] = {
+	{
+		.pin	= "Headphone",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin	= "Headset Mic",
+		.mask	= SND_JACK_MICROPHONE,
+	 },
+};
+
+static const struct snd_soc_dapm_widget acp3x_es8336_widgets[] = {
+	SND_SOC_DAPM_SPK("Speaker", NULL),
+	SND_SOC_DAPM_HP("Headphone", NULL),
+	SND_SOC_DAPM_MIC("Headset Mic", NULL),
+	SND_SOC_DAPM_MIC("Internal Mic", NULL),
+
+	SND_SOC_DAPM_SUPPLY("Speaker Power", SND_SOC_NOPM, 0, 0,
+	                    acp3x_es8336_speaker_power_event,
+	                    SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMU),
+};
+
+static const struct snd_soc_dapm_route acp3x_es8336_audio_map[] = {
+	{"Headphone", NULL, "HPOL"},
+	{"Headphone", NULL, "HPOR"},
+
+	/*
+	 * There is no separate speaker output instead the speakers are muxed to
+	 * the HP outputs. The mux is controlled Speaker and/or headphone switch.
+	 */
+	{"Speaker", NULL, "HPOL"},
+	{"Speaker", NULL, "HPOR"},
+	{"MIC1", NULL, "Headset Mic"},
+	{"Speaker", NULL, "Speaker Power"},
+};
+
+
+static const struct snd_kcontrol_new acp3x_es8336_controls[] = {
+	SOC_DAPM_PIN_SWITCH("Speaker"),
+	SOC_DAPM_PIN_SWITCH("Headphone"),
+	SOC_DAPM_PIN_SWITCH("Headset Mic"),
+};
+
+static const struct acpi_gpio_params enable_gpio0 = { 0, 0, true };
+
+static const struct acpi_gpio_mapping acpi_speakers_enable_gpio0[] = {
+	{ "speakers-enable-gpios", &enable_gpio0, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },
+	{ }
+};
+
+static int acp3x_es8336_speaker_power_event(struct snd_soc_dapm_widget *w,
+                                            struct snd_kcontrol *kcontrol, int event)
+{
+	struct acp3x_es8336_private *priv = snd_soc_card_get_drvdata(w->dapm->card);
+
+	if (priv->speaker_en == !SND_SOC_DAPM_EVENT_ON(event))
+		return 0;
+
+	priv->speaker_en = !SND_SOC_DAPM_EVENT_ON(event);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		msleep(70);
+
+	gpiod_set_value_cansleep(priv->gpio_speakers, priv->speaker_en);
+
+	return 0;
+}
+
+/*
+  static int acp3x_es8336_hw_params(struct snd_pcm_substream *substream,
+  struct snd_pcm_hw_params *params)
+  {
+  struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+  struct snd_soc_dai *codec_dai = asoc_rtd_to_codec(rtd, 0);
+  struct snd_mask *fmt = hw_param_mask(params, SNDRV_PCM_HW_PARAM_FORMAT);
+
+  printk(KERN_INFO"mysound1: entered card set hw params\n");
+
+  //snd_mask_none(fmt);
+  //snd_mask_set_format(fmt, SNDRV_PCM_FORMAT_S32_LE);
+
+  return 0;
+  }
+*/
+
+static int acp3x_es8336_init(struct snd_soc_pcm_runtime *runtime)
+{
+	struct snd_soc_component *codec = asoc_rtd_to_codec(runtime, 0)->component;
+	struct snd_soc_card *card = runtime->card;
+	struct acp3x_es8336_private *priv = snd_soc_card_get_drvdata(card);
+	int ret;
+
+	ret = snd_soc_card_jack_new_pins(card, "Headset",
+	                                 SND_JACK_HEADSET | SND_JACK_BTN_0,
+	                                 &es8336_jack, es8336_jack_pins,
+	                                 ARRAY_SIZE(es8336_jack_pins));
+	if (ret) {
+		dev_err(card->dev, "jack creation failed %d\n", ret);
+		return ret;
+	}
+
+	snd_jack_set_key(es8336_jack.jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+
+	snd_soc_component_set_jack(codec, &es8336_jack, NULL);
+
+	ret = devm_acpi_dev_add_driver_gpios(codec->dev, acpi_speakers_enable_gpio0);
+	if (ret)
+		dev_warn(codec->dev, "failed to add speaker gpio\n");
+
+	priv->codec_dev = codec->dev;
+	priv->gpio_speakers = gpiod_get_optional(codec->dev, "speakers-enable", GPIOD_OUT_LOW);
+	if (IS_ERR(priv->gpio_speakers)) {
+		dev_err(codec->dev, "could not get speakers-enable GPIO\n");
+		return PTR_ERR(priv->gpio_speakers);
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops acp3x_es8336_ops = {
+	//	.hw_params = acp3x_es8336_hw_params,
+	.startup = acp3x_es8336_codec_startup,
+};
+
+
+SND_SOC_DAILINK_DEF(acp3x_i2s,
+                    DAILINK_COMP_ARRAY(COMP_CPU("acp3x_i2s_playcap.0")));
+SND_SOC_DAILINK_DEF(codec,
+                    DAILINK_COMP_ARRAY(COMP_CODEC("i2c-ESSX8336:00", "ES8316 HiFi")));
+SND_SOC_DAILINK_DEF(platform,
+                    DAILINK_COMP_ARRAY(COMP_PLATFORM("acp3x_rv_i2s_dma.0")));
+
+static struct snd_soc_dai_link acp3x_dai_es8336[] = {
+	{
+		.name = "amd-acp3x-es8336-dai",
+		.stream_name = "ES8336 HiFi Play",
+		.stop_dma_first = 1,
+		.nonatomic = true,
+		.dpcm_capture = 1,
+		.dpcm_playback = 1,
+		.init = acp3x_es8336_init,
+		.ops = &acp3x_es8336_ops,
+		SND_SOC_DAILINK_REG(acp3x_i2s, codec, platform),
+	},
+};
+
+static struct snd_soc_card acp3x_es8336 = {
+	.name = SND_CARD_NAME,
+	.owner = THIS_MODULE,
+	.dai_link = acp3x_dai_es8336,
+	.num_links = ARRAY_SIZE(acp3x_dai_es8336),
+	.dapm_widgets = acp3x_es8336_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(acp3x_es8336_widgets),
+	.dapm_routes = acp3x_es8336_audio_map,
+	.num_dapm_routes = ARRAY_SIZE(acp3x_es8336_audio_map),
+	.controls = acp3x_es8336_controls,
+	.num_controls = ARRAY_SIZE(acp3x_es8336_controls),
+};
+
+static const struct dmi_system_id acp3x_es8336_dmi_table[] = {
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "HUAWEI"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "KLVL-WXXW"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "M1010"),
+		},
+		.driver_data = &acp3x_es8336,
+	},
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "HUAWEI"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "KLVL-WXX9"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "M1010"),
+		},
+		.driver_data = &acp3x_es8336,
+	},
+	{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "HUAWEI"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "BOM-WXX9"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "M1010"),
+		},
+		.driver_data = &acp3x_es8336,
+	},
+	{}
+};
+
+
+static int acp3x_probe(struct platform_device *pdev)
+{
+	int ret = -ENODEV;
+	struct device *dev = &pdev->dev;
+	const struct dmi_system_id *dmi_id;
+
+	dmi_id = dmi_first_match(acp3x_es8336_dmi_table);
+	if (dmi_id && dmi_id->driver_data) {
+		struct acp3x_es8336_private *priv;
+		struct snd_soc_card *card;
+
+		dev_info(dev, "matched DMI table with this system, trying to register sound card\n");
+
+		priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+		if (!priv) {
+			dev_err(dev, "can't alloc priv structure\n");
+			return -ENOMEM;
+		}
+
+		card = (struct snd_soc_card *)dmi_id->driver_data;
+
+		card->dev = &pdev->dev;
+		platform_set_drvdata(pdev, card);
+		snd_soc_card_set_drvdata(card, priv);
+		ret = devm_snd_soc_register_card(&pdev->dev, card);
+		if (ret) {
+			dev_err(dev, "failed to register sound card, ret = %d\n", ret);
+			return dev_err_probe(&pdev->dev, ret,
+			                     "devm_snd_soc_register_card(%s) failed\n",
+			                     card->name);
+		} else {
+			dev_info(dev, "successfully registered the sound card\n");
+		}
+	}
+	else {
+		dev_warn(dev, "this system has a ES8336 codec defined in ACPI, "
+		         "but the driver doesn't have this system registered in DMI table\n");
+	}
+	return ret;
+}
+
+
+static int acp3x_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+	struct acp3x_es8336_private *priv = snd_soc_card_get_drvdata(card);
+	struct device *dev = &pdev->dev;
+
+	gpiod_put(priv->gpio_speakers);
+
+	dev_info(dev, "removing sound card\n");
+	return 0;
+}
+
+/*
+  static const struct platform_device_id board_ids[] = {
+  {
+  .name = "acp3x-essx8336",
+  },
+  { }
+  };
+*/
+//MODULE_DEVICE_TABLE(platform, board_ids);
+
+
+
+static const struct acpi_device_id acp3x_audio_acpi_match[] = {
+	{"ESSX8336", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(acpi, acp3x_audio_acpi_match);
+
+
+static struct platform_driver acp3x_audio = {
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+		//.acpi_match_table = ACPI_PTR(acp3x_audio_acpi_match),
+		.pm = &snd_soc_pm_ops,
+	},
+	.probe = acp3x_probe,
+	.remove = acp3x_remove,
+	//.id_table = board_ids,
+};
+
+static struct platform_device *acp3x_es8336_snd_device;
+
+static int __init acp3x_es8336_module_init(void)
+{
+	int ret = -ENODEV;
+
+	msleep(5000);
+	ret = platform_driver_register(&acp3x_audio);
+	if (ret < 0) {
+		printk(KERN_ERR DRV_NAME": can't register platform driver\n");
+		return ret;
+	}
+
+	acp3x_es8336_snd_device = platform_device_register_simple(DRV_NAME, 0, NULL, 0);
+	if (IS_ERR(acp3x_es8336_snd_device)) {
+		printk(KERN_ERR DRV_NAME": couldn't register platform device\n");
+		platform_driver_unregister(&acp3x_audio);
+		return PTR_ERR(acp3x_es8336_snd_device);
+	}
+
+	if (!platform_get_drvdata(acp3x_es8336_snd_device)) {
+		printk(KERN_ERR DRV_NAME": probe of hw failed\n");
+		platform_device_unregister(acp3x_es8336_snd_device);
+		platform_driver_unregister(&acp3x_audio);
+		return -ENODEV;
+	}
+	printk(KERN_INFO DRV_NAME": platform device registered successfully\n");
+
+	return ret;
+}
+module_init(acp3x_es8336_module_init);
+
+static void __exit acp3x_es8336_module_exit(void)
+{
+	printk(KERN_INFO DRV_NAME": module unloading\n");
+	platform_device_unregister(acp3x_es8336_snd_device);
+	platform_driver_unregister(&acp3x_audio);
+}
+module_exit(acp3x_es8336_module_exit);
+
+MODULE_AUTHOR("posteuca@mutex.one");
+MODULE_DESCRIPTION("ACP3x rev 1 ES8336 audio support");
+MODULE_LICENSE("GPL v2");
+//MODULE_ALIAS("dmi:bvnHUAWEI:*:*:*:*:*:pnKLVL-WXXW:pvrM1010:rvnHUAWEI:rnKLVL-WXXW-PCB:rvrM1010:*:*:*:skuC100:*")
+//MODULE_ALIAS("platform:acp3x-essx8336");
diff --git a/sound/soc/amd/raven/pci-acp3x.c b/sound/soc/amd/raven/pci-acp3x.c
index a013a607b..cdb8773b1 100644
--- a/sound/soc/amd/raven/pci-acp3x.c
+++ b/sound/soc/amd/raven/pci-acp3x.c
@@ -133,8 +133,8 @@ static int snd_acp3x_probe(struct pci_dev *pci,
 	int ret, i;
 	u32 addr, val;
 
-	/* Raven device detection */
-	if (pci->revision != 0x00)
+	/* Raven and lucienne device detection */
+	if (pci->revision != 0x00 && pci->revision != 0x01)
 		return -ENODEV;
 
 	if (pci_enable_device(pci)) {
diff --git a/sound/soc/codecs/es8316.c b/sound/soc/codecs/es8316.c
index 056c3082f..462336b91 100644
--- a/sound/soc/codecs/es8316.c
+++ b/sound/soc/codecs/es8316.c
@@ -86,7 +86,7 @@ static const struct soc_enum dacpol =
 	SOC_ENUM_SINGLE(ES8316_DAC_SET1, 0, 4, dacpol_txt);
 
 static const struct snd_kcontrol_new es8316_snd_controls[] = {
-	SOC_DOUBLE_TLV("Headphone Playback Volume", ES8316_CPHP_ICAL_VOL,
+	SOC_DOUBLE_TLV("Master Playback Volume", ES8316_CPHP_ICAL_VOL,
 		       4, 0, 3, 1, hpout_vol_tlv),
 	SOC_DOUBLE_TLV("Headphone Mixer Volume", ES8316_HPMIX_VOL,
 		       4, 0, 11, 0, hpmixer_gain_tlv),
@@ -520,7 +520,7 @@ static int es8316_mute(struct snd_soc_dai *dai, int mute, int direction)
 }
 
 #define ES8316_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
-			SNDRV_PCM_FMTBIT_S24_LE)
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
 
 static const struct snd_soc_dai_ops es8316_ops = {
 	.startup = es8316_pcm_startup,
@@ -717,6 +717,41 @@ static int es8316_set_jack(struct snd_soc_component *component,
 	return 0;
 }
 
+#ifdef CONFIG_PM
+
+static int es8316_suspend(struct snd_soc_component *component)
+{
+	struct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);
+	regcache_cache_only(es8316->regmap, true);
+
+	return 0;
+}
+
+static int es8316_resume(struct snd_soc_component *component)
+{
+	struct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);
+
+	regcache_cache_only(es8316->regmap, false);
+	/* Reset codec and enable current state machine */
+	snd_soc_component_write(component, ES8316_RESET, 0x3f);
+	usleep_range(5000, 5500);
+	snd_soc_component_write(component, ES8316_RESET, ES8316_RESET_CSM_ON);
+	msleep(30);
+
+	snd_soc_component_write(component, ES8316_SYS_VMIDSEL, 0xff);
+
+	snd_soc_component_write(component, ES8316_CLKMGR_ADCOSR, 0x32);
+
+	regcache_mark_dirty(es8316->regmap);
+	regcache_sync(es8316->regmap);
+
+	return 0;
+}
+#else
+#define es8316_suspend NULL
+#define es8316_resume NULL
+#endif
+
 static int es8316_probe(struct snd_soc_component *component)
 {
 	struct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);
@@ -767,26 +802,6 @@ static void es8316_remove(struct snd_soc_component *component)
 	clk_disable_unprepare(es8316->mclk);
 }
 
-static int es8316_resume(struct snd_soc_component *component)
-{
-	struct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);
-
-	regcache_cache_only(es8316->regmap, false);
-	regcache_sync(es8316->regmap);
-
-	return 0;
-}
-
-static int es8316_suspend(struct snd_soc_component *component)
-{
-	struct es8316_priv *es8316 = snd_soc_component_get_drvdata(component);
-
-	regcache_cache_only(es8316->regmap, true);
-	regcache_mark_dirty(es8316->regmap);
-
-	return 0;
-}
-
 static const struct snd_soc_component_driver soc_component_dev_es8316 = {
 	.probe			= es8316_probe,
 	.remove			= es8316_remove,
@@ -794,6 +809,8 @@ static const struct snd_soc_component_driver soc_component_dev_es8316 = {
 	.suspend		= es8316_suspend,
 	.set_jack		= es8316_set_jack,
 	.controls		= es8316_snd_controls,
+	.suspend		= es8316_suspend,
+	.resume		= es8316_resume,
 	.num_controls		= ARRAY_SIZE(es8316_snd_controls),
 	.dapm_widgets		= es8316_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(es8316_dapm_widgets),
@@ -805,6 +822,9 @@ static const struct snd_soc_component_driver soc_component_dev_es8316 = {
 
 static const struct regmap_range es8316_volatile_ranges[] = {
 	regmap_reg_range(ES8316_GPIO_FLAG, ES8316_GPIO_FLAG),
+	regmap_reg_range(ES8316_RESET, ES8316_RESET),
+	regmap_reg_range(ES8316_SYS_VMIDSEL,ES8316_SYS_VMIDSEL),
+	regmap_reg_range(ES8316_CLKMGR_ADCOSR,ES8316_CLKMGR_ADCOSR),
 };
 
 static const struct regmap_access_table es8316_volatile_table = {
-- 
2.39.2


From b5de6d652eae95a3ec8a52bfbd250be5f0f5decf Mon Sep 17 00:00:00 2001
From: Roman Martynoff <nonsensr@gmail.com>
Date: Sun, 8 Jan 2023 16:10:33 +0400
Subject: [PATCH 2/4] Add support for MateBook D16 with AMD Ryzen 5 4600H
 (HVY-WXX9)

---
 sound/soc/amd/acp3x-es8336.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/sound/soc/amd/acp3x-es8336.c b/sound/soc/amd/acp3x-es8336.c
index 68c7cf0fd..9a1032f82 100644
--- a/sound/soc/amd/acp3x-es8336.c
+++ b/sound/soc/amd/acp3x-es8336.c
@@ -293,6 +293,14 @@ static const struct dmi_system_id acp3x_es8336_dmi_table[] = {
 			DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "M1010"),
 		},
 		.driver_data = &acp3x_es8336,
+	},
+		{
+		.matches = {
+			DMI_EXACT_MATCH(DMI_BOARD_VENDOR, "HUAWEI"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "HVY-WXX9"),
+			DMI_EXACT_MATCH(DMI_PRODUCT_VERSION, "M1040"),
+		},
+		.driver_data = &acp3x_es8336,
 	},
 	{}
 };
-- 
2.39.2


From daeb2a3dcdc5e616bb746b9effc4644c7a488a5a Mon Sep 17 00:00:00 2001
From: Marian Postevca <posteuca@mutex.one>
Date: Mon, 9 Jan 2023 20:50:40 +0200
Subject: [PATCH 3/4] Seems non-atomic is not always supported, disable it
 completely

---
 sound/soc/amd/acp3x-es8336.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/sound/soc/amd/acp3x-es8336.c b/sound/soc/amd/acp3x-es8336.c
index 9a1032f82..f600d11e6 100644
--- a/sound/soc/amd/acp3x-es8336.c
+++ b/sound/soc/amd/acp3x-es8336.c
@@ -247,7 +247,6 @@ static struct snd_soc_dai_link acp3x_dai_es8336[] = {
 		.name = "amd-acp3x-es8336-dai",
 		.stream_name = "ES8336 HiFi Play",
 		.stop_dma_first = 1,
-		.nonatomic = true,
 		.dpcm_capture = 1,
 		.dpcm_playback = 1,
 		.init = acp3x_es8336_init,
-- 
2.39.2


From b9731beeb484d7b2ccaeaa123ca803f87e7b73cf Mon Sep 17 00:00:00 2001
From: Marian Postevca <posteuca@mutex.one>
Date: Wed, 11 Jan 2023 00:33:09 +0200
Subject: [PATCH 4/4] Added support for reading _DSM ACPI DATA

---
 sound/soc/codecs/Kconfig             |   5 +
 sound/soc/codecs/Makefile            |   2 +
 sound/soc/codecs/es8316.c            |  13 +-
 sound/soc/codecs/es83xx-dsm-common.c | 369 ++++++++++++++++++++++++
 sound/soc/codecs/es83xx-dsm-common.h | 403 +++++++++++++++++++++++++++
 5 files changed, 790 insertions(+), 2 deletions(-)
 create mode 100644 sound/soc/codecs/es83xx-dsm-common.c
 create mode 100644 sound/soc/codecs/es83xx-dsm-common.h

diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 7022e6286..cad7d1781 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -924,13 +924,18 @@ config SND_SOC_ES7134
 config SND_SOC_ES7241
 	tristate "Everest Semi ES7241 CODEC"
 
+config SND_SOC_ES83XX_DSM_COMMON
+	tristate
+
 config SND_SOC_ES8316
 	tristate "Everest Semi ES8316 CODEC"
 	depends on I2C
+	select SND_SOC_ES83XX_DSM_COMMON if ACPI
 
 config SND_SOC_ES8326
 	tristate "Everest Semi ES8326 CODEC"
 	depends on I2C
+	select SND_SOC_ES83XX_DSM_COMMON if ACPI
 
 config SND_SOC_ES8328
 	tristate
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index 9170ee144..eeac06809 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -101,6 +101,7 @@ snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es7241-objs := es7241.o
+snd-soc-es83xx-dsm-common-objs := es83xx-dsm-common.o
 snd-soc-es8316-objs := es8316.o
 snd-soc-es8326-objs := es8326.o
 snd-soc-es8328-objs := es8328.o
@@ -461,6 +462,7 @@ obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES7241)	+= snd-soc-es7241.o
+obj-$(CONFIG_SND_SOC_ES83XX_DSM_COMMON)    += snd-soc-es83xx-dsm-common.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
 obj-$(CONFIG_SND_SOC_ES8326)    += snd-soc-es8326.o
 obj-$(CONFIG_SND_SOC_ES8328)	+= snd-soc-es8328.o
diff --git a/sound/soc/codecs/es8316.c b/sound/soc/codecs/es8316.c
index 462336b91..11ea3b638 100644
--- a/sound/soc/codecs/es8316.c
+++ b/sound/soc/codecs/es8316.c
@@ -22,6 +22,7 @@
 #include <sound/tlv.h>
 #include <sound/jack.h>
 #include "es8316.h"
+#include "es83xx-dsm-common.h"
 
 /* In slave mode at single speed, the codec is documented as accepting 5
  * MCLK/LRCK ratios, but we also add ratio 400, which is commonly used on
@@ -809,8 +810,6 @@ static const struct snd_soc_component_driver soc_component_dev_es8316 = {
 	.suspend		= es8316_suspend,
 	.set_jack		= es8316_set_jack,
 	.controls		= es8316_snd_controls,
-	.suspend		= es8316_suspend,
-	.resume		= es8316_resume,
 	.num_controls		= ARRAY_SIZE(es8316_snd_controls),
 	.dapm_widgets		= es8316_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(es8316_dapm_widgets),
@@ -853,6 +852,16 @@ static int es8316_i2c_probe(struct i2c_client *i2c_client)
 	if (es8316 == NULL)
 		return -ENOMEM;
 
+	es83xx_dsm_dump(dev);
+
+	/* read jack information from _DSM */
+	ret = es83xx_dsm_jack_inverted(dev);
+	if (ret < 0)
+		dev_warn(dev, "%s: Could not get jack detection information with ACPI _DSM method\n",
+			 __func__);
+	else
+		es8316->jd_inverted = ret;
+
 	i2c_set_clientdata(i2c_client, es8316);
 
 	es8316->regmap = devm_regmap_init_i2c(i2c_client, &es8316_regmap);
diff --git a/sound/soc/codecs/es83xx-dsm-common.c b/sound/soc/codecs/es83xx-dsm-common.c
new file mode 100644
index 000000000..2f1f6a919
--- /dev/null
+++ b/sound/soc/codecs/es83xx-dsm-common.c
@@ -0,0 +1,369 @@
+// SPDX-License-Identifier: GPL-2.0-only
+//
+// Copyright (c) Intel Corporation, 2022
+// Copyright Everest Semiconductor Co.,Ltd
+
+#define DEBUG
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include "es83xx-dsm-common.h"
+
+/* UUID ("a9800c04-e016-343e-41f4-6bcce70f4332") */
+static const guid_t es83xx_dsm_guid =
+	GUID_INIT(0xa9800c04, 0xe016, 0x343e,
+		  0x41, 0xf4, 0x6b, 0xcc, 0xe7, 0x0f, 0x43, 0x32);
+
+#define ES83xx_DSM_REVID 1
+
+static int es83xx_dsm(struct device *dev, int arg, int *value)
+{
+	acpi_handle dhandle;
+	union acpi_object *obj;
+	int ret = 0;
+
+	dhandle = ACPI_HANDLE(dev);
+	if (!dhandle)
+		return -ENOENT;
+
+	obj = acpi_evaluate_dsm(dhandle, &es83xx_dsm_guid, ES83xx_DSM_REVID,
+				arg, NULL);
+	if (!obj) {
+		dev_err(dev, "%s: acpi_evaluate_dsm() failed\n", __func__);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (obj->type != ACPI_TYPE_INTEGER) {
+		dev_err(dev, "%s: object is not ACPI_TYPE_INTEGER\n", __func__);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	*value = obj->integer.value;
+err:
+	ACPI_FREE(obj);
+out:
+	return ret;
+}
+
+void es83xx_dsm_dump(struct device *dev)
+{
+	int value;
+	int ret;
+
+	/*
+	 * The _DSM method returns 0xff if the argument is not handled.
+	 */
+	ret = es83xx_dsm(dev, PLATFORM_MAINMIC_TYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_MAINMIC_TYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_HPMIC_TYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_HPMIC_TYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_SPK_TYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_SPK_TYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_HPDET_INV_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_HPDET_INV_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_PCM_TYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_PCM_TYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_MIC_DE_POP_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_MIC_DE_POP_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_CODEC_TYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_CODEC_TYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_BUS_SLOT_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_BUS_SLOT_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_LINEIN_PGA_GAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_LINEIN_PGA_GAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_LINEIN_PGA_GAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_LINEIN_PGA_GAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_D2SEPGA_GAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_D2SEPGA_GAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_D2SEPGA_GAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_D2SEPGA_GAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_ENABLE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_ENABLE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_ENABLE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_ENABLE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_TARGET_LEVEL_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_TARGET_LEVEL_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_TARGET_LEVEL_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_TARGET_LEVEL_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_MAXGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_MAXGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_MAXGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_MAXGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_MINGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_MINGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_MINGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_MINGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_HLDTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_HLDTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_HLDTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_HLDTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_DCYTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_DCYTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_DCYTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_DCYTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_ATKTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_ATKTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_ATKTIME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_ATKTIME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_NGTYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_NGTYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_NGTYPE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_NGTYPE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_ADC_ALC_NGTHLD_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_ADC_ALC_NGTHLD_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_ALC_NGTHLD_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_ALC_NGTHLD_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_GUI_STEP_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_GUI_STEP_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, MAIN_CODEC_ADC_GUI_GAIN_RANGE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "MAIN_CODEC_ADC_GUI_GAIN_RANGE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HEADPHONE_DUMMY_REMOVE_ENABLE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HEADPHONE_DUMMY_REMOVE_ENABLE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_DAC_HPMIX_HIGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_DAC_HPMIX_HIGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_DAC_HPMIX_HIGAIN_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_DAC_HPMIX_HIGAIN_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_DAC_HPMIX_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_DAC_HPMIX_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_DAC_HPMIX_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_DAC_HPMIX_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_DAC_HPOUT_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_DAC_HPOUT_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_DAC_HPOUT_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_DAC_HPOUT_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_LDAC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_LDAC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_RDAC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_RDAC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_LDAC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_LDAC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_RDAC_VOLUME_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_RDAC_VOLUME_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_DAC_AUTOMUTE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_DAC_AUTOMUTE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_DAC_AUTOMUTE_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_DAC_AUTOMUTE_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CODEC_DAC_MONO_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CODEC_DAC_MONO_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CODEC_DAC_MONO_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CODEC_DAC_MONO_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, HP_CTL_IO_LEVEL_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "HP_CTL_IO_LEVEL_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, SPK_CTL_IO_LEVEL_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "SPK_CTL_IO_LEVEL_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, CODEC_GPIO0_FUNC_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "CODEC_GPIO0_FUNC_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, CODEC_GPIO1_FUNC_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "CODEC_GPIO1_FUNC_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, CODEC_GPIO2_FUNC_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "CODEC_GPIO2_FUNC_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, CODEC_GPIO3_FUNC_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "CODEC_GPIO3_FUNC_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, CODEC_GPIO4_FUNC_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "CODEC_GPIO4_FUNC_ARG=%#x\n", value);
+
+	ret = es83xx_dsm(dev, PLATFORM_MCLK_LRCK_FREQ_ARG, &value);
+	if (ret >= 0 && value != 0xff)
+		dev_dbg(dev, "PLATFORM_MCLK_LRCK_FREQ_ARG=%#x\n", value);
+}
+EXPORT_SYMBOL_GPL(es83xx_dsm_dump);
+
+int es83xx_dsm_jack_inverted(struct device *dev)
+{
+	int value;
+	int ret;
+
+	es83xx_dsm_dump(dev);
+
+	ret = es83xx_dsm(dev,  PLATFORM_HPDET_INV_ARG, &value);
+	if (ret < 0)
+		return ret;
+	dev_info(dev, "HP jack detect inverted %d\n", value);
+	return value;
+}
+EXPORT_SYMBOL_GPL(es83xx_dsm_jack_inverted);
+
+int es83xx_dsm_is_gpio_level_low(struct device *dev, bool is_spk)
+{
+	int value;
+	int ret;
+	const char *type;
+
+	if (is_spk) {
+		type = "Speaker";
+		ret = es83xx_dsm(dev, SPK_CTL_IO_LEVEL_ARG, &value);
+	} else {
+		type = "Headphone";
+		ret = es83xx_dsm(dev, HP_CTL_IO_LEVEL_ARG, &value);
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "%s: Can't read I/O ctl level argument\n", type);
+		return ret;
+	}
+
+	switch (value) {
+	case GPIO_CTL_IO_LEVEL_HIGH:
+		return 0;
+	case GPIO_CTL_IO_LEVEL_LOW:
+	case 0xff:
+		return 1;
+	default:
+		dev_err(dev, "%s: invalid I/O ctl level argument (%d)\n",
+			type, value);
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL_GPL(es83xx_dsm_is_gpio_level_low);
+
+int es83xx_dsm_mic_type(struct device *dev, bool is_main)
+{
+	int value;
+	int ret;
+	const char *type;
+
+	if (is_main) {
+		type = "main";
+		ret = es83xx_dsm(dev, PLATFORM_MAINMIC_TYPE_ARG, &value);
+	} else {
+		type = "headset";
+		ret = es83xx_dsm(dev, PLATFORM_HPMIC_TYPE_ARG, &value);
+	}
+
+	if (ret < 0) {
+		dev_err(dev, "Can't read %s microphone type\n", type);
+		return ret;
+	}
+
+	switch (value) {
+	case PLATFORM_MIC_DMIC_HIGH_LEVEL:
+	case PLATFORM_MIC_DMIC_LOW_LEVEL:
+	case PLATFORM_MIC_AMIC_LIN1RIN1:
+	case PLATFORM_MIC_AMIC_LIN2RIN2:
+		return value;
+	default:
+		dev_err(dev, "Invalid value for %s microphone type (%d)\n",
+			type, value);
+		return -EINVAL;
+	}
+}
+EXPORT_SYMBOL_GPL(es83xx_dsm_mic_type);
+
+MODULE_DESCRIPTION("Everest Semi ES83xx DSM helpers");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/codecs/es83xx-dsm-common.h b/sound/soc/codecs/es83xx-dsm-common.h
new file mode 100644
index 000000000..041a809e6
--- /dev/null
+++ b/sound/soc/codecs/es83xx-dsm-common.h
@@ -0,0 +1,403 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (c) Intel Corporation, 2022
+ * Copyright Everest Semiconductor Co.,Ltd
+ */
+
+/* Definitions extracted from ASL file provided at
+ * https://github.com/thesofproject/linux/files/9398723/ESSX8326.zip
+ */
+
+#ifndef _ES83XX_DSM_COMMON_H
+#define _ES83XX_DSM_COMMON_H
+
+/***************************************************
+ *  DSM arguments                                  *
+ ***************************************************/
+
+#define PLATFORM_MAINMIC_TYPE_ARG		0x00
+#define PLATFORM_HPMIC_TYPE_ARG			0x01
+#define PLATFORM_SPK_TYPE_ARG			0x02
+#define PLATFORM_HPDET_INV_ARG			0x03
+#define PLATFORM_PCM_TYPE_ARG			0x04
+
+#define PLATFORM_MIC_DE_POP_ARG			0x06
+#define PLATFORM_CODEC_TYPE_ARG			0x0E
+#define PLATFORM_BUS_SLOT_ARG			0x0F
+
+#define HP_CODEC_LINEIN_PGA_GAIN_ARG		0x10
+#define MAIN_CODEC_LINEIN_PGA_GAIN_ARG		0x20
+
+#define HP_CODEC_D2SEPGA_GAIN_ARG		0x11
+#define MAIN_CODEC_D2SEPGA_GAIN_ARG		0x21
+
+#define HP_CODEC_ADC_VOLUME_ARG			0x12
+#define MAIN_CODEC_ADC_VOLUME_ARG		0x22
+
+#define HP_CODEC_ADC_ALC_ENABLE_ARG		0x13
+#define MAIN_CODEC_ADC_ALC_ENABLE_ARG		0x23
+
+#define HP_CODEC_ADC_ALC_TARGET_LEVEL_ARG	0x14
+#define MAIN_CODEC_ADC_ALC_TARGET_LEVEL_ARG	0x24
+
+#define HP_CODEC_ADC_ALC_MAXGAIN_ARG		0x15
+#define MAIN_CODEC_ADC_ALC_MAXGAIN_ARG		0x25
+
+#define HP_CODEC_ADC_ALC_MINGAIN_ARG		0x16
+#define MAIN_CODEC_ADC_ALC_MINGAIN_ARG		0x26
+
+#define HP_CODEC_ADC_ALC_HLDTIME_ARG		0x17
+#define MAIN_CODEC_ADC_ALC_HLDTIME_ARG		0x27
+
+#define HP_CODEC_ADC_ALC_DCYTIME_ARG		0x18
+#define MAIN_CODEC_ADC_ALC_DCYTIME_ARG		0x28
+
+#define HP_CODEC_ADC_ALC_ATKTIME_ARG		0x19
+#define MAIN_CODEC_ADC_ALC_ATKTIME_ARG		0x29
+
+#define HP_CODEC_ADC_ALC_NGTYPE_ARG		0x1a
+#define MAIN_CODEC_ADC_ALC_NGTYPE_ARG		0x2a
+
+#define HP_CODEC_ADC_ALC_NGTHLD_ARG		0x1b
+#define MAIN_CODEC_ADC_ALC_NGTHLD_ARG		0x2b
+
+#define MAIN_CODEC_ADC_GUI_STEP_ARG		0x2c
+#define MAIN_CODEC_ADC_GUI_GAIN_RANGE_ARG	0x2c
+
+#define HEADPHONE_DUMMY_REMOVE_ENABLE_ARG	0x2e
+
+#define HP_CODEC_DAC_HPMIX_HIGAIN_ARG		0x40
+#define SPK_CODEC_DAC_HPMIX_HIGAIN_ARG		0x50
+
+#define HP_CODEC_DAC_HPMIX_VOLUME_ARG		0x41
+#define SPK_CODEC_DAC_HPMIX_VOLUME_ARG		0x51
+
+#define HP_CODEC_DAC_HPOUT_VOLUME_ARG		0x42
+#define SPK_CODEC_DAC_HPOUT_VOLUME_ARG		0x52
+
+#define HP_CODEC_LDAC_VOLUME_ARG		0x44
+#define HP_CODEC_RDAC_VOLUME_ARG		0x54
+
+#define SPK_CODEC_LDAC_VOLUME_ARG		0x45
+#define SPK_CODEC_RDAC_VOLUME_ARG		0x55
+
+#define HP_CODEC_DAC_AUTOMUTE_ARG		0x46
+#define SPK_CODEC_DAC_AUTOMUTE_ARG		0x56
+
+#define HP_CODEC_DAC_MONO_ARG			0x4A
+#define SPK_CODEC_DAC_MONO_ARG			0x5A
+
+#define HP_CTL_IO_LEVEL_ARG			0x4B
+#define SPK_CTL_IO_LEVEL_ARG			0x5B
+
+#define CODEC_GPIO0_FUNC_ARG			0x80
+#define CODEC_GPIO1_FUNC_ARG			0x81
+#define CODEC_GPIO2_FUNC_ARG			0x82
+#define CODEC_GPIO3_FUNC_ARG			0x83
+#define CODEC_GPIO4_FUNC_ARG			0x84
+
+#define PLATFORM_MCLK_LRCK_FREQ_ARG		0x85
+
+/***************************************************
+ *  Values for arguments                           *
+ ***************************************************/
+
+/* Main and HP Mic */
+#define PLATFORM_MIC_DMIC_HIGH_LEVEL		0xAA
+#define PLATFORM_MIC_DMIC_LOW_LEVEL		0x55
+#define PLATFORM_MIC_AMIC_LIN1RIN1		0xBB
+#define PLATFORM_MIC_AMIC_LIN2RIN2		0xCC
+
+/* Speaker */
+#define PLATFORM_SPK_NONE			0x00
+#define PLATFORM_SPK_MONO			0x01
+#define PLATFORM_SPK_STEREO			0x02
+
+/* Jack Detection */
+#define PLATFORM_HPDET_NORMAL			0x00
+#define PLATFORM_HPDET_INVERTED			0x01
+
+/* PCM type (Port number + protocol) */
+/*
+ * RETURNED VALUE = 0x00,   PCM PORT0, I2S
+ *       0x01,   PCM PORT0, LJ
+ *       0x02,   PCM PORT0, RJ
+ *       0x03,   PCM PORT0, DSP-A
+ *       0x04,   PCM PORT0, DSP-B
+ *       0x10,   PCM PORT1, I2S
+ *       0x11,   PCM PORT1, LJ
+ *       0x12,   PCM PORT1, RJ
+ *       0x13,   PCM PORT1, DSP-A
+ *       0x14,   PCM PORT1, DSP-B
+ *       0xFF,   Use default
+ *
+ * This is not used in Linux (defined by topology) and in
+ * Windows it's always DSP-A
+ */
+
+/* Depop */
+#define PLATFORM_MIC_DE_POP_OFF			0x00
+#define PLATFORM_MIC_DE_POP_ON			0x01
+
+/* Codec type */
+#define PLATFORM_CODEC_8316			16
+#define PLATFORM_CODEC_8326			26
+#define PLATFORM_CODEC_8336			36
+#define PLATFORM_CODEC_8395			95
+#define PLATFORM_CODEC_8396			96
+
+/* Bus slot (on the host) */
+/* BIT[3:0] FOR BUS NUMBER, BIT[7:4] FOR SLOT NUMBER
+ * BIT[3:0] 0 for I2S0, 1 for IS21, 2 for I2S2.
+ *
+ * On Intel platforms this refers to SSP0..2. This information
+ * is not really useful for Linux, the information is already
+ * inferred from NHLT but can be used to double-check NHLT
+ */
+
+/* Volume - Gain */
+#define LINEIN_GAIN_0db				0x00 /* gain =  0db */
+#define LINEIN_GAIN_3db				0x01 /* gain = +3db */
+#define LINEIN_GAIN_6db				0x02 /* gain = +6db */
+#define LINEIN_GAIN_9db				0x03 /* gain = +9db */
+#define LINEIN_GAIN_12db			0x04 /* gain = +12db */
+#define LINEIN_GAIN_15db			0x05 /* gain = +15db */
+#define LINEIN_GAIN_18db			0x06 /* gain = +18db */
+#define LINEIN_GAIN_21db			0x07 /* gain = +21db */
+#define LINEIN_GAIN_24db			0x08 /* gain = +24db */
+#define LINEIN_GAIN_27db			0x09 /* gain = +27db */
+#define LINEIN_GAIN_30db			0x0a /* gain = +30db */
+
+#define ADC_GUI_STEP_3db			0x03 /* gain = +3db */
+#define ADC_GUI_STEP_6db			0x06 /* gain = +6db */
+#define ADC_GUI_STEP_10db			0x0a /* gain = +10db */
+
+#define D2SEPGA_GAIN_0db			0x00 /* gain =   0db */
+#define D2SEPGA_GAIN_15db			0x01 /* gain = +15db */
+
+/* ADC volume: base = 0db, -0.5db/setp, 0xc0 <-> -96db */
+
+#define ADC_ALC_DISABLE				0x00
+#define ADC_ALC_ENABLE				0x01
+
+#define ADC_ALC_TARGET_LEVEL_m16_5db		0x00 /* gain = -16.5db */
+#define ADC_ALC_TARGET_LEVEL_m15db		0x01 /* gain = -15db */
+#define ADC_ALC_TARGET_LEVEL_m13_5db		0x02 /* gain = -13.5db */
+#define ADC_ALC_TARGET_LEVEL_m12db		0x03 /* gain = -12db */
+#define ADC_ALC_TARGET_LEVEL_m10_5db		0x04 /* gain = -10.5db */
+#define ADC_ALC_TARGET_LEVEL_m9db		0x05 /* gain = -9db */
+#define ADC_ALC_TARGET_LEVEL_m7_5db		0x06 /* gain = -7.5db */
+#define ADC_ALC_TARGET_LEVEL_m6db		0x07 /* gain = -6db */
+#define ADC_ALC_TARGET_LEVEL_m4_5db		0x08 /* gain = -4.5db */
+#define ADC_ALC_TARGET_LEVEL_m_3db		0x09 /* gain = -3db */
+#define ADC_ALC_TARGET_LEVEL_m1_5db		0x0a /* gain = -1.5db */
+
+#define ADC_ALC_MAXGAIN_m6_5db			0x00  /* gain = -6.5db */
+#define ADC_ALC_MAXGAIN_m5db			0x01  /* gain = -5db */
+#define ADC_ALC_MAXGAIN_m3_5db			0x02  /* gain = -3.5db */
+#define ADC_ALC_MAXGAIN_m2db			0x03  /* gain = -2db */
+#define ADC_ALC_MAXGAIN_m0_5db			0x04  /* gain = -0.5db */
+#define ADC_ALC_MAXGAIN_1db			0x05  /* gain = +1db */
+#define ADC_ALC_MAXGAIN_2_5db			0x06  /* gain = +2.5db */
+#define ADC_ALC_MAXGAIN_4db			0x07  /* gain = +4db */
+#define ADC_ALC_MAXGAIN_5_5db			0x08  /* gain = +5.5db */
+#define ADC_ALC_MAXGAIN_7db			0x09  /* gain = +7db */
+#define ADC_ALC_MAXGAIN_8_5db			0x0a  /* gain = +8.5db */
+#define ADC_ALC_MAXGAIN_10db			0x0b  /* gain = +10db */
+#define ADC_ALC_MAXGAIN_11_5db			0x0c  /* gain = +11.5db */
+#define ADC_ALC_MAXGAIN_13db			0x0d  /* gain = +13db */
+#define ADC_ALC_MAXGAIN_14_5db			0x0e  /* gain = +14.5db */
+#define ADC_ALC_MAXGAIN_16db			0x0f  /* gain = +16db */
+#define ADC_ALC_MAXGAIN_17_5db			0x10  /* gain = +17.5db */
+#define ADC_ALC_MAXGAIN_19db			0x11  /* gain = +19db */
+#define ADC_ALC_MAXGAIN_20_5db			0x12  /* gain = +20.5db */
+#define ADC_ALC_MAXGAIN_22db			0x13  /* gain = +22db */
+#define ADC_ALC_MAXGAIN_23_5db			0x14  /* gain = +23.5db */
+#define ADC_ALC_MAXGAIN_25db			0x15  /* gain = +25db */
+#define ADC_ALC_MAXGAIN_26_5db			0x16  /* gain = +26.5db */
+#define ADC_ALC_MAXGAIN_28db			0x17  /* gain = +28db */
+#define ADC_ALC_MAXGAIN_29_5db			0x18  /* gain = +29.5db */
+#define ADC_ALC_MAXGAIN_31db			0x19  /* gain = +31db */
+#define ADC_ALC_MAXGAIN_32_5db			0x1a  /* gain = +32.5db */
+#define ADC_ALC_MAXGAIN_34db			0x1b  /* gain = +34db */
+#define ADC_ALC_MAXGAIN_35_5db			0x1c  /* gain = +35.5db */
+
+#define ADC_ALC_MINGAIN_m12db			0x00 /* gain = -12db */
+#define ADC_ALC_MINGAIN_m10_5db			0x01 /* gain = -10.5db */
+#define ADC_ALC_MINGAIN_m9db			0x02 /* gain = -9db */
+#define ADC_ALC_MINGAIN_m7_5db			0x03 /* gain = -7.5db */
+#define ADC_ALC_MINGAIN_m6db			0x04 /* gain = -6db */
+#define ADC_ALC_MINGAIN_m4_51db			0x05 /* gain = -4.51db */
+#define ADC_ALC_MINGAIN_m3db			0x06 /* gain = -3db */
+#define ADC_ALC_MINGAIN_m1_5db			0x07 /* gain = -1.5db */
+#define ADC_ALC_MINGAIN_0db			0x08 /* gain = 0db */
+#define ADC_ALC_MINGAIN_1_5db			0x09 /* gain = +1.5db */
+#define ADC_ALC_MINGAIN_3db			0x0a /* gain = +3db */
+#define ADC_ALC_MINGAIN_4_5db			0x0b /* gain = +4.5db */
+#define ADC_ALC_MINGAIN_6db			0x0c /* gain = +6db */
+#define ADC_ALC_MINGAIN_7_5db			0x0d /* gain = +7.5db */
+#define ADC_ALC_MINGAIN_9db			0x0e /* gain = +9db */
+#define ADC_ALC_MINGAIN_10_5db			0x0f /* gain = +10.5db */
+#define ADC_ALC_MINGAIN_12db			0x10 /* gain = +12db */
+#define ADC_ALC_MINGAIN_13_5db			0x11 /* gain = +13.5db */
+#define ADC_ALC_MINGAIN_15db			0x12 /* gain = +15db */
+#define ADC_ALC_MINGAIN_16_5db			0x13 /* gain = +16.5db */
+#define ADC_ALC_MINGAIN_18db			0x14 /* gain = +18db */
+#define ADC_ALC_MINGAIN_19_5db			0x15 /* gain = +19.5db */
+#define ADC_ALC_MINGAIN_21db			0x16 /* gain = +21db */
+#define ADC_ALC_MINGAIN_22_5db			0x17 /* gain = +22.5db */
+#define ADC_ALC_MINGAIN_24db			0x18 /* gain = +24db */
+#define ADC_ALC_MINGAIN_25_5db			0x19 /* gain = +25.5db */
+#define ADC_ALC_MINGAIN_27db			0x1a /* gain = +27db */
+#define ADC_ALC_MINGAIN_28_5db			0x1b /* gain = +28.5db */
+#define ADC_ALC_MINGAIN_30db			0x1c /* gain = +30db */
+
+/* ADC volume: step 1dB */
+
+/* ALC Hold, Decay, Attack */
+#define ADC_ALC_HLDTIME_0_US			0x00
+#define ADC_ALC_HLDTIME_0000266_US		0x01 //time = 2.67ms
+#define ADC_ALC_HLDTIME_0000533_US		0x02 //time = 5.33ms
+#define ADC_ALC_HLDTIME_0001066_US		0x03 //time = 10.66ms
+#define ADC_ALC_HLDTIME_0002132_US		0x04 //time = 21.32ms
+#define ADC_ALC_HLDTIME_0004264_US		0x05 //time = 42.64ms
+#define ADC_ALC_HLDTIME_0008538_US		0x06 //time = 85.38ms
+#define ADC_ALC_HLDTIME_0017076_US		0x07 //time = 170.76ms
+#define ADC_ALC_HLDTIME_0034152_US		0x08 //time = 341.52ms
+#define ADC_ALC_HLDTIME_0680000_US		0x09 //time = 0.68s
+#define ADC_ALC_HLDTIME_1360000_US		0x0a //time = 1.36s
+
+#define ADC_ALC_DCYTIME_000410_US		0x00 //time = 410us
+#define ADC_ALC_DCYTIME_000820_US		0x01 //time = 820us
+#define ADC_ALC_DCYTIME_001640_US		0x02 //time = 1.64ms
+#define ADC_ALC_DCYTIME_003280_US		0x03 //time = 3.28ms
+#define ADC_ALC_DCYTIME_006560_US		0x04 //time = 6.56ms
+#define ADC_ALC_DCYTIME_013120_US		0x05 //time = 13.12ms
+#define ADC_ALC_DCYTIME_026240_US		0x06 //time = 26.24ms
+#define ADC_ALC_DCYTIME_058480_US		0x07 //time = 52.48ms
+#define ADC_ALC_DCYTIME_104960_US		0x08 //time = 104.96ms
+#define ADC_ALC_DCYTIME_209920_US		0x09 //time = 209.92ms
+#define ADC_ALC_DCYTIME_420000_US		0x0a //time = 420ms
+
+#define ADC_ALC_ATKTIME_000104_US		0x00 //time = 104us
+#define ADC_ALC_ATKTIME_000208_US		0x01 //time = 208us
+#define ADC_ALC_ATKTIME_000416_US		0x02 //time = 416ms
+#define ADC_ALC_ATKTIME_003832_US		0x03 //time = 832ms
+#define ADC_ALC_ATKTIME_001664_US		0x04 //time = 1.664ms
+#define ADC_ALC_ATKTIME_003328_US		0x05 //time = 3.328ms
+#define ADC_ALC_ATKTIME_006656_US		0x06 //time = 6.656ms
+#define ADC_ALC_ATKTIME_013312_US		0x07 //time = 13.312ms
+#define ADC_ALC_ATKTIME_026624_US		0x08 //time = 26.624ms
+#define ADC_ALC_ATKTIME_053248_US		0x09 //time = 53.248ms
+#define ADC_ALC_ATKTIME_106496_US		0x0a //time = 106.496ms
+
+/* ALC Noise Gate */
+#define ADC_ALC_NGTYPE_DISABLE			0x00 //noise gate disable
+#define ADC_ALC_NGTYPE_ENABLE_HOLD		0x01 //noise gate enable, hold gain type
+#define ADC_ALC_NGTYPE_ENABLE_MUTE		0x03 //noise gate enable, mute type
+
+#define ADC_ALC_NGTHLD_m76_5db			0x00 /* Threshold = -76.5db */
+#define ADC_ALC_NGTHLD_m75db			0x01 /* Threshold = -75db   */
+#define ADC_ALC_NGTHLD_m73_5db			0x02 /* Threshold = -73.5db */
+#define ADC_ALC_NGTHLD_m72db			0x03 /* Threshold = -72db   */
+#define ADC_ALC_NGTHLD_m70_5db			0x04 /* Threshold = -70.5db */
+#define ADC_ALC_NGTHLD_m69db			0x05 /* Threshold = -69db   */
+#define ADC_ALC_NGTHLD_m67_5db			0x06 /* Threshold = -67.5db */
+#define ADC_ALC_NGTHLD_m66db			0x07 /* Threshold = -66db   */
+#define ADC_ALC_NGTHLD_m64_5db			0x08 /* Threshold = -64.5db */
+#define ADC_ALC_NGTHLD_m63db			0x09 /* Threshold = -63db   */
+#define ADC_ALC_NGTHLD_m61_5db			0x0a /* Threshold = -61.5db */
+#define ADC_ALC_NGTHLD_m60db			0x0b /* Threshold = -60db   */
+#define ADC_ALC_NGTHLD_m58_5db			0x0c /* Threshold = -58.5db */
+#define ADC_ALC_NGTHLD_m57db			0x0d /* Threshold = -57db   */
+#define ADC_ALC_NGTHLD_m55_5db			0x0e /* Threshold = -55.5db */
+#define ADC_ALC_NGTHLD_m54db			0x0f /* Threshold = -54db   */
+#define ADC_ALC_NGTHLD_m52_5db			0x10 /* Threshold = -52.5db */
+#define ADC_ALC_NGTHLD_m51db			0x11 /* Threshold = -51db   */
+#define ADC_ALC_NGTHLD_m49_5db			0x12 /* Threshold = -49.5db */
+#define ADC_ALC_NGTHLD_m48db			0x13 /* Threshold = -48db   */
+#define ADC_ALC_NGTHLD_m46_5db			0x14 /* Threshold = -46.5db */
+#define ADC_ALC_NGTHLD_m45db			0x15 /* Threshold = -45db   */
+#define ADC_ALC_NGTHLD_m43_5db			0x16 /* Threshold = -43.5db */
+#define ADC_ALC_NGTHLD_m42db			0x17 /* Threshold = -42db   */
+#define ADC_ALC_NGTHLD_m40_5db			0x18 /* Threshold = -40.5db */
+#define ADC_ALC_NGTHLD_m39db			0x19 /* Threshold = -39db   */
+#define ADC_ALC_NGTHLD_m37_5db			0x1a /* Threshold = -37.5db */
+#define ADC_ALC_NGTHLD_m36db			0x1b /* Threshold = -36db   */
+#define ADC_ALC_NGTHLD_m34_5db			0x1c /* Threshold = -34.5db */
+#define ADC_ALC_NGTHLD_m33db			0x1d /* Threshold = -33db   */
+#define ADC_ALC_NGTHLD_m31_5db			0x1e /* Threshold = -31.5db */
+#define ADC_ALC_NGTHLD_m30db			0x1f /* Threshold = -30db   */
+
+/* Headphone dummy - Windows Specific flag, not needed for Linux */
+
+/* HPMIX HIGAIN and VOLUME */
+#define DAC_HPMIX_HIGAIN_0db			0x00 /* gain =  0db      */
+#define DAC_HPMIX_HIGAIN_m6db			0x88 /* gain = -6db      */
+
+#define DAC_HPMIX_VOLUME_m12db			0x00 /* volume = -12db   */
+#define DAC_HPMIX_VOLUME_m10_5db		0x11 /* volume = -10.5db */
+#define DAC_HPMIX_VOLUME_m9db			0x22 /* volume = -9db    */
+#define DAC_HPMIX_VOLUME_m7_5db			0x33 /* volume = -7.5db  */
+#define DAC_HPMIX_VOLUME_m6db			0x44 /* volume = -6db    */
+#define DAC_HPMIX_VOLUME_m4_5db			0x88 /* volume = -4.5db  */
+#define DAC_HPMIX_VOLUME_m3db			0x99 /* volume = -3db    */
+#define DAC_HPMIX_VOLUME_m1_5db			0xaa /* volume = -1.5db  */
+#define DAC_HPMIX_VOLUME_0db			0xbb /* volume =  0db    */
+
+/* HPOUT VOLUME */
+#define DAC_HPOUT_VOLUME_0db			0x00 /* volume =   0db   */
+#define DAC_HPOUT_VOLUME_m12db			0x11 /* volume = -12db   */
+#define DAC_HPOUT_VOLUME_m24db			0x22 /* volume = -24db   */
+#define DAC_HPOUT_VOLUME_m48db			0x33 /* volume = -48db   */
+
+/* LDAC/RDAC volume = 0db, -0.5db/setp, 0xc0 <-> -96db */
+
+/* Automute */
+#define DAC_AUTOMUTE_NONE			0x00 /* no automute  */
+#define DAC_AUTOMUTE_DIGITAL			0x01 /* digital mute */
+#define DAC_AUTOMUTE_ANALOG			0x02 /* analog mute  */
+
+/* Mono - Windows specific, on Linux the information comes from DAI/topology */
+#define HEADPHONE_MONO                          0x01 /* on channel */
+#define HEADPHONE_STEREO                        0x00 /* stereo */
+
+/* Speaker and headphone GPIO control */
+#define GPIO_CTL_IO_LEVEL_LOW			0x00 /* low level enable */
+#define GPIO_CTL_IO_LEVEL_HIGH			0x01 /* high level enable */
+
+/* GPIO */
+/* FIXME: for ES8396, no need to use */
+
+/* Platform clocks */
+/*
+ * BCLK AND MCLK FREQ
+ * BIT[7:4] MCLK FREQ
+ * 0 - 19.2MHz
+ * 1 - 24MHz
+ * 2 - 12.288MHz
+ * F - Default for 19.2MHz
+ *
+ * BIT[3:0] BCLK FREQ
+ * 0 - 4.8MHz
+ * 1 - 2.4MHz
+ * 2 - 2.304MHz
+ * 3 - 3.072MHz
+ * 4 - 4.096MHz
+ * F - Default for 4.8MHz
+ */
+
+#if IS_ENABLED(CONFIG_ACPI)
+void es83xx_dsm_dump(struct device *dev);
+int es83xx_dsm_jack_inverted(struct device *dev);
+int es83xx_dsm_is_gpio_level_low(struct device *dev, bool is_spk);
+int es83xx_dsm_mic_type(struct device *dev, bool is_main);
+
+#else
+static inline void es83xx_dsm_dump(struct device *dev) {};
+static inline int es83xx_dsm_jack_inverted(struct device *dev) { return 0; }
+static inline int es83xx_dsm_is_gpio_level_low(struct device *dev, bool is_spk) { return 0; }
+static inline int es83xx_dsm_mic_type(struct device *dev, bool is_main) { return 0; }
+#endif
+
+#endif
-- 
2.39.2

