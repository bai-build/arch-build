diff --git a/Makefile.am b/Makefile.am
index 9ee3fae..06ddb75 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -56,7 +56,7 @@ EXTRA_mutt_SOURCES = account.c bcache.c crypt-gpgme.c crypt-mod-pgp-classic.c \
 	mutt_idna.c mutt_sasl.c mutt_socket.c mutt_ssl.c mutt_ssl_gnutls.c \
 	mutt_tunnel.c pgp.c pgpinvoke.c pgpkey.c pgplib.c pgpmicalg.c \
 	pgppacket.c pop.c pop_auth.c pop_lib.c remailer.c resize.c sha1.c \
-	smime.c smtp.c utf8.c wcwidth.c \
+	sidebar.c smime.c smtp.c utf8.c wcwidth.c \
 	bcache.h browser.h hcache.h mbyte.h mutt_idna.h remailer.h url.h
 
 EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
@@ -71,7 +71,7 @@ EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO UPDATING \
 	mbyte.h lib.h extlib.c pgpewrap.c smime_keys.pl pgplib.h \
 	README.SSL smime.h group.h \
 	muttbug pgppacket.h depcomp ascii.h BEWARE PATCHES patchlist.sh \
-	ChangeLog mkchangelog.sh mutt_idna.h \
+	ChangeLog mkchangelog.sh mutt_idna.h sidebar.h OPS.SIDEBAR \
 	snprintf.c regex.c crypt-gpgme.h hcachever.sh.in sys_socket.h \
 	txt2c.c txt2c.sh version.sh check_sec.sh
 
@@ -129,9 +129,9 @@ smime_keys: $(srcdir)/smime_keys.pl
 keymap_defs.h: $(OPS) $(srcdir)/gen_defs
 	$(srcdir)/gen_defs $(OPS) > keymap_defs.h
 
-keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
+keymap_alldefs.h: $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP $(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME $(srcdir)/gen_defs
 	rm -f $@
-	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.PGP \
+	$(srcdir)/gen_defs $(srcdir)/OPS $(srcdir)/OPS.SIDEBAR $(srcdir)/OPS.PGP \
 		$(srcdir)/OPS.MIX $(srcdir)/OPS.CRYPT $(srcdir)/OPS.SMIME \
 			> keymap_alldefs.h
 
diff --git a/OPS.MIX b/OPS.MIX
index 4988333..a836226 100644
--- a/OPS.MIX
+++ b/OPS.MIX
@@ -1,7 +1,7 @@
-OP_MIX_USE "Accept the chain constructed"
-OP_MIX_APPEND "Append a remailer to the chain"
-OP_MIX_INSERT "Insert a remailer into the chain"
-OP_MIX_DELETE "Delete a remailer from the chain"
-OP_MIX_CHAIN_PREV "Select the previous element of the chain"
-OP_MIX_CHAIN_NEXT "Select the next element of the chain"
+OP_MIX_USE "accept the chain constructed"
+OP_MIX_APPEND "append a remailer to the chain"
+OP_MIX_INSERT "insert a remailer into the chain"
+OP_MIX_DELETE "delete a remailer from the chain"
+OP_MIX_CHAIN_PREV "select the previous element of the chain"
+OP_MIX_CHAIN_NEXT "select the next element of the chain"
 OP_COMPOSE_MIX "send the message through a mixmaster remailer chain"
diff --git a/OPS.SIDEBAR b/OPS.SIDEBAR
new file mode 100644
index 0000000..7e5b504
--- /dev/null
+++ b/OPS.SIDEBAR
@@ -0,0 +1,8 @@
+OP_SIDEBAR_NEXT "move the highlight to next mailbox"
+OP_SIDEBAR_NEXT_NEW "move the highlight to next mailbox with new mail"
+OP_SIDEBAR_OPEN "open highlighted mailbox"
+OP_SIDEBAR_PAGE_DOWN "scroll the sidebar down 1 page"
+OP_SIDEBAR_PAGE_UP "scroll the sidebar up 1 page"
+OP_SIDEBAR_PREV "move the highlight to previous mailbox"
+OP_SIDEBAR_PREV_NEW "move the highlight to previous mailbox with new mail"
+OP_SIDEBAR_TOGGLE_VISIBLE "make the sidebar (in)visible"
diff --git a/PATCHES b/PATCHES
index e69de29..48f5b48 100644
--- a/PATCHES
+++ b/PATCHES
@@ -0,0 +1 @@
+patch-sidebar-neo-git
diff --git a/README.sidebar b/README.sidebar
new file mode 100644
index 0000000..53f56c1
--- /dev/null
+++ b/README.sidebar
@@ -0,0 +1,145 @@
+Sidebar Patch
+=============
+
+    Overview of mailboxes
+
+    NOTES:
+
+    If you haven't used the sidebar before, you might like to read the
+    Sidebar Introduction:
+
+        http://www.neomutt.org/sidebar-intro.html
+
+    If you have used an older version of the Sidebar, please note that some
+    of the configuration has changed.
+
+        http://www.neomutt.org/sidebar-intro.html#intro-sidebar-config-changes
+
+Patch
+-----
+
+    To check if Mutt supports "Sidebar", look for "+USE_SIDEBAR" in the mutt
+    version.
+
+    Dependencies
+    * mutt-1.6.1
+
+Introduction
+------------
+
+    The Sidebar shows a list of all your mailboxes. The list can be turned on
+    and off, it can be themed and the list style can be configured.
+
+    This part of the manual is a reference guide. If you want a simple
+    introduction with examples see the Sidebar Howto. If you just want to get
+    started, you could use the sample Sidebar muttrc.
+
+    This version of Sidebar is based on Terry Chan's [2015-11-11
+    release](http://www.lunar-linux.org/mutt-sidebar/). It contains many new
+    features, lots of bugfixes.
+
+Variables
+---------
+
+    Sidebar Variables
+
+    | Name                    | Type    | Default                     |
+    |-------------------------|---------|-----------------------------|
+    | 'sidebar_delim_chars'   | string  | '/.'                        |
+    | 'sidebar_divider_char'  | string  | '|'                         |
+    | 'sidebar_folder_indent' | boolean | 'no'                        |
+    | 'sidebar_format'        | string  | '%B%?F? [%F]?%* %?N?%N/?%S' |
+    | 'sidebar_indent_string' | string  | '  ' (two spaces)           |
+    | 'sidebar_new_mail_only' | boolean | 'no'                        |
+    | 'sidebar_next_new_wrap' | boolean | 'no'                        |
+    | 'sidebar_refresh_time'  | number  | '60'                        |
+    | 'sidebar_short_path'    | boolean | 'no'                        |
+    | 'sidebar_sort_method'   | enum    | 'SORT_ORDER'                |
+    | 'sidebar_visible'       | boolean | 'no'                        |
+    | 'sidebar_whitelist'     | list    | (empty)                     |
+    | 'sidebar_width'         | number  | '20'                        |
+
+Functions
+---------
+
+    Sidebar Functions
+
+    Sidebar adds the following functions to Mutt. By default, none of them are
+    bound to keys.
+
+    | Menus       | Function                   | Description                                          |
+    |-------------|----------------------------|------------------------------------------------------|
+    | index,pager | '<sidebar-next>'           | Move the highlight to next mailbox                   |
+    | index,pager | '<sidebar-next-new>'       | Move the highlight to next mailbox with new mail     |
+    | index,pager | '<sidebar-open>'           | Open highlighted mailbox                             |
+    | index,pager | '<sidebar-page-down>'      | Scroll the Sidebar down 1 page                       |
+    | index,pager | '<sidebar-page-up>'        | Scroll the Sidebar up 1 page                         |
+    | index,pager | '<sidebar-prev>'           | Move the highlight to previous mailbox               |
+    | index,pager | '<sidebar-prev-new>'       | Move the highlight to previous mailbox with new mail |
+    | index,pager | '<sidebar-toggle-visible>' | Make the Sidebar (in)visible                         |
+
+Commands
+--------
+
+        sidebar_whitelist mailbox [ mailbox... ]
+
+Colors
+------
+
+    Sidebar Colors
+
+    | Name                | Default Color    | Description                                                      |
+    |---------------------|------------------|------------------------------------------------------------------|
+    | 'sidebar_divider'   | default          | The dividing line between the Sidebar and the Index/Pager panels |
+    | 'sidebar_flagged'   | default          | Mailboxes containing flagged mail                                |
+    | 'sidebar_highlight' | underline        | Cursor to select a mailbox                                       |
+    | 'sidebar_indicator' | mutt 'indicator' | The mailbox open in the Index panel                              |
+    | 'sidebar_new'       | default          | Mailboxes containing new mail                                    |
+    | 'sidebar_spoolfile' | default          | Mailbox that receives incoming mail                              |
+
+    If the sidebar_indicator color isn't set, then the default Mutt indicator
+    color will be used (the color used in the index panel).
+
+Sort
+----
+
+    Sidebar Sort
+
+    | Sort       | Description                |
+    |------------|----------------------------|
+    | 'alpha'    | Alphabetically by path     |
+    | 'count'    | Total number of messages   |
+    | 'flagged'  | Number of flagged messages |
+    | 'name'     | Alphabetically by path     |
+    | 'new'      | Number of new messages     |
+    | 'path'     | Alphabetically by path     |
+    | 'unsorted' | Do not resort the paths    |
+
+See Also
+--------
+
+    * Regular Expressions
+    * Patterns
+    * Color command
+    * notmuch patch
+
+Known Bugs
+----------
+
+    Unsorted isn't
+
+Credits
+-------
+
+    * Justin Hibbits <jrh29@po.cwru.edu>
+    * Thomer M. Gil <mutt@thomer.com>
+    * David Sterba <dsterba@suse.cz>
+    * Evgeni Golov <evgeni@debian.org>
+    * Fabian Groffen <grobian@gentoo.org>
+    * Jason DeTiberus <jdetiber@redhat.com>
+    * Stefan Assmann <sassmann@kpanic.de>
+    * Steve Kemp <steve@steve.org.uk>
+    * Terry Chan <tchan@lunar-linux.org>
+    * Tyler Earnest <tylere@rne.st>
+    * Richard Russon <rich@flatcap.org>
+
diff --git a/addrbook.c b/addrbook.c
index 8767a00..345fe87 100644
--- a/addrbook.c
+++ b/addrbook.c
@@ -24,6 +24,7 @@
 #include "mutt_menu.h"
 #include "mapping.h"
 #include "sort.h"
+#include "mutt_curses.h"
 
 #include "mutt_idna.h"
 
@@ -43,7 +44,7 @@ static const struct mapping_t AliasHelp[] = {
 };
 
 static const char *
-alias_format_str (char *dest, size_t destlen, size_t col, char op, const char *src,
+alias_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
 		  const char *fmt, const char *ifstring, const char *elsestring,
 		  unsigned long data, format_flag flags)
 {
@@ -80,7 +81,7 @@ alias_format_str (char *dest, size_t destlen, size_t col, char op, const char *s
 
 static void alias_entry (char *s, size_t slen, MUTTMENU *m, int num)
 {
-  mutt_FormatString (s, slen, 0, NONULL (AliasFmt), alias_format_str, (unsigned long) ((ALIAS **) m->data)[num], M_FORMAT_ARROWCURSOR);
+  mutt_FormatString (s, slen, 0, COLS - SidebarWidth, NONULL (AliasFmt), alias_format_str, (unsigned long) ((ALIAS **) m->data)[num], M_FORMAT_ARROWCURSOR);
 }
 
 static int alias_tag (MUTTMENU *menu, int n, int m)
diff --git a/browser.c b/browser.c
index 46919a0..11980e5 100644
--- a/browser.c
+++ b/browser.c
@@ -142,7 +142,7 @@ static int link_is_dir (const char *folder, const char *path)
 }
 
 static const char *
-folder_format_str (char *dest, size_t destlen, size_t col, char op, const char *src,
+folder_format_str (char *dest, size_t destlen, size_t col, int cols, char op, const char *src,
 		   const char *fmt, const char *ifstring, const char *elsestring,
 		   unsigned long data, format_flag flags)
 {
@@ -317,9 +317,9 @@ folder_format_str (char *dest, size_t destlen, size_t col, char op, const char *
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, folder_format_str, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, folder_format_str, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, folder_format_str, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, folder_format_str, data, 0);
 
   return (src);
 }
@@ -515,7 +515,7 @@ static void folder_entry (char *s, size_t slen, MUTTMENU *menu, int num)
   folder.ff = &((struct folder_file *) menu->data)[num];
   folder.num = num;
   
-  mutt_FormatString (s, slen, 0, NONULL(FolderFormat), folder_format_str, 
+  mutt_FormatString (s, slen, 0, COLS - SidebarWidth, NONULL(FolderFormat), folder_format_str, 
       (unsigned long) &folder, M_FORMAT_ARROWCURSOR);
 }
 
diff --git a/buffy.c b/buffy.c
index c713d16..4ae879e 100644
--- a/buffy.c
+++ b/buffy.c
@@ -27,6 +27,10 @@
 
 #include "mutt_curses.h"
 
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
+
 #ifdef USE_IMAP
 #include "imap.h"
 #endif
@@ -41,6 +45,7 @@
 #include <stdio.h>
 
 static time_t BuffyTime = 0;	/* last time we started checking for mail */
+static time_t BuffyStatsTime = 0; /* last time we check performed mail_check_stats */
 time_t BuffyDoneTime = 0;	/* last time we knew for sure how much mail there was. */
 static short BuffyCount = 0;	/* how many boxes with new mail */
 static short BuffyNotify = 0;	/* # of unnotified new boxes */
@@ -196,9 +201,13 @@ void mutt_update_mailbox (BUFFY * b)
 static BUFFY *buffy_new (const char *path)
 {
   BUFFY* buffy;
+  char rp[PATH_MAX] = "";
+  char *r = NULL;
 
   buffy = (BUFFY *) safe_calloc (1, sizeof (BUFFY));
   strfcpy (buffy->path, path, sizeof (buffy->path));
+  r = realpath (path, rp);
+  strfcpy (buffy->realpath, r ? rp : path, sizeof (buffy->realpath));
   buffy->next = NULL;
   buffy->magic = 0;
 
@@ -215,8 +224,8 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
   BUFFY **tmp,*tmp1;
   char buf[_POSIX_PATH_MAX];
   struct stat sb;
-  char f1[PATH_MAX], f2[PATH_MAX];
-  char *p, *q;
+  char f1[PATH_MAX];
+  char *p;
 
   while (MoreArgs (s))
   {
@@ -228,6 +237,9 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
       for (tmp = &Incoming; *tmp;)
       {
         tmp1=(*tmp)->next;
+#ifdef USE_SIDEBAR
+	mutt_sb_notify_mailbox (*tmp, 0);
+#endif
         buffy_free (tmp);
         *tmp=tmp1;
       }
@@ -243,8 +255,7 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
     p = realpath (buf, f1);
     for (tmp = &Incoming; *tmp; tmp = &((*tmp)->next))
     {
-      q = realpath ((*tmp)->path, f2);
-      if (mutt_strcmp (p ? p : buf, q ? q : (*tmp)->path) == 0)
+      if (mutt_strcmp (p ? p : buf, (*tmp)->realpath) == 0)
       {
 	dprint(3,(debugfile,"mailbox '%s' already registered as '%s'\n", buf, (*tmp)->path));
 	break;
@@ -256,14 +267,21 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
       if(*tmp)
       {
         tmp1=(*tmp)->next;
+#ifdef USE_SIDEBAR
+	mutt_sb_notify_mailbox (*tmp, 0);
+#endif
         buffy_free (tmp);
         *tmp=tmp1;
       }
       continue;
     }
 
-    if (!*tmp)
+    if (!*tmp) {
       *tmp = buffy_new (buf);
+#ifdef USE_SIDEBAR
+      mutt_sb_notify_mailbox (*tmp, 1);
+#endif
+    }
 
     (*tmp)->new = 0;
     (*tmp)->notified = 1;
@@ -285,10 +303,16 @@ int mutt_parse_mailboxes (BUFFER *path, BUFFER *s, unsigned long data, BUFFER *e
   return 0;
 }
 
-/* returns 1 if the specified dir (cur or new) has new mail */
-static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
+/* Checks the specified maildir subdir (cur or new) for new mail or mail counts.
+ * check_new:   if true, check for new mail.
+ * check_stats: if true, count total, new, and flagged mesages.
+ * Returns 1 if the dir has new mail.
+ */
+static int buffy_maildir_check_dir (BUFFY* mailbox, const char *dir_name, int check_new,
+                                    int check_stats)
 {
   char path[_POSIX_PATH_MAX];
+  char msgpath[_POSIX_PATH_MAX];
   DIR *dirp;
   struct dirent *de;
   char *p;
@@ -300,12 +324,18 @@ static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
   /* when $mail_check_recent is set, if the new/ directory hasn't been modified since
    * the user last exited the mailbox, then we know there is no recent mail.
    */
-  if (option(OPTMAILCHECKRECENT))
+  if (check_new && option(OPTMAILCHECKRECENT))
   {
     if (stat(path, &sb) == 0 && sb.st_mtime < mailbox->last_visited)
-      return 0;
+    {
+      rc = 0;
+      check_new = 0;
+    }
   }
 
+  if (! (check_new || check_stats))
+    return rc;
+
   if ((dirp = opendir (path)) == NULL)
   {
     mailbox->magic = 0;
@@ -317,21 +347,35 @@ static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
     if (*de->d_name == '.')
       continue;
 
-    if (!(p = strstr (de->d_name, ":2,")) || !(strchr (p + 3, 'T') || strchr(p + 3, 'S')))
+    p = strstr (de->d_name, ":2,");
+    if (p && strchr (p + 3, 'T'))
+      continue;
+
+    if (check_stats)
     {
-      if (option(OPTMAILCHECKRECENT))
+      mailbox->msg_count++;
+      if (p && strchr (p + 3, 'F'))
+        mailbox->msg_flagged++;
+    }
+    if (!p || !strchr (p + 3, 'S'))
+    {
+      if (check_stats)
+        mailbox->msg_unread++;
+      if (check_new)
       {
-	char msgpath[_POSIX_PATH_MAX];
-
-	snprintf(msgpath, sizeof(msgpath), "%s/%s", path, de->d_name);
-	/* ensure this message was received since leaving this mailbox */
-	if (stat(msgpath, &sb) == 0 && (sb.st_ctime <= mailbox->last_visited))
-	  continue;
+        if (option(OPTMAILCHECKRECENT))
+        {
+          snprintf(msgpath, sizeof(msgpath), "%s/%s", path, de->d_name);
+          /* ensure this message was received since leaving this mailbox */
+          if (stat(msgpath, &sb) == 0 && (sb.st_ctime <= mailbox->last_visited))
+            continue;
+        }
+        mailbox->new = 1;
+        rc = 1;
+        check_new = 0;
+        if (!check_stats)
+          break;
       }
-      /* one new and undeleted message is enough */
-      mailbox->new = 1;
-      rc = 1;
-      break;
     }
   }
 
@@ -340,35 +384,48 @@ static int buffy_maildir_dir_hasnew(BUFFY* mailbox, const char *dir_name)
   return rc;
 }
 
-/* returns 1 if maildir has new mail */
-static int buffy_maildir_hasnew (BUFFY* mailbox)
+/* Checks new mail for a maildir mailbox.
+ * check_stats: if true, also count total, new, and flagged mesages.
+ * Returns 1 if the mailbox has new mail.
+ */
+static int buffy_maildir_check (BUFFY* mailbox, int check_stats)
 {
-  if (buffy_maildir_dir_hasnew(mailbox, "new")) {
-      return 1;
-  }
+  int rc, check_new = 1;
 
-  if (!option(OPTMAILDIRCHECKCUR)) {
-      return 0;
+  if (check_stats)
+  {
+    mailbox->msg_count   = 0;
+    mailbox->msg_unread  = 0;
+    mailbox->msg_flagged = 0;
   }
 
-  if (buffy_maildir_dir_hasnew(mailbox, "cur")) {
-      return 1;
-  }
+  rc = buffy_maildir_check_dir (mailbox, "new", check_new, check_stats);
 
-  return 0;
+  check_new = !rc && option (OPTMAILDIRCHECKCUR);
+  if (check_new || check_stats)
+    if (buffy_maildir_check_dir (mailbox, "cur", check_new, check_stats))
+      rc = 1;
+
+  return rc;
 }
-/* returns 1 if mailbox has new mail */ 
-static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
+
+/* Checks new mail for an mbox mailbox
+ * check_stats: if true, also count total, new, and flagged mesages.
+ * Returns 1 if the mailbox has new mail.
+ */
+static int buffy_mbox_check (BUFFY* mailbox, struct stat *sb, int check_stats)
 {
   int rc = 0;
-  int statcheck;
+  int new_or_changed;
+  CONTEXT *ctx = NULL;
 
   if (option (OPTCHECKMBOXSIZE))
-    statcheck = sb->st_size > mailbox->size;
+    new_or_changed = sb->st_size > mailbox->size;
   else
-    statcheck = sb->st_mtime > sb->st_atime
+    new_or_changed = sb->st_mtime > sb->st_atime
       || (mailbox->newly_created && sb->st_ctime == sb->st_mtime && sb->st_ctime == sb->st_atime);
-  if (statcheck)
+
+  if (new_or_changed)
   {
     if (!option(OPTMAILCHECKRECENT) || sb->st_mtime > mailbox->last_visited)
     {
@@ -381,19 +438,43 @@ static int buffy_mbox_hasnew (BUFFY* mailbox, struct stat *sb)
     /* some other program has deleted mail from the folder */
     mailbox->size = (off_t) sb->st_size;
   }
+
   if (mailbox->newly_created &&
       (sb->st_ctime != sb->st_mtime || sb->st_ctime != sb->st_atime))
     mailbox->newly_created = 0;
 
+  if (check_stats &&
+      (mailbox->stats_last_checked < sb->st_mtime))
+  {
+    if ((ctx = mx_open_mailbox (mailbox->path,
+                                M_READONLY | M_QUIET | M_NOSORT | M_PEEK,
+                                NULL)) != NULL)
+    {
+      mailbox->msg_count       = ctx->msgcount;
+      mailbox->msg_unread      = ctx->unread;
+      mailbox->msg_flagged     = ctx->flagged;
+      mailbox->stats_last_checked = ctx->mtime;
+      mx_close_mailbox (ctx, 0);
+    }
+  }
+
   return rc;
 }
 
+/* Check all Incoming for new mail and total/new/flagged messages
+ * force: if true, ignore BuffyTimeout and check for new mail anyway
+ */
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
   struct stat sb;
   struct stat contex_sb;
   time_t t;
+  int check_stats = 0;
+#ifdef USE_SIDEBAR
+  short orig_new;
+  int orig_count, orig_unread, orig_flagged;
+#endif
 
   sb.st_size=0;
   contex_sb.st_dev=0;
@@ -411,13 +492,20 @@ int mutt_buffy_check (int force)
   t = time (NULL);
   if (!force && (t - BuffyTime < BuffyTimeout))
     return BuffyCount;
- 
+
+  if (option (OPTMAILCHECKSTATS) &&
+      (t - BuffyStatsTime >= BuffyCheckStatsInterval))
+  {
+    check_stats = 1;
+    BuffyStatsTime = t;
+  }
+
   BuffyTime = t;
   BuffyCount = 0;
   BuffyNotify = 0;
 
 #ifdef USE_IMAP
-  BuffyCount += imap_buffy_check (force);
+  BuffyCount += imap_buffy_check (force, check_stats);
 #endif
 
   /* check device ID and serial number instead of comparing paths */
@@ -430,6 +518,13 @@ int mutt_buffy_check (int force)
   
   for (tmp = Incoming; tmp; tmp = tmp->next)
   {
+#ifdef USE_SIDEBAR
+    orig_new = tmp->new;
+    orig_count = tmp->msg_count;
+    orig_unread = tmp->msg_unread;
+    orig_flagged = tmp->msg_flagged;
+#endif
+
     if (tmp->magic != M_IMAP)
     {
       tmp->new = 0;
@@ -459,27 +554,34 @@ int mutt_buffy_check (int force)
     {
       switch (tmp->magic)
       {
-      case M_MBOX:
-      case M_MMDF:
-	if (buffy_mbox_hasnew (tmp, &sb) > 0)
-	  BuffyCount++;
-	break;
-
-      case M_MAILDIR:
-	if (buffy_maildir_hasnew (tmp) > 0)
-	  BuffyCount++;
-	break;
-
-      case M_MH:
-	mh_buffy(tmp);
-	if (tmp->new)
-	  BuffyCount++;
-	break;
+        case M_MBOX:
+        case M_MMDF:
+          if (buffy_mbox_check (tmp, &sb, check_stats) > 0)
+            BuffyCount++;
+          break;
+
+        case M_MAILDIR:
+          if (buffy_maildir_check (tmp, check_stats) > 0)
+            BuffyCount++;
+          break;
+
+        case M_MH:
+          if (mh_buffy (tmp, check_stats) > 0)
+            BuffyCount++;
+          break;
       }
     }
     else if (option(OPTCHECKMBOXSIZE) && Context && Context->path)
       tmp->size = (off_t) sb.st_size;	/* update the size of current folder */
 
+#ifdef USE_SIDEBAR
+    if ((orig_new != tmp->new) ||
+        (orig_count != tmp->msg_count) ||
+        (orig_unread != tmp->msg_unread) ||
+        (orig_flagged != tmp->msg_flagged))
+      SidebarNeedsRedraw = 1;
+#endif
+
     if (!tmp->new)
       tmp->notified = 0;
     else if (!tmp->notified)
diff --git a/buffy.h b/buffy.h
index 9aa8e51..16191f8 100644
--- a/buffy.h
+++ b/buffy.h
@@ -16,6 +16,9 @@
  *     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
 
+#ifndef _BUFFY_H
+#define _BUFFY_H
+
 /*parameter to mutt_parse_mailboxes*/
 #define M_MAILBOXES   1
 #define M_UNMAILBOXES 2 
@@ -23,18 +26,28 @@
 typedef struct buffy_t
 {
   char path[_POSIX_PATH_MAX];
+  char realpath[_POSIX_PATH_MAX]; /* used for duplicate detection, context comparison,
+                                     and the sidebar */
   off_t size;
   struct buffy_t *next;
   short new;			/* mailbox has new mail */
+
+  /* These next three are only set when OPTMAILCHECKSTATS is set */
+  int msg_count;		/* total number of messages */
+  int msg_unread;		/* number of unread messages */
+  int msg_flagged;		/* number of flagged messages */
+
   short notified;		/* user has been notified */
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
   time_t last_visited;		/* time of last exit from this mailbox */
+  time_t stats_last_checked;	/* mtime of mailbox the last time stats where checked. */
 }
 BUFFY;
 
 WHERE BUFFY *Incoming INITVAL (0);
 WHERE short BuffyTimeout INITVAL (3);
+WHERE short BuffyCheckStatsInterval INITVAL (60);
 
 extern time_t BuffyDoneTime;	/* last time we knew for sure how much mail there was */
 
@@ -48,4 +61,6 @@ void mutt_buffy_cleanup (const char *buf, struct stat *st);
 /* mark mailbox just left as already notified */
 void mutt_buffy_setnotified (const char *path);
 
-void mh_buffy (BUFFY *);
+int mh_buffy (BUFFY *, int);
+
+#endif /* _BUFFY_H */
diff --git a/color.c b/color.c
index 6e29603..b542ffd 100644
--- a/color.c
+++ b/color.c
@@ -94,6 +94,14 @@ static const struct mapping_t Fields[] =
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
   { "prompt",		MT_COLOR_PROMPT },
+#ifdef USE_SIDEBAR
+  { "sidebar_divider",	MT_COLOR_DIVIDER },
+  { "sidebar_flagged",	MT_COLOR_FLAGGED },
+  { "sidebar_highlight",MT_COLOR_HIGHLIGHT },
+  { "sidebar_indicator",MT_COLOR_SB_INDICATOR },
+  { "sidebar_new",	MT_COLOR_NEW },
+  { "sidebar_spoolfile",MT_COLOR_SB_SPOOLFILE },
+#endif
   { NULL,		0 }
 };
 
@@ -146,6 +154,9 @@ void ci_start_color (void)
   ColorDefs[MT_COLOR_INDICATOR] = A_REVERSE;
   ColorDefs[MT_COLOR_SEARCH] = A_REVERSE;
   ColorDefs[MT_COLOR_MARKERS] = A_REVERSE;
+#ifdef USE_SIDEBAR
+  ColorDefs[MT_COLOR_HIGHLIGHT] = A_UNDERLINE;
+#endif
   /* special meaning: toggle the relevant attribute */
   ColorDefs[MT_COLOR_BOLD] = 0;
   ColorDefs[MT_COLOR_UNDERLINE] = 0;
diff --git a/compose.c b/compose.c
index 6af817f..0098ab8 100644
--- a/compose.c
+++ b/compose.c
@@ -32,6 +32,9 @@
 #include "mailbox.h"
 #include "sort.h"
 #include "charset.h"
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
 
 #ifdef MIXMASTER
 #include "remailer.h"
@@ -72,7 +75,7 @@ enum
 
 #define HDR_XOFFSET 10
 #define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
-#define W (COLS - HDR_XOFFSET)
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static const char * const Prompts[] =
 {
@@ -99,7 +102,7 @@ static const struct mapping_t ComposeHelp[] = {
 
 static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
-    mutt_FormatString (b, blen, 0, NONULL (AttachFormat), mutt_attach_fmt,
+  mutt_FormatString (b, blen, 0, COLS - SidebarWidth, NONULL (AttachFormat), mutt_attach_fmt,
 	    (unsigned long)(((ATTACHPTR **) menu->data)[num]),
 	    M_FORMAT_STAT_FILE | M_FORMAT_ARROWCURSOR);
 }
@@ -110,7 +113,7 @@ static void snd_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 
 static void redraw_crypt_lines (HEADER *msg)
 {
-  mvaddstr (HDR_CRYPT, 0, "Security: ");
+  mvprintw (HDR_CRYPT, SidebarWidth, TITLE_FMT, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -145,16 +148,16 @@ static void redraw_crypt_lines (HEADER *msg)
       addstr (_(" (OppEnc mode)"));
 
   clrtoeol ();
-  move (HDR_CRYPTINFO, 0);
+  move (HDR_CRYPTINFO, SidebarWidth);
   clrtoeol ();
 
   if ((WithCrypto & APPLICATION_PGP)
       && (msg->security & APPLICATION_PGP) && (msg->security & SIGN))
-    printw ("%s%s", _(" sign as: "), PgpSignAs ? PgpSignAs : _("<default>"));
+    printw (TITLE_FMT "%s", _("sign as: "), PgpSignAs ? PgpSignAs : _("<default>"));
 
   if ((WithCrypto & APPLICATION_SMIME)
       && (msg->security & APPLICATION_SMIME) && (msg->security & SIGN)) {
-      printw ("%s%s", _(" sign as: "), SmimeDefaultKey ? SmimeDefaultKey : _("<default>"));
+      printw (TITLE_FMT "%s", _("sign as: "), SmimeDefaultKey ? SmimeDefaultKey : _("<default>"));
   }
 
   if ((WithCrypto & APPLICATION_SMIME)
@@ -162,7 +165,7 @@ static void redraw_crypt_lines (HEADER *msg)
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-      mvprintw (HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
   }
 }
@@ -175,7 +178,8 @@ static void redraw_mix_line (LIST *chain)
   int c;
   char *t;
 
-  mvaddstr (HDR_MIX, 0,     "     Mix: ");
+  /* L10N: "Mix" refers to the MixMaster chain for anonymous email */
+  mvprintw (HDR_MIX, SidebarWidth, TITLE_FMT, _("Mix: "));
 
   if (!chain)
   {
@@ -190,7 +194,7 @@ static void redraw_mix_line (LIST *chain)
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
     
-    if (c + mutt_strlen (t) + 2 >= COLS)
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -242,20 +246,23 @@ static void draw_envelope_addr (int line, ADDRESS *addr)
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mvprintw (line, 0, TITLE_FMT, Prompts[line - 1]);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
   mutt_paddstr (W, buf);
 }
 
 static void draw_envelope (HEADER *msg, char *fcc)
 {
+#ifdef USE_SIDEBAR
+  mutt_sb_draw();
+#endif
   draw_envelope_addr (HDR_FROM, msg->env->from);
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
-  mvprintw (HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
+  mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
-  mvprintw (HDR_FCC, 0, TITLE_FMT, Prompts[HDR_FCC - 1]);
+  mvprintw (HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC - 1]);
   mutt_paddstr (W, fcc);
 
   if (WithCrypto)
@@ -266,7 +273,7 @@ static void draw_envelope (HEADER *msg, char *fcc)
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mvaddstr (HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   clrtoeol ();
 
   NORMAL_COLOR;
@@ -302,7 +309,7 @@ static int edit_address_list (int line, ADDRESS **addr)
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  move (line, HDR_XOFFSET);
+  move (line, HDR_XOFFSET + SidebarWidth);
   mutt_paddstr (W, buf);
   
   return 0;
@@ -402,7 +409,7 @@ static unsigned long cum_attachs_size (MUTTMENU *menu)
 }
 
 /* prototype for use below */
-static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
+static void compose_status_line (char *buf, size_t buflen, size_t col, int cols, MUTTMENU *menu, 
       const char *p);
 
 /*
@@ -418,7 +425,7 @@ static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU
  */
 
 static const char *
-compose_format_str (char *buf, size_t buflen, size_t col, char op, const char *src,
+compose_format_str (char *buf, size_t buflen, size_t col, int cols, char op, const char *src,
 		   const char *prefix, const char *ifstring,
 		   const char *elsestring,
 		   unsigned long data, format_flag flags)
@@ -461,17 +468,17 @@ compose_format_str (char *buf, size_t buflen, size_t col, char op, const char *s
   }
 
   if (optional)
-    compose_status_line (buf, buflen, col, menu, ifstring);
+    compose_status_line (buf, buflen, col, cols, menu, ifstring);
   else if (flags & M_FORMAT_OPTIONAL)
-    compose_status_line (buf, buflen, col, menu, elsestring);
+    compose_status_line (buf, buflen, col, cols, menu, elsestring);
 
   return (src);
 }
 
-static void compose_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, 
-      const char *p)
+static void compose_status_line (char *buf, size_t buflen, size_t col, int cols,
+                                 MUTTMENU *menu, const char *p)
 {
-  mutt_FormatString (buf, buflen, col, p, compose_format_str, 
+  mutt_FormatString (buf, buflen, col, cols, p, compose_format_str, 
         (unsigned long) menu, 0);
 }
 
@@ -515,7 +522,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
   menu->tag = mutt_tag_attach;
   menu->data = idx;
   menu->help = mutt_compile_help (helpstr, sizeof (helpstr), MENU_COMPOSE, ComposeHelp);
-  
+
   while (loop)
   {
     switch (op = mutt_menuLoop (menu))
@@ -564,7 +571,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  move (HDR_SUBJECT, HDR_XOFFSET);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
 	  else
@@ -582,7 +589,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
-	  move (HDR_FCC, HDR_XOFFSET);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
 	}
@@ -1313,7 +1320,7 @@ int mutt_compose_menu (HEADER *msg,   /* structure for new message */
     /* Draw formatted compose status line */
     if (menu->redraw & REDRAW_STATUS) 
     {
-	compose_status_line (buf, sizeof (buf), 0, menu, NONULL(ComposeFormat));
+	compose_status_line (buf, sizeof (buf), 0, COLS - SidebarWidth, menu, NONULL(ComposeFormat));
 	move(option (OPTSTATUSONTOP) ? 0 : LINES-2, 0);
 	SETCOLOR (MT_COLOR_STATUS);
 	mutt_paddstr (COLS, buf);
diff --git a/configure.ac b/configure.ac
index 6096dbb..df29887 100644
--- a/configure.ac
+++ b/configure.ac
@@ -175,6 +175,14 @@ if test x$have_smime != xno ; then
 	SMIMEAUX_TARGET="smime_keys"
 fi
 
+AC_ARG_ENABLE(sidebar, AC_HELP_STRING([--enable-sidebar], [Enable Sidebar support]),
+[       if test x$enableval = xyes ; then
+		AC_DEFINE(USE_SIDEBAR, 1, [Define if you want support for the sidebar.])
+		OPS="$OPS \$(srcdir)/OPS.SIDEBAR"
+                MUTT_LIB_OBJECTS="$MUTT_LIB_OBJECTS sidebar.o"
+        fi
+])
+
 AC_ARG_WITH(mixmaster, AS_HELP_STRING([--with-mixmaster@<:@=PATH@:>@],[Include Mixmaster support]),
   [if test "$withval" != no
    then
diff --git a/copy.c b/copy.c
index 360c1a4..3c67260 100644
--- a/copy.c
+++ b/copy.c
@@ -288,7 +288,8 @@ mutt_copy_hdr (FILE *in, FILE *out, LOFF_T off_start, LOFF_T off_end, int flags,
       if (flags & (CH_DECODE|CH_PREFIX))
       {
 	if (mutt_write_one_header (out, 0, headers[x], 
-				   flags & CH_PREFIX ? prefix : 0, mutt_term_width (Wrap), flags) == -1)
+				   flags & CH_PREFIX ? prefix : 0,
+                                   mutt_term_width (Wrap), flags) == -1)
 	{
 	  error = TRUE;
 	  break;
diff --git a/crypt-gpgme.c b/crypt-gpgme.c
index 479b58a..d7bf305 100644
--- a/crypt-gpgme.c
+++ b/crypt-gpgme.c
@@ -2744,6 +2744,7 @@ int smime_gpgme_application_handler (BODY *a, STATE *s)
 static const char *crypt_entry_fmt (char *dest,
                                     size_t destlen,
 				    size_t col,
+                                    int cols,
                                     char op,
                                     const char *src,
                                     const char *prefix,
@@ -2941,9 +2942,9 @@ static const char *crypt_entry_fmt (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
       
@@ -2956,7 +2957,7 @@ static void crypt_entry (char *s, size_t l, MUTTMENU * menu, int num)
   entry.key = key_table[num];
   entry.num = num + 1;
 
-  mutt_FormatString (s, l, 0, NONULL (PgpEntryFormat), crypt_entry_fmt, 
+  mutt_FormatString (s, l, 0, COLS - SidebarWidth, NONULL (PgpEntryFormat), crypt_entry_fmt, 
 		     (unsigned long) &entry, M_FORMAT_ARROWCURSOR);
 }
 
diff --git a/curs_main.c b/curs_main.c
index a76aac9..9c077fd 100644
--- a/curs_main.c
+++ b/curs_main.c
@@ -26,8 +26,13 @@
 #include "mailbox.h"
 #include "mapping.h"
 #include "sort.h"
+#include "buffy.h"
 #include "mx.h"
 
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
+
 #ifdef USE_POP
 #include "pop.h"
 #endif
@@ -595,8 +600,12 @@ int mutt_index_menu (void)
        menu->redraw |= REDRAW_STATUS;
      if (do_buffy_notify)
      {
-       if (mutt_buffy_notify () && option (OPTBEEPNEW))
- 	beep ();
+       if (mutt_buffy_notify())
+       {
+         menu->redraw |= REDRAW_STATUS;
+         if (option (OPTBEEPNEW))
+           beep();
+       }
      }
      else
        do_buffy_notify = 1;
@@ -613,6 +622,13 @@ int mutt_index_menu (void)
 
     if (menu->menu == MENU_MAIN)
     {
+#ifdef USE_SIDEBAR
+      if (menu->redraw & REDRAW_SIDEBAR || SidebarNeedsRedraw)
+      {
+        mutt_sb_set_buffystats (Context);
+        menu_redraw_sidebar (menu);
+      }
+#endif
       if (Context && Context->hdrs && !(menu->current >= Context->vcount))
       {
 	menu_check_recenter (menu);
@@ -630,7 +646,15 @@ int mutt_index_menu (void)
 
       if (menu->redraw & REDRAW_STATUS)
       {
+#ifdef USE_SIDEBAR
+        /* Temporarily lie about the sidebar width */
+	short sw = SidebarWidth;
+	SidebarWidth = 0;
+#endif
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+#ifdef USE_SIDEBAR
+        SidebarWidth = sw; /* Restore the sidebar width */
+#endif
 	move (option (OPTSTATUSONTOP) ? 0 : LINES-2, 0);
 	SETCOLOR (MT_COLOR_STATUS);
 	mutt_paddstr (COLS, buf);
@@ -652,7 +676,7 @@ int mutt_index_menu (void)
 	menu->oldcurrent = -1;
 
       if (option (OPTARROWCURSOR))
-	move (menu->current - menu->top + menu->offset, 2);
+	move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
       else if (option (OPTBRAILLEFRIENDLY))
 	move (menu->current - menu->top + menu->offset, 0);
       else
@@ -1150,6 +1174,9 @@ int mutt_index_menu (void)
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+#ifdef USE_SIDEBAR
+      case OP_SIDEBAR_OPEN:
+#endif
       case OP_MAIN_CHANGE_FOLDER:
       case OP_MAIN_NEXT_UNREAD_MAILBOX:
 
@@ -1177,20 +1204,29 @@ int mutt_index_menu (void)
 	    break;
 	  }
 	}
+#ifdef USE_SIDEBAR
+        else if (op == OP_SIDEBAR_OPEN)
+        {
+          const char *path = mutt_sb_get_highlight();
+          if (!path || !*path)
+            break;
+          strncpy (buf, path, sizeof (buf));
+        }
+#endif
 	else
 	{
 	  mutt_buffy (buf, sizeof (buf));
 
-	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
-	  {
-	    if (menu->menu == MENU_PAGER)
-	    {
-	      op = OP_DISPLAY_MESSAGE;
-	      continue;
-	    }
-	    else
-	      break;
-	  }
+          if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+          {
+            if (menu->menu == MENU_PAGER)
+            {
+              op = OP_DISPLAY_MESSAGE;
+              continue;
+            }
+            else
+              break;
+          }
 	  if (!buf[0])
 	  {
 	    CLEARLINE (LINES-1);
@@ -1248,6 +1284,10 @@ int mutt_index_menu (void)
 	else
 	  menu->current = 0;
 
+#ifdef USE_SIDEBAR
+        mutt_sb_set_open_buffy ();
+#endif
+
 	mutt_clear_error ();
 	mutt_buffy_check(1); /* force the buffy check after we have changed
 			      the folder */
@@ -2310,6 +2350,21 @@ int mutt_index_menu (void)
 	mutt_what_key();
 	break;
 
+#ifdef USE_SIDEBAR
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_NEXT_NEW:
+      case OP_SIDEBAR_PAGE_DOWN:
+      case OP_SIDEBAR_PAGE_UP:
+      case OP_SIDEBAR_PREV:
+      case OP_SIDEBAR_PREV_NEW:
+        mutt_sb_change_mailbox (op);
+        break;
+
+      case OP_SIDEBAR_TOGGLE_VISIBLE:
+	toggle_option (OPTSIDEBAR);
+	menu->redraw = REDRAW_FULL;
+	break;
+#endif
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff --git a/doc/makedoc-defs.h b/doc/makedoc-defs.h
index 8f1a349..ac6cd33 100644
--- a/doc/makedoc-defs.h
+++ b/doc/makedoc-defs.h
@@ -55,4 +55,7 @@
 # ifndef USE_SASL
 #  define USE_SASL
 # endif
+# ifndef USE_SIDEBAR
+#  define USE_SIDEBAR
+# endif
 #endif
diff --git a/doc/manual.xml.head b/doc/manual.xml.head
index b90908f..57d908f 100644
--- a/doc/manual.xml.head
+++ b/doc/manual.xml.head
@@ -405,6 +405,623 @@ attach to a message, select multiple files to attach and many more.
 
 </sect2>
 
+<sect2 id="intro-sidebar">
+  <title>Sidebar</title>
+  <para>
+    The Sidebar shows a list of all your mailboxes.  The list can be
+    turned on and off, it can be themed and the list style can be
+    configured.
+  </para>
+  <para>
+    This part of the manual is suitable for beginners.
+    If you already know Mutt you could skip ahead to the main
+    <link linkend="sidebar">Sidebar guide</link>.
+    If you just want to get started, you could use the sample
+    <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+  </para>
+  <para>
+    This version of Sidebar is based on Terry Chan's
+    <ulink url="http://www.lunar-linux.org/mutt-sidebar/">2015-11-11 release</ulink>.
+    It contains many
+    <emphasis role="bold"><link linkend="intro-sidebar-features">new features</link></emphasis>,
+    lots of
+    <emphasis role="bold"><link linkend="intro-sidebar-bugfixes">bugfixes</link></emphasis>
+    and a generous helping of
+    <emphasis role="bold">new documentation</emphasis> which you are already reading.
+  </para>
+  <para>
+    To check if Mutt supports <quote>Sidebar</quote>, look for the string
+    <literal>+USE_SIDEBAR</literal> in the mutt version.
+  </para>
+<screen>
+mutt -v
+</screen>
+  <para>
+    <emphasis role="bold">Let's turn on the Sidebar:</emphasis>
+  </para>
+  <screen>set sidebar_visible</screen>
+  <para>
+    You will see something like this.
+    A list of mailboxes on the left.
+    A list of emails, from the selected mailbox, on the right.
+  </para>
+<screen>
+<emphasis role="indicator">Fruit [1]     3/8</emphasis>|  1    + Jan 24  Rhys Lee         (192)  Yew
+Animals [1]   2/6|  2    + Feb 11  Grace Hall       (167)  Ilama
+Cars            4|  3      Feb 23  Aimee Scott      (450)  Nectarine
+Seas          1/7|  4    ! Feb 28  Summer Jackson   (264)  Lemon
+                 |  5      Mar 07  Callum Harrison  (464)  Raspberry
+                 |<emphasis role="indicator">  6 N  + Mar 24  Samuel Harris    (353)  Tangerine          </emphasis>
+                 |  7 N  + Sep 05  Sofia Graham     (335)  Cherry
+                 |  8 N    Sep 16  Ewan Brown       (105)  Ugli
+                 |
+                 |
+</screen>
+<para>
+  This user has four mailboxes: <quote>Fruit</quote>,
+  <quote>Cars</quote>, <quote>Animals</quote> and
+  <quote>Seas</quote>.
+</para>
+<para>
+  The current, open, mailbox is <quote>Fruit</quote>.  We can
+  also see information about the other mailboxes.  For example:
+  The <quote>Animals</quote> mailbox contains, 1 flagged email, 2
+  new emails out of a total of 6 emails.
+</para>
+  <sect3 id="intro-sidebar-navigation">
+    <title>Navigation</title>
+    <para>
+      The Sidebar adds some new <link linkend="sidebar-functions">functions</link>
+      to Mutt.
+    </para>
+    <para>
+      The user pressed the <quote>c</quote> key to
+      <literal>&lt;change-folder&gt;</literal> to the
+      <quote>Animals</quote> mailbox.  The Sidebar automatically
+      updated the indicator to match.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+Seas          1/7|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <para>
+      Let's map some functions:
+    </para>
+<screen>
+bind index,pager \CP sidebar-prev       <emphasis role="comment"># Ctrl-Shift-P - Previous Mailbox</emphasis>
+bind index,pager \CN sidebar-next       <emphasis role="comment"># Ctrl-Shift-N - Next Mailbox</emphasis>
+bind index,pager \CO sidebar-open       <emphasis role="comment"># Ctrl-Shift-O - Open Highlighted Mailbox</emphasis>
+</screen>
+    <para>
+      Press <quote>Ctrl-Shift-N</quote> (Next mailbox) twice will
+      move the Sidebar <emphasis role="bold">highlight</emphasis> to
+      down to the <quote>Seas</quote> mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1      Jan 03  Tia Gibson       (362)  Caiman
+<emphasis role="indicator">Animals [1]   2/6</emphasis>|  2    + Jan 22  Rhys Lee         ( 48)  Dolphin
+Cars            4|  3    ! Aug 16  Ewan Brown       (333)  Hummingbird
+<emphasis role="highlight">Seas          1/7</emphasis>|  4      Sep 25  Grace Hall       ( 27)  Capybara
+                 |<emphasis role="indicator">  5 N  + Nov 12  Evelyn Rogers    (453)  Tapir              </emphasis>
+                 |  6 N  + Nov 16  Callum Harrison  (498)  Hedgehog
+                 |
+                 |
+                 |
+                 |
+</screen>
+    <note>
+      Functions <literal>&lt;sidebar-next&gt;</literal> and
+      <literal>&lt;sidebar-prev&gt;</literal> move the Sidebar
+      <emphasis role="bold">highlight</emphasis>.
+      They <emphasis role="bold">do not</emphasis> change the open
+      mailbox.
+    </note>
+    <para>
+      Press <quote>Ctrl-Shift-O</quote>
+      (<literal>&lt;sidebar-open&gt;</literal>)
+      to open the highlighted mailbox.
+    </para>
+<screen>
+Fruit [1]     3/8|  1    ! Mar 07  Finley Jones     (139)  Molucca Sea
+Animals [1]   2/6|  2    + Mar 24  Summer Jackson   ( 25)  Arafura Sea
+Cars            4|  3    + Feb 28  Imogen Baker     (193)  Pechora Sea
+<emphasis role="indicator">Seas          1/7</emphasis>|<emphasis role="indicator">  4 N  + Feb 23  Isla Hussain     (348)  Balearic Sea       </emphasis>
+                 |
+                 |
+                 |
+                 |
+                 |
+                 |
+</screen>
+  </sect3>
+  <sect3 id="intro-sidebar-features">
+    <title>Features</title>
+    <para>
+      The Sidebar shows a list of mailboxes in a panel.
+    <para>
+    </para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-basics">State of the Sidebar</link></title>
+      <listitem><para>Visibility</para></listitem>
+      <listitem><para>Width</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-limit">Which mailboxes are displayed</link></title>
+      <listitem><para>Display all</para></listitem>
+      <listitem><para>Limit to mailboxes with new mail</para></listitem>
+      <listitem><para>Whitelist mailboxes to display always</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-sort">The order in which mailboxes are displayed</link></title>
+    <title></title>
+      <listitem><para>Unsorted (order of mailboxes commands)</para></listitem>
+      <listitem><para>Sorted alphabetically</para></listitem>
+      <listitem><para>Sorted by number of new mails</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="intro-sidebar-colors">Color</link></title>
+      <listitem><para>Sidebar indicators and divider</para></listitem>
+      <listitem><para>Mailboxes depending on their type</para></listitem>
+      <listitem><para>Mailboxes depending on their contents</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title><link linkend="sidebar-functions">Key bindings</link></title>
+      <listitem><para>Hide/Unhide the Sidebar</para></listitem>
+      <listitem><para>Select previous/next mailbox</para></listitem>
+      <listitem><para>Select previous/next mailbox with new mail</para></listitem>
+      <listitem><para>Page up/down through a list of mailboxes</para></listitem>
+    </itemizedlist>
+    <itemizedlist>
+    <title>Misc</title>
+      <listitem><para><link linkend="intro-sidebar-format">Formatting string for mailbox</link></para></listitem>
+      <listitem><para><link linkend="sidebar-next-new-wrap">Wraparound searching</link></para></listitem>
+      <listitem><para><link linkend="intro-sidebar-abbrev">Flexible mailbox abbreviations</link></para></listitem>
+      <listitem><para>Support for Unicode mailbox names (utf-8)</para></listitem>
+    </itemizedlist>
+  </sect3>
+  <sect3 id="intro-sidebar-display">
+    <title>Display</title>
+    <para>
+      Everything about the Sidebar can be configured.
+    </para>
+    <itemizedlist>
+      <title>For a quick reference:</title>
+      <listitem><para><link linkend="sidebar-variables">Sidebar variables to set</link> </para></listitem>
+      <listitem><para><link linkend="sidebar-colors">Sidebar colors to apply</link></para></listitem>
+      <listitem><para><link linkend="sidebar-sort">Sidebar sort methods</link></para></listitem>
+    </itemizedlist>
+    <sect4 id="intro-sidebar-basics">
+      <title>Sidebar Basics</title>
+      <para>
+        The most important variable is <literal>$sidebar_visible</literal>.
+        You can set this in your <quote>muttrc</quote>, or bind a key to the
+        function <literal>&lt;sidebar-toggle-visible&gt;</literal>.
+      </para>
+<screen>
+set sidebar_visible                         <emphasis role="comment"># Make the Sidebar visible by default</emphasis>
+bind index,pager B sidebar-toggle-visible   <emphasis role="comment"># Use 'B' to switch the Sidebar on and off</emphasis>
+</screen>
+      <para>
+        Next, decide how wide you want the Sidebar to be.  25
+        characters might be enough for the mailbox name and some numbers.
+    Remember, you can hide/show the Sidebar at the press of button.
+    </para>
+    <para>
+    Finally, you might want to change the divider character.
+    By default, Sidebar draws an ASCII line between it and the Index panel
+        If your terminal supports it, you can use a Unicode line-drawing character.
+      </para>
+<screen>
+set sidebar_width = 25                  <emphasis role="comment"># Plenty of space</emphasis>
+set sidebar_divider_char = '│'          <emphasis role="comment"># Pretty line-drawing character</emphasis>
+</screen>
+    </sect4>
+    <sect4 id="intro-sidebar-format">
+      <title>Sidebar Format String</title>
+      <para>
+        <literal>$sidebar_format</literal> allows you to customize the Sidebar display.
+        For an introduction, read <link linkend="index-format">format strings</link>
+        including the section about <link linkend="formatstrings-conditionals">conditionals</link>.
+      </para>
+      <para>
+        The default value is <literal>%B%?F? [%F]?%* %?N?%N/?%S</literal>
+      </para>
+      <itemizedlist>
+        <title>Which breaks down as:</title>
+        <listitem><para><literal>%B</literal> - Mailbox name</para></listitem>
+        <listitem><para><literal>%?F? [%F]?</literal> - If flagged emails <literal>[%F]</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%* </literal> - Pad with spaces</para></listitem>
+        <listitem><para><literal>%?N?%N/?</literal> - If new emails <literal>%N/</literal>, otherwise nothing</para></listitem>
+        <listitem><para><literal>%S</literal> - Total number of emails</para></listitem>
+      </itemizedlist>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="3">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Notes</entry>
+              <entry>Description</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry>%B</entry>
+              <entry></entry>
+              <entry>Name of the mailbox</entry>
+            </row>
+            <row>
+              <entry>%S</entry>
+              <entry>*</entry>
+              <entry>Size of mailbox (total number of messages)</entry>
+            </row>
+            <row>
+              <entry>%N</entry>
+              <entry>*</entry>
+              <entry>Number of New messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%F</entry>
+              <entry>*</entry>
+              <entry>Number of Flagged messages in the mailbox</entry>
+            </row>
+            <row>
+              <entry>%!</entry>
+              <entry></entry>
+              <entry>
+                <quote>!</quote>: one flagged message;
+                <quote>!!</quote>: two flagged messages;
+                <quote>n!</quote>: n flagged messages (for n &gt; 2).
+                Otherwise prints nothing.
+              </entry>
+            </row>
+            <row>
+              <entry>%d</entry>
+              <entry>* ‡</entry>
+              <entry>Number of deleted messages</entry>
+            </row>
+            <row>
+              <entry>%L</entry>
+              <entry>* ‡</entry>
+              <entry>Number of messages after limiting</entry>
+            </row>
+            <row>
+              <entry>%t</entry>
+              <entry>* ‡</entry>
+              <entry>Number of tagged messages</entry>
+            </row>
+            <row>
+              <entry>%&gt;X</entry>
+              <entry></entry>
+              <entry>Right justify the rest of the string and pad with <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%|X</entry>
+              <entry></entry>
+              <entry>Pad to the end of the line with
+              <quote>X</quote></entry>
+            </row>
+            <row>
+              <entry>%*X</entry>
+              <entry></entry>
+              <entry>Soft-fill with character <quote>X</quote>as pad</entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+      <para>
+      * = Can be optionally printed if nonzero
+      </para>
+      <para>
+      ‡ = Only applicable to the current folder
+      </para>
+      <para>
+        Here are some examples.
+        They show the number of (F)lagged, (N)ew and (S)ize.
+      </para>
+      <table>
+        <title>sidebar_format</title>
+        <tgroup cols="2">
+          <thead>
+            <row>
+              <entry>Format</entry>
+              <entry>Example</entry>
+            </row>
+          </thead>
+          <tbody>
+            <row>
+              <entry><literal>%B%?F? [%F]?%* %?N?%N/?%S</literal></entry>
+              <entry><screen>mailbox [F]            N/S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* %F:%N:%S</literal></entry>
+              <entry><screen>mailbox              F:N:S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B %?N?(%N)?%* %S</literal></entry>
+              <entry><screen>mailbox (N)              S</screen></entry>
+            </row>
+            <row>
+              <entry><literal>%B%* ?F?%F/?%N</literal></entry>
+              <entry><screen>mailbox                F/S</screen></entry>
+            </row>
+          </tbody>
+        </tgroup>
+      </table>
+    </sect4>
+    <sect4 id="intro-sidebar-abbrev">
+      <title>Abbreviating Mailbox Names</title>
+      <para>
+        <literal>$sidebar_delim_chars</literal> tells Sidebar
+        how to split up mailbox paths.  For local directories
+        use <quote>/</quote>; for IMAP folders use <quote>.</quote>
+      </para>
+      <sect5 id="intro-sidebar-abbrev-ex1">
+        <title>Example 1</title>
+        <para>
+          This example works well if your mailboxes have unique names
+          after the last separator.
+        </para>
+        <para>
+          Add some mailboxes of diffent depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit/apple          =fruit/banana          =fruit/cherry
+mailboxes =water/sea/sicily     =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean/atlantic =water/ocean/pacific   =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit/apple                            |apple
+|fruit/banana                           |banana
+|fruit/cherry                           |cherry
+|water/sea/sicily                       |sicily
+|water/sea/archipelago                  |archipelago
+|water/sea/sibuyan                      |sibuyan
+|water/ocean/atlantic                   |atlantic
+|water/ocean/pacific                    |pacific
+|water/ocean/arctic                     |arctic
+</screen>
+      </sect5>
+      <sect5 id="intro-sidebar-abbrev-ex2">
+        <title>Example 2</title>
+        <para>
+          This example works well if you have lots of mailboxes which are arranged
+          in a tree.
+        </para>
+        <para>
+          Add some mailboxes of diffent depths.
+        </para>
+<screen>
+set folder="~/mail"
+mailboxes =fruit
+mailboxes =fruit/apple =fruit/banana =fruit/cherry
+mailboxes =water
+mailboxes =water/sea
+mailboxes =water/sea/sicily =water/sea/archipelago =water/sea/sibuyan
+mailboxes =water/ocean
+mailboxes =water/ocean/atlantic =water/ocean/pacific =water/ocean/arctic
+</screen>
+        <para>
+          Shorten the names:
+        </para>
+<screen>
+set sidebar_short_path                  <emphasis role="comment"># Shorten mailbox names</emphasis>
+set sidebar_delim_chars="/"             <emphasis role="comment"># Delete everything up to the last / character</emphasis>
+set sidebar_folder_indent               <emphasis role="comment"># Indent folders whose names we've shortened</emphasis>
+set sidebar_indent_string="  "          <emphasis role="comment"># Indent with two spaces</emphasis>
+</screen>
+        <para>
+          The screenshot below shows what the Sidebar would look like
+          before and after shortening.
+        </para>
+<screen>
+|fruit                                  |fruit
+|fruit/apple                            |  apple
+|fruit/banana                           |  banana
+|fruit/cherry                           |  cherry
+|water                                  |water
+|water/sea                              |  sea
+|water/sea/sicily                       |    sicily
+|water/sea/archipelago                  |    archipelago
+|water/sea/sibuyan                      |    sibuyan
+|water/ocean                            |  ocean
+|water/ocean/atlantic                   |    atlantic
+|water/ocean/pacific                    |    pacific
+|water/ocean/arctic                     |    arctic
+</screen>
+        <para>
+          Sometimes, it will be necessary to add mailboxes, that you
+          don't use, to fill in part of the tree.  This will trade
+          vertical space for horizonal space (but it looks good).
+        </para>
+      </sect5>
+    </sect4>
+    <sect4 id="intro-sidebar-limit">
+      <title>Limiting the Number of Mailboxes</title>
+      <para>
+        If you have a lot of mailboxes, sometimes it can be useful to hide
+        the ones you aren't using.  <literal>$sidebar_new_mail_only</literal>
+        tells Sidebar to only show mailboxes that contain new, or flagged, email.
+      </para>
+      <para>
+        If you want some mailboxes to be always visible, then use the
+        <literal>sidebar_whitelist</literal> command.  It takes a list of
+        mailboxes as parameters.
+      </para>
+<screen>
+set sidebar_new_mail_only               <emphasis role="comment"># Only mailboxes with new/flagged email</emphasis>
+sidebar_whitelist fruit fruit/apple     <emphasis role="comment"># Always display these two mailboxes</emphasis>
+</screen>
+    </sect4>
+  </sect3>
+  <sect3 id="intro-sidebar-colors">
+    <title>Colors</title>
+    <para>
+      Here is a sample color scheme:
+    </para>
+<screen>
+color sidebar_indicator default color17         <emphasis role="comment"># Dark blue background</emphasis>
+color sidebar_highlight white   color238        <emphasis role="comment"># Grey background</emphasis>
+color sidebar_spoolfile yellow  default         <emphasis role="comment"># Yellow</emphasis>
+color sidebar_new       green   default         <emphasis role="comment"># Green</emphasis>
+color sidebar_flagged   red     default         <emphasis role="comment"># Red</emphasis>
+color sidebar_divider   color8  default         <emphasis role="comment"># Dark grey</emphasis>
+</screen>
+    <para>
+      There is a priority order when coloring Sidebar mailboxes.
+      e.g.  If a mailbox has new mail it will have the
+      <literal>sidebar_new</literal> color, even if it also contains
+      flagged mails.
+    </para>
+    <table id="table-intro-sidebar-colors">
+      <title>Sidebar Color Priority</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Priority</entry>
+            <entry>Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>Highest</entry>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>Mailbox is open</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>Mailbox is highlighed</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>Mailbox is the spoolfile (receives incoming mail)</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>Mailbox contains new mail</entry>
+          </row>
+          <row>
+            <entry></entry>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>Mailbox contains flagged mail</entry>
+          </row>
+          <row>
+            <entry>Lowest</entry>
+            <entry>(None)</entry>
+            <entry>Mailbox does not match above</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
+  <sect3 id="intro-sidebar-bugfixes">
+    <title>Bug-fixes</title>
+    <para>
+      If you haven't used Sidebar before, you can ignore this section.
+    </para>
+    <para>
+      These bugs have been fixed since the previous Sidebar release: 2015-11-11.
+    </para>
+    <itemizedlist>
+      <listitem><para>Fix bug when starting in compose mode</para></listitem>
+      <listitem><para>Fix bug with empty sidebar_divider_char string</para></listitem>
+      <listitem><para>Fix bug with header wrapping</para></listitem>
+      <listitem><para>Correctly handle utf8 character sequences</para></listitem>
+      <listitem><para>Fix a bug in mh_buffy_update</para></listitem>
+      <listitem><para>Fix refresh -- time overflowed short</para></listitem>
+      <listitem><para>Protect against empty format strings</para></listitem>
+      <listitem><para>Limit Sidebar width to COLS</para></listitem>
+      <listitem><para>Handle unmailboxes * safely</para></listitem>
+      <listitem><para>Refresh Sidebar after timeout</para></listitem>
+    </itemizedlist>
+  </sect3>
+  <sect3 id="intro-sidebar-config-changes">
+    <title>Config Changes</title>
+    <para>
+      If you haven't used Sidebar before, you can ignore this section.
+    </para>
+    <para>
+      Some of the Sidebar config has been changed to make its meaning clearer.
+      These changes have been made since the previous Sidebar release: 2015-11-11.
+    </para>
+    <table id="table-intro-sidebar-config-changes">
+      <title>Config Changes</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Old Name</entry>
+            <entry>New Name</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>$sidebar_delim</literal></entry>
+            <entry><literal>$sidebar_divider_char</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_folderindent</literal></entry>
+            <entry><literal>$sidebar_folder_indent</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_indentstr</literal></entry>
+            <entry><literal>$sidebar_indent_string</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_newmail_only</literal></entry>
+            <entry><literal>$sidebar_new_mail_only</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_refresh</literal></entry>
+            <entry><literal>$sidebar_refresh_time</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_shortpath</literal></entry>
+            <entry><literal>$sidebar_short_path</literal></entry>
+          </row>
+          <row>
+            <entry><literal>$sidebar_sort</literal></entry>
+            <entry><literal>$sidebar_sort_method</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-down&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+          </row>
+          <row>
+            <entry><literal>&lt;sidebar-scroll-up&gt;</literal></entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect3>
+</sect2>
+
 <sect2 id="intro-help">
 <title>Help</title>
 
@@ -6062,6 +6679,14 @@ linkend="imap-idle">$imap_idle</link> option is set, it'll use the IMAP
 IDLE extension if advertised by the server.
 </para>
 
+<para>
+The <link linkend="mail-check-recent">$mail_check_recent</link>
+option changes whether Mutt will notify you of new mail in an
+already visited mailbox.  When set (the default) it will only notify
+you of new mail received since the last time you opened the mailbox.
+When unset, Mutt will notify you of any new mail in the mailbox.
+</para>
+
 </sect2>
 
 <sect2 id="new-mail-polling">
@@ -6110,6 +6735,26 @@ to immediately open the next folder with unread mail (if any).
 
 </sect2>
 
+<sect2 id="calc-mailbox-counts">
+<title>Calculating Mailbox Message Counts</title>
+
+<para>
+If <link linkend="mail-check-stats">$mail_check_stats</link> is set,
+Mutt will periodically calculate the unread, flagged, and total
+message counts for each mailbox watched by the
+<command>mailboxes</command> command.  This calculation takes place at
+the same time as new mail polling, but is controlled by a separate
+timer: <link
+linkend="mail-check-stats-interval">$mail_check_stats_interval</link>.
+</para>
+
+<para>
+The sidebar can display these message counts.  See <link
+linkend="sidebar-format">$sidebar_format</link>.
+</para>
+
+</sect2>
+
 </sect1>
 
 <sect1 id="editing-threads">
@@ -6773,6 +7418,17 @@ to display the results.
 </para>
 
 <para>
+Mutt will set the <literal>COLUMNS</literal> environment variable to
+the width of the pager.  Some programs make use of this environment
+variable automatically.  Others provide a command line argument that
+can use this to set the output width:
+</para>
+
+<screen>
+text/html; lynx -dump -width ${COLUMNS:-80} %s; copiousoutput
+</screen>
+
+<para>
 Note that when using the built-in pager, <emphasis>only</emphasis>
 entries with this flag will be considered a handler for a MIME type
 &mdash; all other entries will be ignored.
@@ -7467,6 +8123,16 @@ would contain:
 
 </sect2>
 
+<sect2 id="mutt-patches">
+<title>Mutt Patches</title>
+<para>
+Mutt may also be <quote>patched</quote> to support smaller features.
+These patches should add a free-form string to the end Mutt's version string.
+Running <literal>mutt -v</literal> might show:
+<screen>patch-1.6.1.sidebar.20160502</screen>
+</para>
+</sect2>
+
 <sect2 id="url-syntax">
 <title>URL Syntax</title>
 
@@ -8081,6 +8747,466 @@ please have a look at the mixmaster documentation.
 
 </sect1>
 
+<sect1 id="sidebar">
+  <title>Sidebar Patch</title>
+  <subtitle>Overview of mailboxes</subtitle>
+
+  <sect2 id="sidebar-patch">
+    <title>Patch</title>
+
+    <para>
+      To check if Mutt supports <quote>Sidebar</quote>, look for
+      <quote>+USE_SIDEBAR</quote> in the mutt version.
+      See: <xref linkend="compile-time-features"/>.
+    </para>
+
+    <itemizedlist>
+      <title>Dependencies:</title>
+      <listitem><para>mutt-1.6.1</para></listitem>
+    </itemizedlist>
+
+    <para>This patch is part of the <ulink url="http://www.neomutt.org/">NeoMutt Project</ulink>.</para>
+  </sect2>
+
+  <sect2 id="sidebar-intro">
+    <title>Introduction</title>
+
+    <para>
+      The Sidebar shows a list of all your mailboxes.  The list can be
+      turned on and off, it can be themed and the list style can be
+      configured.
+    </para>
+
+    <para>
+      This part of the manual is a reference guide.
+      If you want a simple introduction with examples see the
+      <link linkend="intro-sidebar">Sidebar Howto</link>.
+      If you just want to get started, you could use the sample
+      <link linkend="sidebar-muttrc">Sidebar muttrc</link>.
+    </para>
+
+    <para>
+      This version of Sidebar is based on Terry Chan's
+      <ulink url="http://www.lunar-linux.org/mutt-sidebar/">2015-11-11 release</ulink>.
+      It contains many
+      <emphasis role="bold"><link linkend="intro-sidebar-features">new features</link></emphasis>,
+      lots of
+      <emphasis role="bold"><link linkend="intro-sidebar-bugfixes">bugfixes</link></emphasis>.
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-variables">
+    <title>Variables</title>
+
+    <table id="table-sidebar-variables">
+      <title>Sidebar Variables</title>
+      <tgroup cols="3">
+	<thead>
+	  <row>
+	    <entry>Name</entry>
+	    <entry>Type</entry>
+	    <entry>Default</entry>
+	  </row>
+	</thead>
+	<tbody>
+	  <row>
+	    <entry><literal>sidebar_delim_chars</literal></entry>
+	    <entry>string</entry>
+	    <entry><literal>/.</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_divider_char</literal></entry>
+	    <entry>string</entry>
+	    <entry><literal>|</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_folder_indent</literal></entry>
+	    <entry>boolean</entry>
+	    <entry><literal>no</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_format</literal></entry>
+	    <entry>string</entry>
+	    <entry><literal>%B%*  %n</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_indent_string</literal></entry>
+	    <entry>string</entry>
+	    <entry><literal>&nbsp;&nbsp;</literal> (two spaces)</entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_new_mail_only</literal></entry>
+	    <entry>boolean</entry>
+	    <entry><literal>no</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_next_new_wrap</literal></entry>
+	    <entry>boolean</entry>
+	    <entry><literal>no</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_short_path</literal></entry>
+	    <entry>boolean</entry>
+	    <entry><literal>no</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_sort_method</literal></entry>
+	    <entry>enum</entry>
+	    <entry><literal>unsorted</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_visible</literal></entry>
+	    <entry>boolean</entry>
+	    <entry><literal>no</literal></entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_whitelist</literal></entry>
+	    <entry>list</entry>
+	    <entry>(empty)</entry>
+	  </row>
+	  <row>
+	    <entry><literal>sidebar_width</literal></entry>
+	    <entry>number</entry>
+	    <entry><literal>20</literal></entry>
+	  </row>
+	</tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-functions">
+    <title>Functions</title>
+
+    <para>
+      Sidebar adds the following functions to Mutt.
+      By default, none of them are bound to keys.
+    </para>
+
+    <table id="table-sidebar-functions">
+      <title>Sidebar Functions</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Menus</entry>
+            <entry>Function</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-next-new&gt;</literal></entry>
+            <entry>Move the highlight to next mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-open&gt;</literal></entry>
+            <entry>Open highlighted mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-down&gt;</literal></entry>
+            <entry>Scroll the Sidebar down 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-page-up&gt;</literal></entry>
+            <entry>Scroll the Sidebar up 1 page</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-prev-new&gt;</literal></entry>
+            <entry>Move the highlight to previous mailbox with new mail</entry>
+          </row>
+          <row>
+            <entry>index,pager</entry>
+            <entry><literal>&lt;sidebar-toggle-visible&gt;</literal></entry>
+            <entry>Make the Sidebar (in)visible</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-commands">
+    <title>Commands</title>
+    <cmdsynopsis>
+      <command>sidebar_whitelist<anchor id="sidebar-whitelist"/></command>
+      <arg choice="plain">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+      <arg choice="opt" rep="repeat">
+        <replaceable class="parameter">mailbox</replaceable>
+      </arg>
+    </cmdsynopsis>
+  </sect2>
+
+  <sect2 id="sidebar-colors">
+    <title>Colors</title>
+
+    <table id="table-sidebar-colors">
+      <title>Sidebar Colors</title>
+      <tgroup cols="3">
+        <thead>
+          <row>
+            <entry>Name</entry>
+            <entry>Default Color</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>sidebar_divider</literal></entry>
+            <entry>default</entry>
+            <entry>The dividing line between the Sidebar and the Index/Pager panels</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_flagged</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing flagged mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_highlight</literal></entry>
+            <entry>underline</entry>
+            <entry>Cursor to select a mailbox</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_indicator</literal></entry>
+            <entry>mutt <literal>indicator</literal></entry>
+            <entry>The mailbox open in the Index panel</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_new</literal></entry>
+            <entry>default</entry>
+            <entry>Mailboxes containing new mail</entry>
+          </row>
+          <row>
+            <entry><literal>sidebar_spoolfile</literal></entry>
+            <entry>default</entry>
+            <entry>Mailbox that receives incoming mail</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+
+    <para>
+    If the <literal>sidebar_indicator</literal> color isn't set, then the default Mutt
+    indicator color will be used (the color used in the index panel).
+    </para>
+  </sect2>
+
+  <sect2 id="sidebar-sort">
+    <title>Sort</title>
+
+    <table id="table-sidebar-sort">
+      <title>Sidebar Sort</title>
+      <tgroup cols="2">
+        <thead>
+          <row>
+            <entry>Sort</entry>
+            <entry>Description</entry>
+          </row>
+        </thead>
+        <tbody>
+          <row>
+            <entry><literal>alpha</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>count</literal></entry>
+            <entry>Total number of messages</entry>
+          </row>
+          <row>
+            <entry><literal>flagged</literal></entry>
+            <entry>Number of flagged messages</entry>
+          </row>
+          <row>
+            <entry><literal>name</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>new</literal></entry>
+            <entry>Number of new messages</entry>
+          </row>
+          <row>
+            <entry><literal>path</literal></entry>
+            <entry>Alphabetically by path</entry>
+          </row>
+          <row>
+            <entry><literal>unsorted</literal></entry>
+            <entry>Do not resort the paths</entry>
+          </row>
+        </tbody>
+      </tgroup>
+    </table>
+  </sect2>
+
+  <sect2 id="sidebar-muttrc">
+    <title>Muttrc</title>
+<screen>
+<emphasis role="comment"># This is a complete list of sidebar-related configuration.
+ 
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+ 
+# Should the Sidebar be shown?</emphasis>
+set sidebar_visible = no
+ 
+<emphasis role="comment"># How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.</emphasis>
+set sidebar_width = 20
+ 
+<emphasis role="comment"># Should the mailbox paths be abbreviated?</emphasis>
+set sidebar_short_path = no
+ 
+<emphasis role="comment"># When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.</emphasis>
+set sidebar_delim_chars = '/.'
+ 
+<emphasis role="comment"># If the mailbox path is abbreviated, should it be indented?</emphasis>
+set sidebar_folder_indent = no
+ 
+<emphasis role="comment"># Indent mailbox paths with this string.</emphasis>
+set sidebar_indent_string = '  '
+ 
+<emphasis role="comment"># Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.</emphasis>
+set sidebar_new_mail_only = no
+ 
+<emphasis role="comment"># Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.</emphasis>
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+ 
+<emphasis role="comment"># When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?</emphasis>
+set sidebar_next_new_wrap = no
+ 
+<emphasis role="comment"># The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.</emphasis>
+set sidebar_divider_char = '|'
+ 
+<emphasis role="comment"># Display the Sidebar mailboxes using this format string.</emphasis>
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+ 
+<emphasis role="comment"># Sidebar will not refresh its list of mailboxes any more frequently than
+# this number of seconds.  This will help reduce disk/network traffic.</emphasis>
+set sidebar_refresh_time = 60
+ 
+<emphasis role="comment"># Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - do not sort the mailboxes</emphasis>
+set sidebar_sort_method = 'unsorted'
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+ 
+# Move the highlight to the previous mailbox</emphasis>
+bind index,pager \Cp sidebar-prev
+ 
+<emphasis role="comment"># Move the highlight to the next mailbox</emphasis>
+bind index,pager \Cn sidebar-next
+ 
+<emphasis role="comment"># Open the highlighted mailbox</emphasis>
+bind index,pager \Co sidebar-open
+ 
+<emphasis role="comment"># Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F3&gt; sidebar-page-up
+ 
+<emphasis role="comment"># Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.</emphasis>
+bind index,pager &lt;F4&gt; sidebar-page-down
+ 
+<emphasis role="comment"># Move the highlight to the previous mailbox containing new, or flagged,
+# mail.</emphasis>
+bind index,pager &lt;F5&gt; sidebar-prev-new
+ 
+<emphasis role="comment"># Move the highlight to the next mailbox containing new, or flagged, mail.</emphasis>
+bind index,pager &lt;F6&gt; sidebar-next-new
+ 
+<emphasis role="comment"># Toggle the visibility of the Sidebar.</emphasis>
+bind index,pager B sidebar-toggle-visible
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+ 
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.</emphasis>
+color indicator cyan black
+ 
+<emphasis role="comment"># Color of the highlighted, but not open, mailbox.</emphasis>
+color sidebar_highlight black color8
+ 
+<emphasis role="comment"># Color of the divider separating the Sidebar from Mutt panels</emphasis>
+color sidebar_divider color8 black
+ 
+<emphasis role="comment"># Color to give mailboxes containing flagged mail</emphasis>
+color sidebar_flagged red black
+ 
+<emphasis role="comment"># Color to give mailboxes containing new mail</emphasis>
+color sidebar_new green black
+ 
+<emphasis role="comment"># --------------------------------------------------------------------------
+ 
+# vim: syntax=muttrc</emphasis>
+</screen>
+  </sect2>
+
+  <sect2 id="sidebar-see-also">
+    <title>See Also</title>
+
+    <itemizedlist>
+      <listitem><para><link linkend="regexp">Regular Expressions</link></para></listitem>
+      <listitem><para><link linkend="patterns">Patterns</link></para></listitem>
+      <listitem><para><link linkend="color">Color command</link></para></listitem>
+      <listitem><para><link linkend="notmuch">notmuch patch</link></para></listitem>
+    </itemizedlist>
+  </sect2>
+
+  <sect2 id="sidebar-known-bugs">
+    <title>Known Bugs</title>
+    Unsorted isn't
+  </sect2>
+
+  <sect2 id="sidebar-credits">
+    <title>Credits</title>
+    <itemizedlist>
+    <listitem><para>Justin Hibbits <email>jrh29@po.cwru.edu</email></para></listitem>
+    <listitem><para>Thomer M. Gil <email>mutt@thomer.com</email></para></listitem>
+    <listitem><para>David Sterba <email>dsterba@suse.cz</email></para></listitem>
+    <listitem><para>Evgeni Golov <email>evgeni@debian.org</email></para></listitem>
+    <listitem><para>Fabian Groffen <email>grobian@gentoo.org</email></para></listitem>
+    <listitem><para>Jason DeTiberus <email>jdetiber@redhat.com</email></para></listitem>
+    <listitem><para>Stefan Assmann <email>sassmann@kpanic.de</email></para></listitem>
+    <listitem><para>Steve Kemp <email>steve@steve.org.uk</email></para></listitem>
+    <listitem><para>Terry Chan <email>tchan@lunar-linux.org</email></para></listitem>
+    <listitem><para>Tyler Earnest <email>tylere@rne.st</email></para></listitem>
+    <listitem><para>Richard Russon <email>rich@flatcap.org</email></para></listitem>
+    </itemizedlist>
+  </sect2>
+</sect1>
+
 </chapter>
 
 <chapter id="security">
@@ -9237,6 +10363,17 @@ The following are the commands understood by Mutt:
 
 <listitem>
 <cmdsynopsis>
+<command><link linkend="sidebar-whitelist">sidebar_whitelist</link></command>
+<arg choice="plain">
+<replaceable class="parameter">item</replaceable>
+</arg>
+<arg choice="plain">
+<replaceable class="parameter">command</replaceable>
+</arg>
+</cmdsynopsis>
+</listitem>
+<listitem>
+<cmdsynopsis>
 <command><link linkend="source">source</link></command>
 <arg choice="plain">
 <replaceable class="parameter">filename</replaceable>
diff --git a/doc/mutt.css b/doc/mutt.css
index 5a37b3c..d7ff017 100644
--- a/doc/mutt.css
+++ b/doc/mutt.css
@@ -9,17 +9,24 @@ div.table-contents table td, div.informaltable td, div.table-contents table th,
 div.table-contents table th, div.informaltable table th {
     font-family:sans-serif;
     background:#d0d0d0;
-    font-weight:normal;
+    font-weight:bold;
     vertical-align:top;
 }
-div.cmdsynopsis { border-left:1px solid #707070; padding-left:5px; }
+div.cmdsynopsis { border-left:1px solid #707070; padding-left: 1em; }
 li div.cmdsynopsis { border-left:none; padding-left:0px; }
-pre.screen, div.note { background:#f0f0f0; border:1px solid #c0c0c0; padding:5px; margin-left:2%; margin-right:2%; }
+li p { margin: 0; }
+pre.screen, div.note { border:1px solid #c0c0c0; margin-left:2%; margin-right:2%; }
+pre.screen { color: #ffffff; background:#000000; padding: 0.5em; }
+div.note { background:#ffff80; padding: 0.5em; }
 div.example p.title { margin-left:2%; }
 div.note h3 { font-size:small; font-style:italic; font-variant: small-caps; }
 div.note h3:after { content: ":" }
 div.note { margin-bottom: 5px; }
-.command { font-family: monospace; font-weight: normal; }
+div.literallayout, .command { font-family: monospace; font-weight: normal; }
 .command strong { font-weight: normal; }
 tr { vertical-align: top; }
-.comment { color:#707070; }
+.comment { color:#00c000; }
+code.literal { background: #f0f0f0; color: #000000; }
+span.indicator { background: #000060; color: #ffffff; }
+span.highlight { background: #404040; color: #ffffff; }
+span.reverse { background: #ffffff; color: #000000; }
diff --git a/doc/muttrc.sidebar b/doc/muttrc.sidebar
new file mode 100644
index 0000000..f21db26
--- /dev/null
+++ b/doc/muttrc.sidebar
@@ -0,0 +1,116 @@
+# This is a complete list of sidebar-related configuration.
+
+# --------------------------------------------------------------------------
+# VARIABLES - shown with their default values
+# --------------------------------------------------------------------------
+
+# Should the Sidebar be shown?
+set sidebar_visible = no
+
+# How wide should the Sidebar be in screen columns?
+# Note: Some characters, e.g. Chinese, take up two columns each.
+set sidebar_width = 20
+
+# Should the mailbox paths be abbreviated?
+set sidebar_short_path = no
+
+# When abbreviating mailbox path names, use any of these characters as path
+# separators.  Only the part after the last separators will be shown.
+# For file folders '/' is good.  For IMAP folders, often '.' is useful.
+set sidebar_delim_chars = '/.'
+
+# If the mailbox path is abbreviated, should it be indented?
+set sidebar_folder_indent = no
+
+# Indent mailbox paths with this string.
+set sidebar_indent_string = '  '
+
+# Make the Sidebar only display mailboxes that contain new, or flagged,
+# mail.
+set sidebar_new_mail_only = no
+
+# Any mailboxes that are whitelisted will always be visible, even if the
+# sidebar_new_mail_only option is enabled.
+sidebar_whitelist '/home/user/mailbox1'
+sidebar_whitelist '/home/user/mailbox2'
+
+# When searching for mailboxes containing new mail, should the search wrap
+# around when it reaches the end of the list?
+set sidebar_next_new_wrap = no
+
+# The character to use as the divider between the Sidebar and the other Mutt
+# panels.
+# Note: Only the first character of this string is used.
+set sidebar_divider_char = '|'
+
+# Enable extended buffy mode to calculate total, new, and flagged
+# message counts for each mailbox.
+set mail_check_stats
+
+# Display the Sidebar mailboxes using this format string.
+set sidebar_format = '%B%?F? [%F]?%* %?N?%N/?%S'
+
+# Sort the mailboxes in the Sidebar using this method:
+#       count    - total number of messages
+#       flagged  - number of flagged messages
+#       new      - number of new messages
+#       path     - mailbox path
+#       unsorted - do not sort the mailboxes
+set sidebar_sort_method = 'unsorted'
+
+# --------------------------------------------------------------------------
+# FUNCTIONS - shown with an example mapping
+# --------------------------------------------------------------------------
+
+# Move the highlight to the previous mailbox
+bind index,pager \Cp sidebar-prev
+
+# Move the highlight to the next mailbox
+bind index,pager \Cn sidebar-next
+
+# Open the highlighted mailbox
+bind index,pager \Co sidebar-open
+
+# Move the highlight to the previous page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F3> sidebar-page-up
+
+# Move the highlight to the next page
+# This is useful if you have a LOT of mailboxes.
+bind index,pager <F4> sidebar-page-down
+
+# Move the highlight to the previous mailbox containing new, or flagged,
+# mail.
+bind index,pager <F5> sidebar-prev-new
+
+# Move the highlight to the next mailbox containing new, or flagged, mail.
+bind index,pager <F6> sidebar-next-new
+
+# Toggle the visibility of the Sidebar.
+bind index,pager B sidebar-toggle-visible
+
+# --------------------------------------------------------------------------
+# COLORS - some unpleasant examples are given
+# --------------------------------------------------------------------------
+# Note: All color operations are of the form:
+#       color OBJECT FOREGROUND BACKGROUND
+
+# Color of the current, open, mailbox
+# Note: This is a general Mutt option which colors all selected items.
+color indicator cyan black
+
+# Color of the highlighted, but not open, mailbox.
+color sidebar_highlight black color8
+
+# Color of the divider separating the Sidebar from Mutt panels
+color sidebar_divider color8 black
+
+# Color to give mailboxes containing flagged mail
+color sidebar_flagged red black
+
+# Color to give mailboxes containing new mail
+color sidebar_new green black
+
+# --------------------------------------------------------------------------
+
+# vim: syntax=muttrc
diff --git a/doc/vimrc.sidebar b/doc/vimrc.sidebar
new file mode 100644
index 0000000..c5be50d
--- /dev/null
+++ b/doc/vimrc.sidebar
@@ -0,0 +1,35 @@
+" Vim syntax file for the mutt sidebar patch
+
+syntax keyword muttrcVarBool    skipwhite contained sidebar_folder_indent nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    skipwhite contained sidebar_new_mail_only nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    skipwhite contained sidebar_next_new_wrap nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    skipwhite contained sidebar_short_path    nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarBool    skipwhite contained sidebar_visible       nextgroup=muttrcSetBoolAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarNum     skipwhite contained sidebar_refresh_time  nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+syntax keyword muttrcVarNum     skipwhite contained sidebar_width         nextgroup=muttrcSetNumAssignment,muttrcVPrefix,muttrcVarBool,muttrcVarQuad,muttrcVarNum,muttrcVarStr
+
+syntax keyword muttrcVarStr     contained skipwhite sidebar_divider_char  nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_delim_chars   nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_format        nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_indent_string nextgroup=muttrcVarEqualsIdxFmt
+syntax keyword muttrcVarStr     contained skipwhite sidebar_sort_method   nextgroup=muttrcVarEqualsIdxFmt
+
+syntax keyword muttrcCommand    sidebar_whitelist
+
+syntax match muttrcFunction     contained "\<sidebar-next\>"
+syntax match muttrcFunction     contained "\<sidebar-next-new\>"
+syntax match muttrcFunction     contained "\<sidebar-open\>"
+syntax match muttrcFunction     contained "\<sidebar-page-down\>"
+syntax match muttrcFunction     contained "\<sidebar-page-up\>"
+syntax match muttrcFunction     contained "\<sidebar-prev\>"
+syntax match muttrcFunction     contained "\<sidebar-prev-new\>"
+syntax match muttrcFunction     contained "\<sidebar-toggle-visible\>"
+
+syntax keyword muttrcColorField contained sidebar_divider
+syntax keyword muttrcColorField contained sidebar_flagged
+syntax keyword muttrcColorField contained sidebar_highlight
+syntax keyword muttrcColorField contained sidebar_indicator
+syntax keyword muttrcColorField contained sidebar_new
+
+" vim: syntax=vim
diff --git a/filter.c b/filter.c
index 91a4d75..a8dc2f5 100644
--- a/filter.c
+++ b/filter.c
@@ -21,6 +21,7 @@
 #endif
 
 #include "mutt.h"
+#include "mutt_curses.h"
 
 #include <unistd.h>
 #include <stdlib.h>
@@ -34,6 +35,7 @@ mutt_create_filter_fd (const char *cmd, FILE **in, FILE **out, FILE **err,
 		       int fdin, int fdout, int fderr)
 {
   int pin[2], pout[2], perr[2], thepid;
+  char columns[11];
 
   if (in)
   {
@@ -117,6 +119,9 @@ mutt_create_filter_fd (const char *cmd, FILE **in, FILE **out, FILE **err,
       close (fderr);
     }
 
+    snprintf (columns, sizeof (columns), "%d", COLS - SidebarWidth);
+    setenv ("COLUMNS", columns, 1);
+
     execl (EXECSHELL, "sh", "-c", cmd, NULL);
     _exit (127);
   }
diff --git a/flags.c b/flags.c
index f0f3d81..0351f6c 100644
--- a/flags.c
+++ b/flags.c
@@ -255,7 +255,12 @@ void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
   }
 
   if (update)
+  {
     mutt_set_header_color(ctx, h);
+#ifdef USE_SIDEBAR
+    SidebarNeedsRedraw = 1;
+#endif
+  }
 
   /* if the message status has changed, we need to invalidate the cached
    * search results so that any future search will match the current status
diff --git a/functions.h b/functions.h
index 7a1c5a9..9d7850c 100644
--- a/functions.h
+++ b/functions.h
@@ -168,6 +168,16 @@ const struct binding_t OpMain[] = { /* map: index */
   { "decrypt-copy",		OP_DECRYPT_COPY,		NULL },
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
 
+#ifdef USE_SIDEBAR
+  { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
+  { "sidebar-next-new",		OP_SIDEBAR_NEXT_NEW,		NULL },
+  { "sidebar-open",		OP_SIDEBAR_OPEN,		NULL },
+  { "sidebar-page-down",	OP_SIDEBAR_PAGE_DOWN,		NULL },
+  { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
+  { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
+  { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
+#endif
 
   { NULL,			0,				NULL }
 };
@@ -272,6 +282,17 @@ const struct binding_t OpPager[] = { /* map: pager */
 
   { "what-key",		OP_WHAT_KEY,		NULL },
 
+#ifdef USE_SIDEBAR
+  { "sidebar-next",		OP_SIDEBAR_NEXT,		NULL },
+  { "sidebar-next-new",		OP_SIDEBAR_NEXT_NEW,		NULL },
+  { "sidebar-open",		OP_SIDEBAR_OPEN,		NULL },
+  { "sidebar-page-down",	OP_SIDEBAR_PAGE_DOWN,		NULL },
+  { "sidebar-page-up",		OP_SIDEBAR_PAGE_UP,		NULL },
+  { "sidebar-prev",		OP_SIDEBAR_PREV,		NULL },
+  { "sidebar-prev-new",		OP_SIDEBAR_PREV_NEW,		NULL },
+  { "sidebar-toggle-visible",	OP_SIDEBAR_TOGGLE_VISIBLE,	NULL },
+#endif
+
   { NULL,		0,				NULL }
 };
 
diff --git a/globals.h b/globals.h
index abefade..b14ee63 100644
--- a/globals.h
+++ b/globals.h
@@ -118,6 +118,12 @@ WHERE short SearchContext;
 WHERE char *SendCharset;
 WHERE char *Sendmail;
 WHERE char *Shell;
+#ifdef USE_SIDEBAR
+WHERE char *SidebarDelimChars;
+WHERE char *SidebarDividerChar;
+WHERE char *SidebarFormat;
+WHERE char *SidebarIndentString;
+#endif
 WHERE char *Signature;
 WHERE char *SimpleSearch;
 #if USE_SMTP
@@ -214,6 +220,12 @@ WHERE short ScoreThresholdDelete;
 WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
+WHERE short SidebarWidth INITVAL(0);
+#ifdef USE_SIDEBAR
+WHERE LIST *SidebarWhitelist INITVAL(0);
+WHERE int SidebarNeedsRedraw INITVAL (0);
+#endif
+
 #ifdef USE_IMAP
 WHERE short ImapKeepalive;
 WHERE short ImapPipelineDepth;
diff --git a/hdrline.c b/hdrline.c
index b844411..c18d2e7 100644
--- a/hdrline.c
+++ b/hdrline.c
@@ -236,6 +236,7 @@ static const char *
 hdr_format_str (char *dest,
 		size_t destlen,
 		size_t col,
+                int cols,
 		char op,
 		const char *src,
 		const char *prefix,
@@ -735,9 +736,9 @@ hdr_format_str (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, hdr_format_str, (unsigned long) hfi, flags);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, hdr_format_str, (unsigned long) hfi, flags);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, hdr_format_str, (unsigned long) hfi, flags);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, hdr_format_str, (unsigned long) hfi, flags);
 
   return (src);
 #undef THREAD_NEW
@@ -753,11 +754,11 @@ _mutt_make_string (char *dest, size_t destlen, const char *s, CONTEXT *ctx, HEAD
   hfi.ctx = ctx;
   hfi.pager_progress = 0;
 
-  mutt_FormatString (dest, destlen, 0, s, hdr_format_str, (unsigned long) &hfi, flags);
+  mutt_FormatString (dest, destlen, 0, COLS - SidebarWidth, s, hdr_format_str, (unsigned long) &hfi, flags);
 }
 
 void
 mutt_make_string_info (char *dst, size_t dstlen, const char *s, struct hdr_format_info *hfi, format_flag flags)
 {
-  mutt_FormatString (dst, dstlen, 0, s, hdr_format_str, (unsigned long) hfi, flags);
+  mutt_FormatString (dst, dstlen, 0, COLS - SidebarWidth, s, hdr_format_str, (unsigned long) hfi, flags);
 }
diff --git a/imap/command.c b/imap/command.c
index d99a99a..b5c896d 100644
--- a/imap/command.c
+++ b/imap/command.c
@@ -900,6 +900,7 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s)
   IMAP_STATUS *status;
   unsigned int olduv, oldun;
   long litlen;
+  short new = 0;
 
   mailbox = imap_next_word (s);
 
@@ -1000,16 +1001,26 @@ static void cmd_parse_status (IMAP_DATA* idata, char* s)
 	  if (olduv && olduv == status->uidvalidity)
 	  {
 	    if (oldun < status->uidnext)
-	      inc->new = status->unseen;
+	      new = (status->unseen > 0);
 	  }
 	  else if (!olduv && !oldun)
 	    /* first check per session, use recent. might need a flag for this. */
-	    inc->new = status->recent;
+	    new = (status->recent > 0);
 	  else
-	    inc->new = status->unseen;
+	    new = (status->unseen > 0);
 	}
 	else
-          inc->new = status->unseen;
+          new = (status->unseen > 0);
+
+#ifdef USE_SIDEBAR
+        if ((inc->new != new) ||
+            (inc->msg_count != status->messages) ||
+            (inc->msg_unread != status->unseen))
+          SidebarNeedsRedraw = 1;
+#endif
+        inc->new = new;
+        inc->msg_count  = status->messages;
+        inc->msg_unread = status->unseen;
 
 	if (inc->new)
 	  /* force back to keep detecting new mail until the mailbox is
diff --git a/imap/imap.c b/imap/imap.c
index 1b63b3a..2aaa14c 100644
--- a/imap/imap.c
+++ b/imap/imap.c
@@ -589,7 +589,9 @@ int imap_open_mailbox (CONTEXT* ctx)
   imap_qualify_path (buf, sizeof (buf), &mx, idata->mailbox);
 
   FREE (&(ctx->path));
+  FREE (&(ctx->realpath));
   ctx->path = safe_strdup (buf);
+  ctx->realpath = safe_strdup (ctx->path);
 
   idata->ctx = ctx;
 
@@ -1479,7 +1481,7 @@ static int imap_get_mailbox (const char* path, IMAP_DATA** hidata, char* buf, si
 /* check for new mail in any subscribed mailboxes. Given a list of mailboxes
  * rather than called once for each so that it can batch the commands and
  * save on round trips. Returns number of mailboxes with new mail. */
-int imap_buffy_check (int force)
+int imap_buffy_check (int force, int check_stats)
 {
   IMAP_DATA* idata;
   IMAP_DATA* lastdata = NULL;
@@ -1501,8 +1503,6 @@ int imap_buffy_check (int force)
     if (mailbox->magic != M_IMAP)
       continue;
 
-    mailbox->new = 0;
-
     if (imap_get_mailbox (mailbox->path, &idata, name, sizeof (name)) < 0)
       continue;
 
@@ -1534,7 +1534,11 @@ int imap_buffy_check (int force)
       lastdata = idata;
 
     imap_munge_mbox_name (idata, munged, sizeof (munged), name);
-    snprintf (command, sizeof (command),
+    if (check_stats)
+      snprintf (command, sizeof (command),
+	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)", munged);
+    else
+      snprintf (command, sizeof (command),
 	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)", munged);
 
     if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
diff --git a/imap/imap.h b/imap/imap.h
index a914b40..0933ccf 100644
--- a/imap/imap.h
+++ b/imap/imap.h
@@ -39,7 +39,7 @@ int imap_open_mailbox (CONTEXT *ctx);
 int imap_open_mailbox_append (CONTEXT *ctx);
 int imap_sync_mailbox (CONTEXT *ctx, int expunge, int *index_hint);
 int imap_close_mailbox (CONTEXT *ctx);
-int imap_buffy_check (int force);
+int imap_buffy_check (int force, int check_stats);
 int imap_status (char *path, int queue);
 int imap_search (CONTEXT* ctx, const pattern_t* pat);
 int imap_subscribe (char *path, int subscribe);
diff --git a/init.c b/init.c
index 69e2f76..2fab2f8 100644
--- a/init.c
+++ b/init.c
@@ -1611,6 +1611,10 @@ static void mutt_restore_default (struct option_t *p)
     set_option (OPTRESORTINIT);
   if (p->flags & R_TREE)
     set_option (OPTREDRAWTREE);
+#ifdef USE_SIDEBAR
+  if (p->flags & R_SIDEBAR)
+    SidebarNeedsRedraw = 1;
+#endif
 }
 
 static size_t escape_string (char *dst, size_t len, const char* src)
@@ -2173,6 +2177,9 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
 	case DT_SORT_AUX:
 	  map = SortAuxMethods;
 	  break;
+	case DT_SORT_SIDEBAR:
+	  map = SortSidebarMethods;
+	  break;
 	default:
 	  map = SortMethods;
 	  break;
@@ -2226,6 +2233,10 @@ static int parse_set (BUFFER *tmp, BUFFER *s, unsigned long data, BUFFER *err)
         set_option (OPTRESORTINIT);
       if (MuttVars[idx].flags & R_TREE)
         set_option (OPTREDRAWTREE);
+#ifdef USE_SIDEBAR
+      if (MuttVars[idx].flags & R_SIDEBAR)
+        SidebarNeedsRedraw = 1;
+#endif
     }
   }
   return (r);
diff --git a/init.h b/init.h
index 5a12ec0..95bcb1c 100644
--- a/init.h
+++ b/init.h
@@ -42,11 +42,12 @@
 #define DTYPE(x) ((x) & DT_MASK)
 
 /* subtypes */
-#define DT_SUBTYPE_MASK	0xf0
+#define DT_SUBTYPE_MASK	0xff0
 #define DT_SORT_ALIAS	0x10
 #define DT_SORT_BROWSER 0x20
 #define DT_SORT_KEYS	0x40
 #define DT_SORT_AUX	0x80
+#define DT_SORT_SIDEBAR	0x100
 
 /* flags to parse_set() */
 #define M_SET_INV	(1<<0)	/* default is to invert all vars */
@@ -61,6 +62,8 @@
 #define R_RESORT_SUB	(1<<3)	/* resort subthreads */
 #define R_RESORT_INIT	(1<<4)  /* resort from scratch */
 #define R_TREE		(1<<5)  /* redraw the thread tree */
+#define R_REFLOW        (1<<6)  /* reflow window layout */
+#define R_SIDEBAR       (1<<7)  /* redraw the sidebar */
 #define R_BOTH		(R_INDEX | R_PAGER)
 #define R_RESORT_BOTH	(R_RESORT | R_RESORT_SUB)
 
@@ -1407,6 +1410,22 @@ struct option_t MuttVars[] = {
   ** When \fI$$mark_old\fP is set, Mutt does not consider the mailbox to contain new
   ** mail if only old messages exist.
   */
+  { "mail_check_stats", DT_BOOL, R_NONE, OPTMAILCHECKSTATS, 0 },
+  /*
+  ** .pp
+  ** When \fIset\fP, mutt will periodically calculate message
+  ** statistics of a mailbox while polling for new mail.  It will
+  ** check for unread, flagged, and total message counts.  Because
+  ** this operation is more performance intensive, it defaults to
+  ** \fIunset\fP, and has a separate option, $$mail_check_stats_interval, to
+  ** control how often to update these counts.
+  */
+  { "mail_check_stats_interval", DT_NUM, R_NONE, UL &BuffyCheckStatsInterval, 60 },
+  /*
+  ** .pp
+  ** When $$mail_check_stats is \fIset\fP, this variable configures
+  ** how often (in seconds) mutt will update message counts.
+  */
   { "mailcap_path",	DT_STR,	 R_NONE, UL &MailcapPath, 0 },
   /*
   ** .pp
@@ -2665,6 +2684,142 @@ struct option_t MuttVars[] = {
   ** Command to use when spawning a subshell.  By default, the user's login
   ** shell from \fC/etc/passwd\fP is used.
   */
+#ifdef USE_SIDEBAR
+  { "sidebar_divider_char", DT_STR, R_SIDEBAR, UL &SidebarDividerChar, UL "|" },
+  /*
+  ** .pp
+  ** This specifies the characters to be drawn between the sidebar (when
+  ** visible) and the other Mutt panels. ASCII and Unicode line-drawing
+  ** characters are supported.
+  */
+  { "sidebar_delim_chars", DT_STR, R_SIDEBAR, UL &SidebarDelimChars, UL "/." },
+  /*
+  ** .pp
+  ** This contains the list of characters which you would like to treat
+  ** as folder separators for displaying paths in the sidebar.
+  ** .pp
+  ** Local mail is often arranged in directories: `dir1/dir2/mailbox'.
+  ** .ts
+  ** set sidebar_delim_chars='/'
+  ** .te
+  ** .pp
+  ** IMAP mailboxes are often named: `folder1.folder2.mailbox'.
+  ** .ts
+  ** set sidebar_delim_chars='.'
+  ** .te
+  ** .pp
+  ** \fBSee also:\fP $$sidebar_short_path, $$sidebar_folder_indent, $$sidebar_indent_string.
+  */
+  { "sidebar_folder_indent", DT_BOOL, R_SIDEBAR, OPTSIDEBARFOLDERINDENT, 0 },
+  /*
+  ** .pp
+  ** Set this to indent mailboxes in the sidebar.
+  ** .pp
+  ** \fBSee also:\fP $$sidebar_short_path, $$sidebar_indent_string, $$sidebar_delim_chars.
+  */
+  { "sidebar_format", DT_STR, R_SIDEBAR, UL &SidebarFormat, UL "%B%*  %n" },
+  /*
+  ** .pp
+  ** This variable allows you to customize the sidebar display. This string is
+  ** similar to $$index_format, but has its own set of \fCprintf(3)\fP-like
+  ** sequences:
+  ** .dl
+  ** .dt %B  .dd Name of the mailbox
+  ** .dt %S  .dd * Size of mailbox (total number of messages)
+  ** .dt %N  .dd * Number of New messages in the mailbox
+  ** .dt %n  .dd N if mailbox has new mail, blank otherwise
+  ** .dt %F  .dd * Number of Flagged messages in the mailbox
+  ** .dt %!  .dd ``!'' : one flagged message;
+  **             ``!!'' : two flagged messages;
+  **             ``n!'' : n flagged messages (for n > 2).
+  **             Otherwise prints nothing.
+  ** .dt %d  .dd * @ Number of deleted messages
+  ** .dt %L  .dd * @ Number of messages after limiting
+  ** .dt %t  .dd * @ Number of tagged messages
+  ** .dt %>X .dd right justify the rest of the string and pad with ``X''
+  ** .dt %|X .dd pad to the end of the line with ``X''
+  ** .dt %*X .dd soft-fill with character ``X'' as pad
+  ** .de
+  ** .pp
+  ** * = Can be optionally printed if nonzero
+  ** @ = Only applicable to the current folder
+  ** .pp
+  ** In order to use %S, %N, %F, and %!, $$mail_check_stats must
+  ** be \fIset\fP.  When thus set, a suggested value for this option is
+  ** "%B%?F? [%F]?%* %?N?%N/?%S".
+  */
+  { "sidebar_indent_string", DT_STR, R_SIDEBAR, UL &SidebarIndentString, UL "  " },
+  /*
+  ** .pp
+  ** This specifies the string that is used to indent mailboxes in the sidebar.
+  ** It defaults to two spaces.
+  ** .pp
+  ** \fBSee also:\fP $$sidebar_short_path, $$sidebar_folder_indent, $$sidebar_delim_chars.
+  */
+  { "sidebar_new_mail_only", DT_BOOL, R_SIDEBAR, OPTSIDEBARNEWMAILONLY, 0 },
+  /*
+  ** .pp
+  ** When set, the sidebar will only display mailboxes containing new, or
+  ** flagged, mail.
+  ** .pp
+  ** \fBSee also:\fP $sidebar_whitelist.
+  */
+  { "sidebar_next_new_wrap", DT_BOOL, R_NONE, UL OPTSIDEBARNEXTNEWWRAP, 0 },
+  /*
+  ** .pp
+  ** When set, the \fC<sidebar-next-new>\fP command will not stop and the end of
+  ** the list of mailboxes, but wrap around to the beginning. The
+  ** \fC<sidebar-prev-new>\fP command is similarly affected, wrapping around to
+  ** the end of the list.
+  */
+  { "sidebar_short_path", DT_BOOL, R_SIDEBAR, OPTSIDEBARSHORTPATH, 0 },
+  /*
+  ** .pp
+  ** By default the sidebar will show the mailbox's path, relative to the
+  ** $$folder variable. Setting \fCsidebar_shortpath=yes\fP will shorten the
+  ** names relative to the previous name. Here's an example:
+  ** .dl
+  ** .dt \fBshortpath=no\fP .dd \fBshortpath=yes\fP .dd \fBshortpath=yes, folderindent=yes, indentstr=".."\fP
+  ** .dt \fCfruit\fP        .dd \fCfruit\fP         .dd \fCfruit\fP
+  ** .dt \fCfruit.apple\fP  .dd \fCapple\fP         .dd \fC..apple\fP
+  ** .dt \fCfruit.banana\fP .dd \fCbanana\fP        .dd \fC..banana\fP
+  ** .dt \fCfruit.cherry\fP .dd \fCcherry\fP        .dd \fC..cherry\fP
+  ** .de
+  ** .pp
+  ** \fBSee also:\fP $$sidebar_delim_chars, $$sidebar_folder_indent, $$sidebar_indent_string.
+  */
+  { "sidebar_sort_method", DT_SORT|DT_SORT_SIDEBAR, R_SIDEBAR, UL &SidebarSortMethod, SORT_ORDER },
+  /*
+  ** .pp
+  ** Specifies how to sort entries in the file browser.  By default, the
+  ** entries are sorted alphabetically.  Valid values:
+  ** .il
+  ** .dd alpha (alphabetically)
+  ** .dd count (all message count)
+  ** .dd flagged (flagged message count)
+  ** .dd new (new message count)
+  ** .dd unsorted
+  ** .ie
+  ** .pp
+  ** You may optionally use the ``reverse-'' prefix to specify reverse sorting
+  ** order (example: ``\fCset sort_browser=reverse-date\fP'').
+  */
+  { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show sidebar. The sidebar shows a list of
+  ** all your mailboxes.
+  ** .pp
+  ** \fBSee also:\fP $$sidebar_format, $$sidebar_width
+  */
+  { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** This controls the width of the sidebar.  It is measured in screen columns.
+  ** For example: sidebar_width=20 could display 20 ASCII characters, or 10
+  ** Chinese characters.
+  */
+#endif
   { "sig_dashes",	DT_BOOL, R_NONE, OPTSIGDASHES, 1 },
   /*
   ** .pp
@@ -3652,6 +3807,18 @@ const struct mapping_t SortKeyMethods[] = {
   { NULL,       0 }
 };
 
+const struct mapping_t SortSidebarMethods[] = {
+  { "alpha",		SORT_PATH },
+  { "count",		SORT_COUNT },
+  { "flagged",		SORT_FLAGGED },
+  { "mailbox-order",	SORT_ORDER },
+  { "name",		SORT_PATH },
+  { "new",		SORT_COUNT_NEW },
+  { "path",		SORT_PATH },
+  { "unsorted",		SORT_ORDER },
+  { NULL,		0 }
+};
+
 
 /* functions used to parse commands in a rc file */
 
@@ -3741,6 +3908,9 @@ const struct command_t Commands[] = {
   { "send-hook",	mutt_parse_hook,	M_SENDHOOK },
   { "send2-hook",	mutt_parse_hook,	M_SEND2HOOK },
   { "set",		parse_set,		0 },
+#ifdef USE_SIDEBAR
+  { "sidebar_whitelist",parse_list,		UL &SidebarWhitelist },
+#endif
   { "source",		parse_source,		0 },
   { "spam",		parse_spam_list,	M_SPAM },
   { "nospam",		parse_spam_list,	M_NOSPAM },
diff --git a/mailbox.h b/mailbox.h
index 2b2c9a1..8ffcbce 100644
--- a/mailbox.h
+++ b/mailbox.h
@@ -20,13 +20,13 @@
 #define _MAILBOX_H
 
 /* flags for mutt_open_mailbox() */
-#define M_NOSORT	(1<<0) /* do not sort the mailbox after opening it */
-#define M_APPEND	(1<<1) /* open mailbox for appending messages */
-#define M_READONLY	(1<<2) /* open in read-only mode */
-#define M_QUIET		(1<<3) /* do not print any messages */
-#define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
-				* safe_fopen() for mbox-style folders.
-				*/
+#define M_NOSORT     (1<<0) /* do not sort the mailbox after opening it */
+#define M_APPEND     (1<<1) /* open mailbox for appending messages */
+#define M_READONLY   (1<<2) /* open in read-only mode */
+#define M_QUIET      (1<<3) /* do not print any messages */
+#define M_NEWFOLDER  (1<<4) /* create a new folder - same as M_APPEND, but uses
+                                * safe_fopen() for mbox-style folders. */
+#define M_PEEK       (1<<5) /* revert atime back after taking a look (if applicable) */
 
 /* mx_open_new_message() */
 #define M_ADD_FROM	(1<<0)	/* add a From_ line */
diff --git a/main.c b/main.c
index d0a1128..67859ee 100644
--- a/main.c
+++ b/main.c
@@ -31,6 +31,9 @@
 #include "url.h"
 #include "mutt_crypt.h"
 #include "mutt_idna.h"
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
 
 #ifdef USE_SASL
 #include "mutt_sasl.h"
@@ -485,6 +488,12 @@ static void show_version (void)
 	"-USE_HCACHE  "
 #endif
 
+#ifdef USE_SIDEBAR
+	"+USE_SIDEBAR  "
+#else
+	"-USE_SIDEBAR  "
+#endif
+
 	);
 
 #ifdef ISPELL
@@ -828,6 +837,9 @@ int main (int argc, char **argv)
     clear ();
     mutt_error = mutt_curses_error;
     mutt_message = mutt_curses_message;
+#ifdef USE_SIDEBAR
+    mutt_sb_init();
+#endif
   }
 
   /* Create the Maildir directory if it doesn't exist. */
@@ -1206,6 +1218,9 @@ int main (int argc, char **argv)
     if((Context = mx_open_mailbox (folder, ((flags & M_RO) || option (OPTREADONLY)) ? M_READONLY : 0, NULL))
        || !explicit_folder)
     {
+#ifdef USE_SIDEBAR
+      mutt_sb_set_open_buffy ();
+#endif
       mutt_index_menu ();
       if (Context)
 	FREE (&Context);
diff --git a/mbox.c b/mbox.c
index 95cba65..3e85518 100644
--- a/mbox.c
+++ b/mbox.c
@@ -100,6 +100,7 @@ int mmdf_parse_mailbox (CONTEXT *ctx)
     mutt_perror (ctx->path);
     return (-1);
   }
+  ctx->atime = sb.st_atime;
   ctx->mtime = sb.st_mtime;
   ctx->size = sb.st_size;
 
@@ -251,6 +252,7 @@ int mbox_parse_mailbox (CONTEXT *ctx)
 
   ctx->size = sb.st_size;
   ctx->mtime = sb.st_mtime;
+  ctx->atime = sb.st_atime;
 
 #ifdef NFS_ATTRIBUTE_HACK
   if (sb.st_mtime > sb.st_atime)
diff --git a/menu.c b/menu.c
index 828df9c..729200e 100644
--- a/menu.c
+++ b/menu.c
@@ -24,6 +24,9 @@
 #include "mutt_curses.h"
 #include "mutt_menu.h"
 #include "mbyte.h"
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
 
 char* SearchBuffers[MENU_MAX];
 
@@ -184,7 +187,7 @@ static void menu_pad_string (char *s, size_t n)
 {
   char *scratch = safe_strdup (s);
   int shift = option (OPTARROWCURSOR) ? 3 : 0;
-  int cols = COLS - shift;
+  int cols = COLS - shift - SidebarWidth;
 
   mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
   s[n - 1] = 0;
@@ -216,6 +219,9 @@ void menu_redraw_full (MUTTMENU *menu)
   mutt_show_error ();
 
   menu->redraw = REDRAW_INDEX | REDRAW_STATUS;
+#ifdef USE_SIDEBAR
+  menu->redraw |= REDRAW_SIDEBAR;
+#endif
 }
 
 void menu_redraw_status (MUTTMENU *menu)
@@ -230,6 +236,14 @@ void menu_redraw_status (MUTTMENU *menu)
   menu->redraw &= ~REDRAW_STATUS;
 }
 
+#ifdef USE_SIDEBAR
+void menu_redraw_sidebar (MUTTMENU *menu)
+{
+  SidebarNeedsRedraw = 0;
+  mutt_sb_draw ();
+}
+#endif
+
 void menu_redraw_index (MUTTMENU *menu)
 {
   char buf[LONG_STRING];
@@ -247,7 +261,7 @@ void menu_redraw_index (MUTTMENU *menu)
       menu_pad_string (buf, sizeof (buf));
 
       ATTRSET(attr);
-      move(i - menu->top + menu->offset, 0);
+      move(i - menu->top + menu->offset, SidebarWidth);
       do_color = 1;
 
       if (i == menu->current)
@@ -270,7 +284,11 @@ void menu_redraw_index (MUTTMENU *menu)
     else
     {
       NORMAL_COLOR;
+#ifdef USE_SIDEBAR
+      CLEARLINE_WIN(i - menu->top + menu->offset);
+#else
       CLEARLINE(i - menu->top + menu->offset);
+#endif
     }
   }
   NORMAL_COLOR;
@@ -287,7 +305,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     return;
   }
   
-  move (menu->oldcurrent + menu->offset - menu->top, 0);
+  move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   ATTRSET(menu->color (menu->oldcurrent));
 
   if (option (OPTARROWCURSOR))
@@ -299,13 +317,13 @@ void menu_redraw_motion (MUTTMENU *menu)
     {
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (buf, sizeof (buf));
-      move (menu->oldcurrent + menu->offset - menu->top, 3);
+      move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
       print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
     }
 
     /* now draw it in the new location */
     SETCOLOR(MT_COLOR_INDICATOR);
-    mvaddstr(menu->current + menu->offset - menu->top, 0, "->");
+    mvaddstr(menu->current + menu->offset - menu->top, SidebarWidth, "->");
   }
   else
   {
@@ -318,7 +336,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     menu_make_entry (buf, sizeof (buf), menu, menu->current);
     menu_pad_string (buf, sizeof (buf));
     SETCOLOR(MT_COLOR_INDICATOR);
-    move(menu->current - menu->top + menu->offset, 0);
+    move(menu->current - menu->top + menu->offset, SidebarWidth);
     print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
   }
   menu->redraw &= REDRAW_STATUS;
@@ -330,7 +348,7 @@ void menu_redraw_current (MUTTMENU *menu)
   char buf[LONG_STRING];
   int attr = menu->color (menu->current);
   
-  move (menu->current + menu->offset - menu->top, 0);
+  move (menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (buf, sizeof (buf));
 
@@ -835,6 +853,10 @@ int menu_redraw (MUTTMENU *menu)
   
   if (menu->redraw & REDRAW_STATUS)
     menu_redraw_status (menu);
+#ifdef USE_SIDEBAR
+  if (menu->redraw & REDRAW_SIDEBAR || SidebarNeedsRedraw)
+    menu_redraw_sidebar (menu);
+#endif
   if (menu->redraw & REDRAW_INDEX)
     menu_redraw_index (menu);
   else if (menu->redraw & (REDRAW_MOTION | REDRAW_MOTION_RESYNCH))
@@ -873,7 +895,7 @@ int mutt_menuLoop (MUTTMENU *menu)
     
     
     if (option (OPTARROWCURSOR))
-      move (menu->current - menu->top + menu->offset, 2);
+      move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
     else if (option (OPTBRAILLEFRIENDLY))
       move (menu->current - menu->top + menu->offset, 0);
     else
diff --git a/mh.c b/mh.c
index bc87660..ecec925 100644
--- a/mh.c
+++ b/mh.c
@@ -261,38 +261,86 @@ static int mh_already_notified(BUFFY *b, int msgno)
   return -1;
 }
 
-void mh_buffy(BUFFY *b)
+/* Checks new mail for a mh mailbox.
+ * check_stats: if true, also count total, new, and flagged mesages.
+ * Returns 1 if the mailbox has new mail.
+ */
+int mh_buffy (BUFFY *mailbox, int check_stats)
 {
   int i;
   struct mh_sequences mhs;
-
-  b->new = 0;
+  int check_new = 1;
+  int rc = 0;
+  DIR *dirp;
+  struct dirent *de;
 
   /* when $mail_check_recent is set and the .mh_sequences file hasn't changed
-   * since the last mailbox visit, there is nothing to do */
-  if (option(OPTMAILCHECKRECENT) && mh_sequences_changed(b) <= 0)
-      return;
+   * since the last mailbox visit, there is no "new mail" */
+  if (option(OPTMAILCHECKRECENT) && mh_sequences_changed(mailbox) <= 0)
+  {
+    rc = 0;
+    check_new = 0;
+  }
+
+  if (! (check_new || check_stats))
+    return rc;
 
   memset (&mhs, 0, sizeof (mhs));
+  if (mh_read_sequences (&mhs, mailbox->path) < 0)
+    return 0;
 
-  if (mh_read_sequences (&mhs, b->path) < 0)
-    return;
+  if (check_stats)
+  {
+    mailbox->msg_count   = 0;
+    mailbox->msg_unread  = 0;
+    mailbox->msg_flagged = 0;
+  }
 
-  /* Traverse the sequence from high to low in order to support
-   * $mail_check_recent.  Given that new messages are appended, this should
-   * also be faster when it is unset as well.
-   */
   for (i = mhs.max; i > 0; i--)
   {
+    if (check_stats &&
+        (mhs_check (&mhs, i) & MH_SEQ_FLAGGED))
+      mailbox->msg_flagged++;
     if (mhs_check (&mhs, i) & MH_SEQ_UNSEEN)
     {
-      /* if the first unseen message we encounter was in the mailbox during the last visit, don't notify about it */
-      if (!option(OPTMAILCHECKRECENT) || mh_already_notified(b, i) == 0)
-	b->new = 1;
-      break;
+      if (check_stats)
+        mailbox->msg_unread++;
+      if (check_new)
+      {
+        /* if the first unseen message we encounter was in the mailbox during the
+           last visit, don't notify about it */
+        if (!option(OPTMAILCHECKRECENT) || mh_already_notified(mailbox, i) == 0)
+        {
+          mailbox->new = 1;
+          rc = 1;
+        }
+        /* Because we are traversing from high to low, we can stop
+         * checking for new mail after the first unseen message.
+         * Whether it resulted in "new mail" or not. */
+        check_new = 0;
+        if (!check_stats)
+          break;
+      }
     }
   }
   mhs_free_sequences (&mhs);
+
+  if (check_stats)
+  {
+    if ((dirp = opendir (mailbox->path)) != NULL)
+    {
+      while ((de = readdir (dirp)) != NULL)
+      {
+        if (*de->d_name == '.')
+          continue;
+        if (mh_valid_message (de->d_name))
+          mailbox->msg_count++;
+      }
+      closedir (dirp);
+    }
+  }
+
+  return rc;
 }
 
 static int mh_mkstemp (CONTEXT * dest, FILE ** fp, char **tgt)
diff --git a/mutt.h b/mutt.h
index de26fd8..b68731f 100644
--- a/mutt.h
+++ b/mutt.h
@@ -388,6 +388,7 @@ enum
   OPTKEEPFLAGGED,
   OPTMAILCAPSANITIZE,
   OPTMAILCHECKRECENT,
+  OPTMAILCHECKSTATS,
   OPTMAILDIRTRASH,
   OPTMAILDIRCHECKCUR,
   OPTMARKERS,
@@ -428,6 +429,13 @@ enum
   OPTSAVEEMPTY,
   OPTSAVENAME,
   OPTSCORE,
+#ifdef USE_SIDEBAR
+  OPTSIDEBAR,
+  OPTSIDEBARFOLDERINDENT,
+  OPTSIDEBARNEWMAILONLY,
+  OPTSIDEBARNEXTNEWWRAP,
+  OPTSIDEBARSHORTPATH,
+#endif
   OPTSIGDASHES,
   OPTSIGONTOP,
   OPTSORTRE,
@@ -871,7 +879,9 @@ enum
 typedef struct _context
 {
   char *path;
+  char *realpath;               /* used for buffy comparison and the sidebar */
   FILE *fp;
+  time_t atime;
   time_t mtime;
   off_t size;
   off_t vsize;
@@ -906,6 +916,7 @@ typedef struct _context
   unsigned int quiet : 1;	/* inhibit status messages? */
   unsigned int collapsed : 1;   /* are all threads collapsed? */
   unsigned int closing : 1;	/* mailbox is being closed */
+  unsigned int peekonly : 1;	/* just taking a glance, revert atime */
 
   /* driver hooks */
   void *data;			/* driver specific data */
diff --git a/mutt_curses.h b/mutt_curses.h
index 93d9aea..2bfa1ae 100644
--- a/mutt_curses.h
+++ b/mutt_curses.h
@@ -64,6 +64,9 @@
 #undef lines
 #endif /* lines */
 
+#ifdef USE_SIDEBAR
+#define CLEARLINE_WIN(x) move (x,SidebarWidth), clrtoeol()
+#endif
 #define CLEARLINE(x) move(x,0), clrtoeol()
 #define CENTERLINE(x,y) move(y, (COLS-strlen(x))/2), addstr(x)
 #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
@@ -124,6 +127,14 @@ enum
   MT_COLOR_UNDERLINE,
   MT_COLOR_INDEX,
   MT_COLOR_PROMPT,
+#ifdef USE_SIDEBAR
+  MT_COLOR_DIVIDER,
+  MT_COLOR_FLAGGED,
+  MT_COLOR_HIGHLIGHT,
+  MT_COLOR_NEW,
+  MT_COLOR_SB_INDICATOR,
+  MT_COLOR_SB_SPOOLFILE,
+#endif
   MT_COLOR_MAX
 };
 
@@ -163,12 +174,16 @@ void mutt_progress_update (progress_t* progress, long pos, int percent);
 
 static inline int mutt_term_width(short wrap)
 {
+  int cols = COLS;
+#ifdef USE_SIDEBAR
+  cols -= SidebarWidth;
+#endif
   if (wrap < 0)
-    return COLS > -wrap ? COLS + wrap : COLS;
+    return cols > -wrap ? cols + wrap : cols;
   else if (wrap)
-    return wrap < COLS ? wrap : COLS;
+    return wrap < cols ? wrap : cols;
   else
-    return COLS;
+    return cols;
 }
 
 extern int *ColorQuote;
diff --git a/mutt_menu.h b/mutt_menu.h
index 8192019..a486d88 100644
--- a/mutt_menu.h
+++ b/mutt_menu.h
@@ -34,6 +34,9 @@
 #define REDRAW_FULL		(1<<5)
 #define REDRAW_BODY		(1<<6)
 #define REDRAW_SIGWINCH		(1<<7)
+#ifdef USE_SIDEBAR
+#define REDRAW_SIDEBAR		(1<<8)
+#endif
 
 #define M_MODEFMT "-- Mutt: %s"
 
@@ -82,6 +85,9 @@ typedef struct menu_t
 void mutt_menu_init (void);
 void menu_jump (MUTTMENU *);
 void menu_redraw_full (MUTTMENU *);
+#ifdef USE_SIDEBAR
+void menu_redraw_sidebar (MUTTMENU *);
+#endif
 void menu_redraw_index (MUTTMENU *);
 void menu_redraw_status (MUTTMENU *);
 void menu_redraw_motion (MUTTMENU *);
diff --git a/muttlib.c b/muttlib.c
index a57dbf4..b7eba7a 100644
--- a/muttlib.c
+++ b/muttlib.c
@@ -1053,6 +1053,7 @@ void mutt_safe_path (char *s, size_t l, ADDRESS *a)
 void mutt_FormatString (char *dest,		/* output buffer */
 			size_t destlen,		/* output buffer len */
 			size_t col,		/* starting column (nonzero when called recursively) */
+                        int cols,               /* maximum columns */
 			const char *src,	/* template string */
 			format_t *callback,	/* callback for processing */
 			unsigned long data,	/* callback data */
@@ -1117,7 +1118,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
         mutt_extract_token(word, srcbuf, 0);
         dprint(3, (debugfile, "fmtpipe %2d: %s\n", i++, word->data));
         mutt_buffer_addch(command, '\'');
-        mutt_FormatString(buf, sizeof(buf), 0, word->data, callback, data,
+        mutt_FormatString(buf, sizeof(buf), 0, cols, word->data, callback, data,
                           flags | M_FORMAT_NOFILTER);
         for (p = buf; p && *p; p++)
         {
@@ -1172,7 +1173,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 		 * it back for the recursive call since the expansion of
 		 * format pipes does not try to append a nul itself.
 		 */
-		mutt_FormatString(dest, destlen+1, col, recycler, callback, data, flags);
+		mutt_FormatString(dest, destlen+1, col, cols, recycler, callback, data, flags);
 		FREE(&recycler);
 	      }
 	    }
@@ -1282,23 +1283,35 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  pl = pw = 1;
 
 	/* see if there's room to add content, else ignore */
-	if ((col < COLS && wlen < destlen) || soft)
+	if ((col < cols && wlen < destlen) || soft)
 	{
 	  int pad;
 
 	  /* get contents after padding */
-	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+	  mutt_FormatString (buf, sizeof (buf), 0, cols, src + pl, callback, data, flags);
 	  len = mutt_strlen (buf);
 	  wid = mutt_strwidth (buf);
 
-	  /* try to consume as many columns as we can, if we don't have
-	   * memory for that, use as much memory as possible */
-	  pad = (COLS - col - wid) / pw;
-	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
-	    pad = ((signed)(destlen - wlen - len)) / pl;
-	  if (pad > 0)
+	  pad = (cols - col - wid) / pw;
+	  if (pad >= 0)
 	  {
-	    while (pad--)
+            /* try to consume as many columns as we can, if we don't have
+             * memory for that, use as much memory as possible */
+            if (wlen + (pad * pl) + len > destlen)
+              pad = (destlen > wlen + len) ? ((destlen - wlen - len) / pl) : 0;
+            else
+            {
+              /* Add pre-spacing to make multi-column pad characters and
+               * the contents after padding line up */
+              while ((col + (pad * pw) + wid < cols) &&
+                     (wlen + (pad * pl) + len < destlen))
+              {
+                *wptr++ = ' ';
+                wlen++;
+                col++;
+              }
+            }
+	    while (pad-- > 0)
 	    {
 	      memcpy (wptr, src, pl);
 	      wptr += pl;
@@ -1312,13 +1325,13 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
 	    *wptr = 0;
 	    /* make sure right part is at most as wide as display */
-	    len = mutt_wstr_trunc (buf, destlen, COLS-offset, &wid);
+	    len = mutt_wstr_trunc (buf, destlen, COLS - offset - SidebarWidth, &wid);
 	    /* truncate left so that right part fits completely in */
 	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad*pw -offset, &col);
 	    wptr = dest + wlen;
 	  }
 	  if (len + wlen > destlen)
-	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+	    len = mutt_wstr_trunc (buf, destlen - wlen, cols - col, NULL);
 	  memcpy (wptr, buf, len);
 	  wptr += len;
 	  wlen += len;
@@ -1335,9 +1348,9 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	  pl = pw = 1;
 
 	/* see if there's room to add content, else ignore */
-	if (col < COLS && wlen < destlen)
+	if (col < cols && wlen < destlen)
 	{
-	  c = (COLS - col) / pw;
+	  c = (cols - col) / pw;
 	  if (c > 0 && wlen + (c * pl) > destlen)
 	    c = ((signed)(destlen - wlen)) / pl;
 	  while (c > 0)
@@ -1368,7 +1381,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	}
 	
 	/* use callback function to handle this case */
-	src = callback (buf, sizeof (buf), col, ch, src, prefix, ifstring, elsestring, data, flags);
+	src = callback (buf, sizeof (buf), col, cols, ch, src, prefix, ifstring, elsestring, data, flags);
 
 	if (tolower)
 	  mutt_strlower (buf);
@@ -1381,7 +1394,7 @@ void mutt_FormatString (char *dest,		/* output buffer */
 	}
 	
 	if ((len = mutt_strlen (buf)) + wlen > destlen)
-	  len = mutt_wstr_trunc (buf, destlen - wlen, COLS - col, NULL);
+	  len = mutt_wstr_trunc (buf, destlen - wlen, cols - col, NULL);
 
 	memcpy (wptr, buf, len);
 	wptr += len;
diff --git a/mx.c b/mx.c
index acc81d4..0a146e5 100644
--- a/mx.c
+++ b/mx.c
@@ -29,6 +29,9 @@
 #include "copy.h"
 #include "keymap.h"
 #include "url.h"
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
 
 #ifdef USE_IMAP
 #include "imap.h"
@@ -580,6 +583,7 @@ static int mx_open_mailbox_append (CONTEXT *ctx, int flags)
  *		M_APPEND	open mailbox for appending
  *		M_READONLY	open mailbox in read-only mode
  *		M_QUIET		only print error messages
+ *		M_PEEK		revert atime where applicable
  *	ctx	if non-null, context struct to use
  */
 CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
@@ -591,6 +595,8 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
     ctx = safe_malloc (sizeof (CONTEXT));
   memset (ctx, 0, sizeof (CONTEXT));
   ctx->path = safe_strdup (path);
+  if (! (ctx->realpath = realpath (ctx->path, NULL)) )
+    ctx->realpath = safe_strdup (ctx->path);
 
   ctx->msgnotreadyet = -1;
   ctx->collapsed = 0;
@@ -602,6 +608,8 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
     ctx->quiet = 1;
   if (flags & M_READONLY)
     ctx->readonly = 1;
+  if (flags & M_PEEK)
+    ctx->peekonly = 1;
 
   if (flags & (M_APPEND|M_NEWFOLDER))
   {
@@ -701,13 +709,22 @@ CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
 void mx_fastclose_mailbox (CONTEXT *ctx)
 {
   int i;
+  struct utimbuf ut;
 
   if(!ctx) 
     return;
 
+  /* fix up the times so buffy won't get confused */
+  if (ctx->peekonly && ctx->path && (ctx->mtime > ctx->atime)) {
+    ut.actime  = ctx->atime;
+    ut.modtime = ctx->mtime;
+    utime (ctx->path, &ut);
+  }
+
   /* never announce that a mailbox we've just left has new mail. #3290
    * XXX: really belongs in mx_close_mailbox, but this is a nice hook point */
-  mutt_buffy_setnotified(ctx->path);
+  if (!ctx->peekonly)
+    mutt_buffy_setnotified(ctx->path);
 
   if (ctx->mx_close)
     ctx->mx_close (ctx);
@@ -722,6 +739,7 @@ void mx_fastclose_mailbox (CONTEXT *ctx)
   FREE (&ctx->hdrs);
   FREE (&ctx->v2r);
   FREE (&ctx->path);
+  FREE (&ctx->realpath);
   FREE (&ctx->pattern);
   if (ctx->limit_pattern) 
     mutt_pattern_free (&ctx->limit_pattern);
@@ -812,6 +830,12 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
     if (!ctx->hdrs[i]->deleted && ctx->hdrs[i]->read 
         && !(ctx->hdrs[i]->flagged && option (OPTKEEPFLAGGED)))
       read_msgs++;
+#ifdef USE_SIDEBAR
+    if (ctx->hdrs[i]->deleted && !ctx->hdrs[i]->read)
+      ctx->unread--;
+    if (ctx->hdrs[i]->deleted && ctx->hdrs[i]->flagged)
+      ctx->flagged--;
+#endif
   }
 
   if (read_msgs && quadoption (OPT_MOVE) != M_NO)
@@ -981,6 +1005,11 @@ int mx_close_mailbox (CONTEXT *ctx, int *index_hint)
       !mutt_is_spool(ctx->path) && !option (OPTSAVEEMPTY))
     mx_unlink_empty (ctx->path);
 
+#ifdef USE_SIDEBAR
+  ctx->msgcount -= ctx->deleted;
+  mutt_sb_set_buffystats (ctx);
+#endif
+
   mx_fastclose_mailbox (ctx);
 
   return 0;
diff --git a/mx.h b/mx.h
index dd77ba4..ddb6bce 100644
--- a/mx.h
+++ b/mx.h
@@ -26,6 +26,7 @@
 #define _MX_H
 
 #include "mailbox.h"
+#include "buffy.h"
 
 /* supported mailbox formats */
 enum
diff --git a/pager.c b/pager.c
index 8bfe72c..fe79a89 100644
--- a/pager.c
+++ b/pager.c
@@ -29,6 +29,9 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#ifdef USE_SIDEBAR
+#include "sidebar.h"
+#endif
 
 #include "mutt_crypt.h"
 
@@ -1491,7 +1494,7 @@ display_line (FILE *f, LOFF_T *last_pos, struct line_t **lineInfo, int n,
    * a newline (grr!).
    */
 #ifndef USE_SLANG_CURSES
-    if (col < COLS)
+    if (col < (COLS - SidebarWidth))
 #endif
       addch ('\n');
 
@@ -1573,6 +1576,7 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 
   int bodyoffset = 1;			/* offset of first line of real text */
   int statusoffset = 0; 		/* offset for the status bar */
+  int statuswidth = COLS;
   int helpoffset = LINES - 2;		/* offset for the help bar. */
   int bodylen = LINES - 2 - bodyoffset; /* length of displayable area */
 
@@ -1726,6 +1730,9 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       }
 
       redraw |= REDRAW_BODY | REDRAW_INDEX | REDRAW_STATUS;
+#ifdef USE_SIDEBAR
+      redraw |= REDRAW_SIDEBAR;
+#endif
       mutt_show_error ();
     }
 
@@ -1744,10 +1751,18 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	}
     }
 
+#ifdef USE_SIDEBAR
+    if ((redraw & REDRAW_SIDEBAR) || SidebarNeedsRedraw)
+    {
+      SidebarNeedsRedraw = 0;
+      mutt_sb_draw ();
+    }
+#endif
+
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-	move (bodyoffset, 0);
+	move (bodyoffset, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1760,6 +1775,9 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
 	    lines++;
 	  curline++;
+#ifdef USE_SIDEBAR
+	  move (lines + bodyoffset, SidebarWidth);
+#endif
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1772,6 +1790,9 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
 	  addch ('~');
 	addch ('\n');
 	lines++;
+#ifdef USE_SIDEBAR
+	move (lines + bodyoffset, SidebarWidth);
+#endif
       }
       NORMAL_COLOR;
 
@@ -1789,29 +1810,49 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       hfi.ctx = Context;
       hfi.pager_progress = pager_progress_str;
 
+#ifdef USE_SIDEBAR
+      statuswidth = COLS;
+      if (option (OPTSTATUSONTOP) && (PagerIndexLines > 0))
+        statuswidth -= SidebarWidth;
+#endif
+
       if (last_pos < sb.st_size - 1)
 	snprintf(pager_progress_str, sizeof(pager_progress_str), OFF_T_FMT "%%", (100 * last_offset / sb.st_size));
       else
 	strfcpy(pager_progress_str, (topline == 0) ? "all" : "end", sizeof(pager_progress_str));
 
       /* print out the pager status bar */
-      move (statusoffset, 0);
+      move (statusoffset, SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
+#ifdef USE_SIDEBAR
+      short sw = SidebarWidth;
+      if (option (OPTSTATUSONTOP) && PagerIndexLines > 0) {
+        CLEARLINE_WIN (statusoffset);
+      } else {
+        CLEARLINE (statusoffset);
+        /* Temporarily lie about the sidebar width */
+        SidebarWidth = 0;
+      }
+#endif
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = COLS * MB_LEN_MAX;
+	size_t l1 = statuswidth * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (COLS, buffer);
+	mutt_paddstr (statuswidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (COLS, bn);
+	mutt_paddstr (statuswidth, bn);
       }
+#ifdef USE_SIDEBAR
+      if (!option (OPTSTATUSONTOP) || PagerIndexLines == 0)
+        SidebarWidth = sw; /* Restore the sidebar width */
+#endif
       NORMAL_COLOR;
       if (option(OPTTSENABLED) && TSSupported)
       {
@@ -1827,16 +1868,26 @@ mutt_pager (const char *banner, const char *fname, int flags, pager_t *extra)
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
       menu_redraw_current (index);
+#ifdef USE_SIDEBAR
+      mutt_sb_draw();
+#endif
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), 0);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)),
+          (option(OPTSTATUSONTOP) ? 0: SidebarWidth));
       SETCOLOR (MT_COLOR_STATUS);
-      mutt_paddstr (COLS, buffer);
+      mutt_paddstr (COLS - (option(OPTSTATUSONTOP) ? 0 : SidebarWidth), buffer);
       NORMAL_COLOR;
     }
 
+#ifdef USE_SIDEBAR
+    /* if we're not using the index, update every time */
+    if (index == 0)
+      mutt_sb_draw();
+#endif
+
     redraw = 0;
 
     if (option(OPTBRAILLEFRIENDLY)) {
@@ -2777,6 +2828,22 @@ search_next:
 	mutt_what_key ();
 	break;
 
+#ifdef USE_SIDEBAR
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_NEXT_NEW:
+      case OP_SIDEBAR_PAGE_DOWN:
+      case OP_SIDEBAR_PAGE_UP:
+      case OP_SIDEBAR_PREV:
+      case OP_SIDEBAR_PREV_NEW:
+	mutt_sb_change_mailbox (ch);
+	break;
+
+      case OP_SIDEBAR_TOGGLE_VISIBLE:
+	toggle_option (OPTSIDEBAR);
+	redraw = REDRAW_FULL;
+	break;
+#endif
+
       default:
 	ch = -1;
 	break;
diff --git a/pgpinvoke.c b/pgpinvoke.c
index 7334192..a108b4e 100644
--- a/pgpinvoke.c
+++ b/pgpinvoke.c
@@ -59,6 +59,7 @@ struct pgp_command_context {
 const char *_mutt_fmt_pgp_command (char *dest,
 				   size_t destlen,
 				   size_t col,
+                                   int cols,
 				   char op,
 				   const char *src,
 				   const char *prefix,
@@ -140,16 +141,16 @@ const char *_mutt_fmt_pgp_command (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, _mutt_fmt_pgp_command, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, _mutt_fmt_pgp_command, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, _mutt_fmt_pgp_command, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, _mutt_fmt_pgp_command, data, 0);
 
   return (src);
 }
 
 void mutt_pgp_command (char *d, size_t dlen, struct pgp_command_context *cctx, const char *fmt)
 {
-  mutt_FormatString (d, dlen, 0, NONULL (fmt), _mutt_fmt_pgp_command, (unsigned long) cctx, 0);
+  mutt_FormatString (d, dlen, 0, COLS - SidebarWidth, NONULL (fmt), _mutt_fmt_pgp_command, (unsigned long) cctx, 0);
   dprint (2, (debugfile, "mutt_pgp_command: %s\n", d));
 }
 
diff --git a/pgpkey.c b/pgpkey.c
index 80bd7de..849fa49 100644
--- a/pgpkey.c
+++ b/pgpkey.c
@@ -122,6 +122,7 @@ typedef struct pgp_entry
 static const char *pgp_entry_fmt (char *dest,
 				  size_t destlen,
 				  size_t col,
+                                  int cols,
 				  char op,
 				  const char *src,
 				  const char *prefix,
@@ -278,9 +279,9 @@ static const char *pgp_entry_fmt (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
 
@@ -292,7 +293,7 @@ static void pgp_entry (char *s, size_t l, MUTTMENU * menu, int num)
   entry.uid = KeyTable[num];
   entry.num = num + 1;
 
-  mutt_FormatString (s, l, 0, NONULL (PgpEntryFormat), pgp_entry_fmt, 
+  mutt_FormatString (s, l, 0, COLS - SidebarWidth, NONULL (PgpEntryFormat), pgp_entry_fmt, 
 		     (unsigned long) &entry, M_FORMAT_ARROWCURSOR);
 }
 
diff --git a/pop.c b/pop.c
index 11af0ab..4ef0e11 100644
--- a/pop.c
+++ b/pop.c
@@ -421,7 +421,9 @@ int pop_open_mailbox (CONTEXT *ctx)
     return -1;
 
   FREE (&ctx->path);
+  FREE (&ctx->realpath);
   ctx->path = safe_strdup (buf);
+  ctx->realpath = safe_strdup (ctx->path);
 
   pop_data = safe_calloc (1, sizeof (POP_DATA));
   pop_data->conn = conn;
diff --git a/protos.h b/protos.h
index 8e5f7aa..686c5d1 100644
--- a/protos.h
+++ b/protos.h
@@ -71,9 +71,9 @@ int _mutt_traverse_thread (CONTEXT *ctx, HEADER *hdr, int flag);
 #define mutt_new_envelope() safe_calloc (1, sizeof (ENVELOPE))
 #define mutt_new_enter_state() safe_calloc (1, sizeof (ENTER_STATE))
 
-typedef const char * format_t (char *, size_t, size_t, char, const char *, const char *, const char *, const char *, unsigned long, format_flag);
+typedef const char * format_t (char *, size_t, size_t, int, char, const char *, const char *, const char *, const char *, unsigned long, format_flag);
 
-void mutt_FormatString (char *, size_t, size_t, const char *, format_t *, unsigned long, format_flag);
+void mutt_FormatString (char *, size_t, size_t, int, const char *, format_t *, unsigned long, format_flag);
 void mutt_parse_content_type (char *, BODY *);
 void mutt_generate_boundary (PARAMETER **);
 void mutt_delete_parameter (const char *attribute, PARAMETER **p);
@@ -127,6 +127,7 @@ const char *mutt_attach_fmt (
 	char *dest,
 	size_t destlen,
 	size_t col,
+        int cols,
 	char op,
 	const char *src,
 	const char *prefix,
diff --git a/query.c b/query.c
index 8bcffbd..605b823 100644
--- a/query.c
+++ b/query.c
@@ -24,6 +24,7 @@
 #include "mutt_menu.h"
 #include "mutt_idna.h"
 #include "mapping.h"
+#include "mutt_curses.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -183,7 +184,7 @@ static int query_search (MUTTMENU *m, regex_t *re, int n)
   return REG_NOMATCH;
 }
 
-static const char * query_format_str (char *dest, size_t destlen, size_t col,
+static const char * query_format_str (char *dest, size_t destlen, size_t col, int cols,
 				      char op, const char *src,
 				      const char *fmt, const char *ifstring,
 				      const char *elsestring,
@@ -230,9 +231,9 @@ static const char * query_format_str (char *dest, size_t destlen, size_t col,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, query_format_str, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, query_format_str, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, query_format_str, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, query_format_str, data, 0);
 
   return src;
 }
@@ -242,7 +243,7 @@ static void query_entry (char *s, size_t slen, MUTTMENU *m, int num)
   ENTRY *entry = &((ENTRY *) m->data)[num];
 
   entry->data->num = num;
-  mutt_FormatString (s, slen, 0, NONULL (QueryFormat), query_format_str,
+  mutt_FormatString (s, slen, 0, COLS - SidebarWidth, NONULL (QueryFormat), query_format_str,
 		     (unsigned long) entry, M_FORMAT_ARROWCURSOR);
 }
 
diff --git a/recvattach.c b/recvattach.c
index 5424eda..6bc30fe 100644
--- a/recvattach.c
+++ b/recvattach.c
@@ -173,6 +173,7 @@ ATTACHPTR **mutt_gen_attach_list (BODY *m,
 const char *mutt_attach_fmt (char *dest,
     size_t destlen,
     size_t col,
+    int cols,
     char op,
     const char *src,
     const char *prefix,
@@ -365,15 +366,15 @@ const char *mutt_attach_fmt (char *dest,
   }
   
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
 
 static void attach_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
-  mutt_FormatString (b, blen, 0, NONULL (AttachFormat), mutt_attach_fmt, (unsigned long) (((ATTACHPTR **)menu->data)[num]), M_FORMAT_ARROWCURSOR);
+  mutt_FormatString (b, blen, 0, COLS - SidebarWidth, NONULL (AttachFormat), mutt_attach_fmt, (unsigned long) (((ATTACHPTR **)menu->data)[num]), M_FORMAT_ARROWCURSOR);
 }
 
 int mutt_tag_attach (MUTTMENU *menu, int n, int m)
diff --git a/remailer.c b/remailer.c
index fe9c7f2..3f665af 100644
--- a/remailer.c
+++ b/remailer.c
@@ -375,6 +375,7 @@ static const char *mix_format_caps (REMAILER *r)
 static const char *mix_entry_fmt (char *dest,
 				  size_t destlen,
 				  size_t col,
+                                  int cols,
 				  char op,
 				  const char *src,
 				  const char *prefix,
@@ -427,9 +428,9 @@ static const char *mix_entry_fmt (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, ifstring, mutt_attach_fmt, data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, mutt_attach_fmt, data, 0);
+    mutt_FormatString (dest, destlen, col, cols, elsestring, mutt_attach_fmt, data, 0);
   return (src);
 }
 
@@ -438,7 +439,7 @@ static const char *mix_entry_fmt (char *dest,
 static void mix_entry (char *b, size_t blen, MUTTMENU *menu, int num)
 {
   REMAILER **type2_list = (REMAILER **) menu->data;
-  mutt_FormatString (b, blen, 0, NONULL (MixEntryFormat), mix_entry_fmt,
+  mutt_FormatString (b, blen, 0, COLS - SidebarWidth, NONULL (MixEntryFormat), mix_entry_fmt,
 		     (unsigned long) type2_list[num], M_FORMAT_ARROWCURSOR);
 }
 
diff --git a/sidebar.c b/sidebar.c
new file mode 100644
index 0000000..ea81e1e
--- /dev/null
+++ b/sidebar.c
@@ -0,0 +1,1077 @@
+/* Copyright (C) 2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * Copyright (C) 2015-2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */
+
+#if HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include "mutt.h"
+#include "buffy.h"
+#include "keymap.h"
+#include "mutt_curses.h"
+#include "mutt_menu.h"
+#include "sort.h"
+
+/* Previous values for some sidebar config */
+static short  OldVisible;	/* sidebar_visible */
+static short  OldWidth;		/* sidebar_width */
+static short PreviousSort = SORT_ORDER;  /* sidebar_sort_method */
+
+/**
+ * struct sidebar_entry - Info about folders in the sidebar
+ */
+typedef struct sidebar_entry
+{
+  char         box[STRING];     /* formatted mailbox name */
+  BUFFY       *buffy;
+  short        is_hidden;
+} SBENTRY;
+
+static int EntryCount = 0;
+static int EntryLen   = 0;
+static SBENTRY **Entries = NULL;
+
+static int TopIndex = -1;    /* First mailbox visible in sidebar */
+static int OpnIndex = -1;    /* Current (open) mailbox */
+static int HilIndex = -1;    /* Highlighted mailbox */
+static int BotIndex = -1;    /* Last mailbox visible in sidebar */
+
+/**
+ * cb_format_str - Create the string to show in the sidebar
+ * @dest:        Buffer in which to save string
+ * @destlen:     Buffer length
+ * @col:         Starting column, UNUSED
+ * @op:          printf-like operator, e.g. 'B'
+ * @src:         printf-like format string
+ * @prefix:      Field formatting string, UNUSED
+ * @ifstring:    If condition is met, display this string
+ * @elsestring:  Otherwise, display this string
+ * @data:        Pointer to our sidebar_entry
+ * @flags:       Format flags, e.g. M_FORMAT_OPTIONAL
+ *
+ * cb_format_str is a callback function for mutt_FormatString.  It understands
+ * six operators. '%B' : Mailbox name, '%F' : Number of flagged messages,
+ * '%N' : Number of new messages, '%S' : Size (total number of messages),
+ * '%!' : Icon denoting number of flagged messages.
+ * '%n' : N if folder has new mail, blank otherwise.
+ *
+ * Returns: src (unchanged)
+ */
+static const char *cb_format_str(char *dest, size_t destlen, size_t col, int cols, char op,
+                                 const char *src, const char *prefix, const char *ifstring,
+                                 const char *elsestring, unsigned long data, format_flag flags)
+{
+  SBENTRY *sbe = (SBENTRY *) data;
+  unsigned int optional;
+  char fmt[STRING];
+
+  if (!sbe || !dest)
+    return src;
+
+  dest[0] = 0;	/* Just in case there's nothing to do */
+
+  BUFFY *b = sbe->buffy;
+  if (!b)
+    return src;
+
+  int c = Context && (mutt_strcmp (Context->realpath, b->realpath) == 0);
+
+  optional = flags & M_FORMAT_OPTIONAL;
+
+  switch (op)
+  {
+    case 'B':
+      mutt_format_s (dest, destlen, prefix, sbe->box);
+      break;
+
+    case 'd':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, c ? Context->deleted : 0);
+      }
+      else if ((c && Context->deleted == 0) || !c)
+        optional = 0;
+      break;
+
+    case 'F':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, b->msg_flagged);
+      }
+      else if (b->msg_flagged == 0)
+        optional = 0;
+      break;
+
+    case 'L':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, c ? Context->vcount : b->msg_count);
+      }
+      else if ((c && Context->vcount == b->msg_count) || !c)
+        optional = 0;
+      break;
+
+    case 'N':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, b->msg_unread);
+      }
+      else if (b->msg_unread == 0)
+        optional = 0;
+      break;
+
+    case 'n':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sc", prefix);
+        snprintf (dest, destlen, fmt, b->new ? 'N' : ' ');
+      }
+      else if (b->new == 0)
+        optional = 0;
+      break;
+
+    case 'S':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, b->msg_count);
+      }
+      else if (b->msg_count == 0)
+        optional = 0;
+      break;
+
+    case 't':
+      if (!optional)
+      {
+        snprintf (fmt, sizeof (fmt), "%%%sd", prefix);
+        snprintf (dest, destlen, fmt, c ? Context->tagged : 0);
+      }
+      else if ((c && Context->tagged == 0) || !c)
+        optional = 0;
+      break;
+
+    case '!':
+      if (b->msg_flagged == 0)
+        mutt_format_s (dest, destlen, prefix, "");
+      else if (b->msg_flagged == 1)
+        mutt_format_s (dest, destlen, prefix, "!");
+      else if (b->msg_flagged == 2)
+        mutt_format_s (dest, destlen, prefix, "!!");
+      else
+      {
+        snprintf (fmt, sizeof (fmt), "%d!", b->msg_flagged);
+        mutt_format_s (dest, destlen, prefix, fmt);
+      }
+      break;
+  }
+
+  if (optional)
+    mutt_FormatString (dest, destlen, col, cols, ifstring,   cb_format_str, (unsigned long) sbe, flags);
+  else if (flags & M_FORMAT_OPTIONAL)
+    mutt_FormatString (dest, destlen, col, cols, elsestring, cb_format_str, (unsigned long) sbe, flags);
+
+  /* We return the format string, unchanged */
+  return src;
+}
+
+/**
+ * make_sidebar_entry - Turn mailbox data into a sidebar string
+ * @buf:     Buffer in which to save string
+ * @buflen:  Buffer length
+ * @width:   Desired width in screen cells
+ * @box:     Mailbox name
+ * @size:    Size (total number of messages)
+ * @new:     Number of new messages
+ * @flagged: Number of flagged messages
+ *
+ * Take all the relevant mailbox data and the desired screen width and then get
+ * mutt_FormatString to do the actual work. mutt_FormatString will callback to
+ * us using cb_format_str() for the sidebar specific formatting characters.
+ */
+static void make_sidebar_entry (char *buf, unsigned int buflen, int width, char *box,
+                                SBENTRY *sbe)
+{
+  if (!buf || !box || !sbe)
+    return;
+
+  strfcpy (sbe->box, box, sizeof (sbe->box));
+
+  mutt_FormatString (buf, buflen, 0, width, NONULL(SidebarFormat), cb_format_str, (unsigned long) sbe, 0);
+
+  /* Force string to be exactly the right width */
+  int w = mutt_strwidth (buf);
+  int s = strlen (buf);
+  width = MIN(buflen, width);
+  if (w < width)
+  {
+    /* Pad with spaces */
+    memset (buf + s, ' ', width - w);
+    buf[s + width - w] = 0;
+  }
+  else if (w > width)
+  {
+    /* Truncate to fit */
+    int len = mutt_wstr_trunc (buf, buflen, width, NULL);
+    buf[len] = 0;
+  }
+}
+
+/**
+ * cb_qsort_sbe - qsort callback to sort SBENTRYs
+ * @a: First  SBENTRY to compare
+ * @b: Second SBENTRY to compare
+ *
+ * Returns:
+ *	-1: a precedes b
+ *	 0: a and b are identical
+ *	 1: b precedes a
+ */
+static int cb_qsort_sbe (const void *a, const void *b)
+{
+  const SBENTRY *sbe1 = *(const SBENTRY **) a;
+  const SBENTRY *sbe2 = *(const SBENTRY **) b;
+  BUFFY *b1 = sbe1->buffy;
+  BUFFY *b2 = sbe2->buffy;
+
+  int result = 0;
+
+  switch ((SidebarSortMethod & SORT_MASK))
+  {
+    case SORT_COUNT:
+      result = (b2->msg_count - b1->msg_count);
+      break;
+    case SORT_COUNT_NEW:
+      result = (b2->msg_unread - b1->msg_unread);
+      break;
+    case SORT_FLAGGED:
+      result = (b2->msg_flagged - b1->msg_flagged);
+      break;
+    case SORT_PATH:
+      result = mutt_strcasecmp (b1->path, b2->path);
+      break;
+  }
+
+  if (SidebarSortMethod & SORT_REVERSE)
+    result = -result;
+
+  return result;
+}
+
+/**
+ * update_entries_visibility - Should a sidebar_entry be displayed in the sidebar
+ *
+ * For each SBENTRY in the Entries array, check whether we should display it.
+ * This is determined by several criteria.  If the BUFFY:
+ *	is the currently open mailbox
+ *	is the currently highlighted mailbox
+ *	has unread messages
+ *	has flagged messages
+ *	is whitelisted
+ */
+static void update_entries_visibility (void)
+{
+  short new_only = option (OPTSIDEBARNEWMAILONLY);
+  SBENTRY *sbe;
+  int i;
+
+  for (i = 0; i < EntryCount; i++)
+  {
+    sbe = Entries[i];
+
+    sbe->is_hidden = 0;
+
+    if (!new_only)
+      continue;
+
+    if ((i == OpnIndex) || (sbe->buffy->msg_unread  > 0) || sbe->buffy->new ||
+        (i == HilIndex) || (sbe->buffy->msg_flagged > 0))
+      continue;
+
+    if (Context && (mutt_strcmp (sbe->buffy->realpath, Context->realpath) == 0))
+      /* Spool directory */
+      continue;
+
+    if (mutt_find_list (SidebarWhitelist, sbe->buffy->path))
+      /* Explicitly asked to be visible */
+      continue;
+
+    sbe->is_hidden = 1;
+  }
+}
+
+/**
+ * unsort_entries - Restore Entries array order to match Buffy list order
+ */
+static void unsort_entries (void)
+{
+  BUFFY *cur = Incoming;
+  int i = 0, j;
+  SBENTRY *tmp;
+
+  while (cur && (i < EntryCount))
+  {
+    j = i;
+    while ((j < EntryCount) &&
+           (Entries[j]->buffy != cur))
+      j++;
+    if (j < EntryCount)
+    {
+      if (j != i)
+      {
+        tmp = Entries[i];
+        Entries[i] = Entries[j];
+        Entries[j] = tmp;
+      }
+      i++;
+    }
+    cur = cur->next;
+  }
+}
+
+/**
+ * sort_entries - Sort Entries array.
+ *
+ * Sort the Entries array according to the current sort config
+ * option "sidebar_sort_method". This calls qsort to do the work which calls our
+ * callback function "cb_qsort_sbe".
+ *
+ * Once sorted, the prev/next links will be reconstructed.
+ */
+static void sort_entries (void)
+{
+  short ssm = (SidebarSortMethod & SORT_MASK);
+
+  /* These are the only sort methods we understand */
+  if ((ssm == SORT_COUNT)     ||
+      (ssm == SORT_COUNT_NEW) ||
+      (ssm == SORT_FLAGGED)   ||
+      (ssm == SORT_PATH))
+    qsort (Entries, EntryCount, sizeof (*Entries), cb_qsort_sbe);
+  else if ((ssm == SORT_ORDER) &&
+           (SidebarSortMethod != PreviousSort))
+    unsort_entries ();
+}
+
+/**
+ * prepare_sidebar - Prepare the list of SBENTRYs for the sidebar display
+ * @page_size:  The number of lines on a page
+ *
+ * Before painting the sidebar, we determine which are visible, sort
+ * them and set up our page pointers.
+ *
+ * This is a lot of work to do each refresh, but there are many things that
+ * can change outside of the sidebar that we don't hear about.
+ *
+ * Returns:
+ *	0: No, don't draw the sidebar
+ *	1: Yes, draw the sidebar
+ */
+static int prepare_sidebar (int page_size)
+{
+  int i;
+  SBENTRY *opn_entry = NULL, *hil_entry = NULL;
+
+  if (!EntryCount)
+    return 0;
+
+  if (OpnIndex >= 0)
+    opn_entry = Entries[OpnIndex];
+  if (HilIndex >= 0)
+    hil_entry = Entries[HilIndex];
+
+  update_entries_visibility ();
+  sort_entries ();
+
+  for (i = 0; i < EntryCount; i++)
+  {
+    if (opn_entry == Entries[i])
+      OpnIndex = i;
+    if (hil_entry == Entries[i])
+      HilIndex = i;
+  }
+
+  if ((HilIndex < 0) || (SidebarSortMethod != PreviousSort))
+  {
+    if (OpnIndex >= 0)
+      HilIndex  = OpnIndex;
+    else
+      HilIndex  = 0;
+  }
+  if (TopIndex >= 0)
+    TopIndex = (HilIndex / page_size) * page_size;
+  else
+    TopIndex = HilIndex;
+
+  BotIndex = TopIndex + page_size - 1;
+  if (BotIndex > (EntryCount - 1))
+    BotIndex = EntryCount - 1;
+
+  PreviousSort = SidebarSortMethod;
+  return 1;
+}
+
+/**
+ * visible - Should we display the sidebar?
+ *
+ * After validating the config options "sidebar_visible" and "sidebar_width",
+ * determine whether we should should display the sidebar.
+ *
+ * When not visible, set the global SidebarWidth to 0.
+ *
+ * Returns:
+ *	Boolean
+ */
+static short
+visible (void)
+{
+  short new_visible = option (OPTSIDEBAR);
+  short new_width   = SidebarWidth;
+
+  if (OldWidth != new_width)
+  {
+    if (new_width > 0)
+    {
+      OldWidth = new_width;
+    }
+  }
+
+  if (OldVisible != new_visible)
+  {
+    if (new_visible)
+    {
+      set_option (OPTSIDEBAR);
+    }
+    else
+    {
+      unset_option (OPTSIDEBAR);
+    }
+    OldVisible = new_visible;
+  }
+  else if (new_width == 0)
+  {
+    unset_option (OPTSIDEBAR);
+    OldVisible = 0;
+  }
+
+  if (!option (OPTSIDEBAR))
+  {
+    SidebarWidth = 0;
+  }
+  else if (new_width == 0)
+  {
+    SidebarWidth = OldWidth;
+  }
+  else
+  {
+    SidebarWidth = new_width;
+  }
+
+  return new_visible;
+}
+
+/**
+ * draw_divider - Draw a line between the sidebar and the rest of mutt
+ * @first_row:  Screen line to start (0-based)
+ * @num_rows:   Number of rows to fill
+ *
+ * Draw a divider using characters from the config option "sidebar_divider_char".
+ * This can be an ASCII or Unicode character.  First we calculate this
+ * characters' width in screen columns, then subtract that from the config
+ * option "sidebar_width".
+ *
+ * Returns:
+ *	-1: Error: bad character, etc
+ *	0:  Error: 0 width character
+ *	n:  Success: character occupies n screen columns
+ */
+static int draw_divider (int first_row, int num_rows)
+{
+  /* Calculate the width of the delimiter in screen cells */
+  int delim_len = mutt_strwidth (SidebarDividerChar);
+
+  if (delim_len < 1)
+    return delim_len;
+
+  if ((SidebarWidth + delim_len) > (COLS + 1))
+    return 0;
+
+  if (delim_len > SidebarWidth)
+    return -1;
+
+  SETCOLOR(MT_COLOR_DIVIDER);
+
+  int i;
+  for (i = 0; i < num_rows; i++)
+  {
+    move (first_row + i, SidebarWidth - delim_len);
+    addstr (NONULL(SidebarDividerChar));
+  }
+
+  return delim_len;
+}
+
+/**
+ * fill_empty_space - Wipe the remaining Sidebar space
+ * @first_row:  Screen line to start (0-based)
+ * @num_rows:   Number of rows to fill
+ * @width:      Width of the Sidebar (minus the divider)
+ *
+ * Write spaces over the area the sidebar isn't using.
+ */
+static void fill_empty_space (int first_row, int num_rows, int width)
+{
+  /* Fill the remaining rows with blank space */
+  SETCOLOR(MT_COLOR_NORMAL);
+
+  int r;
+  for (r = 0; r < num_rows; r++)
+  {
+    int i = 0;
+    move (first_row + r, 0);
+    for (; i < width; i++)
+      addch (' ');
+  }
+}
+
+/**
+ * draw_sidebar - Write out a list of mailboxes, on the left
+ * @first_row:  Screen line to start (0-based)
+ * @num_rows:   Number of rows to fill
+ * @div_width:  Width in screen characters taken by the divider
+ *
+ * Display a list of mailboxes in a panel on the left.  What's displayed will
+ * depend on our index markers: TopBuffy, OpnBuffy, HilBuffy, BotBuffy.
+ * On the first run they'll be NULL, so we display the top of Mutt's list
+ * (Incoming).
+ *
+ * TopBuffy - first visible mailbox
+ * BotBuffy - last  visible mailbox
+ * OpnBuffy - mailbox shown in Mutt's Index Panel
+ * HilBuffy - Unselected mailbox (the paging follows this)
+ *
+ * The entries are formatted using "sidebar_format" and may be abbreviated:
+ * "sidebar_short_path", indented: "sidebar_folder_indent",
+ * "sidebar_indent_string" and sorted: "sidebar_sort_method".  Finally, they're
+ * trimmed to fit the available space.
+ */
+static void draw_sidebar (int first_row, int num_rows, int div_width)
+{
+  int entryidx;
+  SBENTRY *entry;
+  BUFFY *b;
+  if (TopIndex < 0)
+    return;
+
+  int w = MIN(COLS, (SidebarWidth - div_width));
+  int row = 0;
+  for (entryidx = TopIndex; (entryidx < EntryCount) && (row < num_rows); entryidx++)
+  {
+    entry = Entries[entryidx];
+    if (entry->is_hidden)
+      continue;
+    b = entry->buffy;
+
+    if (entryidx == OpnIndex)
+    {
+      if ((ColorDefs[MT_COLOR_SB_INDICATOR] != 0))
+        SETCOLOR(MT_COLOR_SB_INDICATOR);
+      else
+        SETCOLOR(MT_COLOR_INDICATOR);
+    }
+    else if (entryidx == HilIndex)
+      SETCOLOR(MT_COLOR_HIGHLIGHT);
+    else if ((ColorDefs[MT_COLOR_SB_SPOOLFILE] != 0) &&
+               (mutt_strcmp (b->path, Spoolfile) == 0))
+      SETCOLOR(MT_COLOR_SB_SPOOLFILE);
+    else if ((b->msg_unread > 0) || (b->new))
+      SETCOLOR(MT_COLOR_NEW);
+    else if (b->msg_flagged > 0)
+      SETCOLOR(MT_COLOR_FLAGGED);
+    else
+      SETCOLOR(MT_COLOR_NORMAL);
+
+    move (first_row + row, 0);
+    if (Context && Context->realpath &&
+        !mutt_strcmp (b->realpath, Context->realpath))
+    {
+      b->msg_unread  = Context->unread;
+      b->msg_count   = Context->msgcount;
+      b->msg_flagged = Context->flagged;
+    }
+
+    /* compute length of Maildir without trailing separator */
+    size_t maildirlen = strlen (Maildir);
+    if (SidebarDelimChars && strchr (SidebarDelimChars, Maildir[maildirlen - 1]))
+      maildirlen--;
+
+    /* check whether Maildir is a prefix of the current folder's path */
+    short maildir_is_prefix = 0;
+    if ((strlen (b->path) > maildirlen) && (strncmp (Maildir, b->path, maildirlen) == 0))
+      maildir_is_prefix = 1;
+
+    /* calculate depth of current folder and generate its display name with indented spaces */
+    int sidebar_folder_depth = 0;
+    char *sidebar_folder_name;
+    int i;
+    if (option (OPTSIDEBARSHORTPATH))
+    {
+      /* disregard a trailing separator, so strlen() - 2 */
+      sidebar_folder_name = b->path;
+      for (i = strlen (sidebar_folder_name) - 2; i >= 0; i--)
+      {
+        if (SidebarDelimChars &&
+            strchr (SidebarDelimChars, sidebar_folder_name[i]))
+        {
+          sidebar_folder_name += (i + 1);
+          break;
+        }
+      }
+    }
+    else
+      sidebar_folder_name = b->path + maildir_is_prefix * (maildirlen + 1);
+
+    if (maildir_is_prefix && option (OPTSIDEBARFOLDERINDENT))
+    {
+      const char *tmp_folder_name;
+      int lastsep = 0;
+      tmp_folder_name = b->path + maildirlen + 1;
+      int tmplen = (int) strlen (tmp_folder_name) - 1;
+      for (i = 0; i < tmplen; i++)
+      {
+        if (SidebarDelimChars && strchr (SidebarDelimChars, tmp_folder_name[i]))
+        {
+          sidebar_folder_depth++;
+          lastsep = i + 1;
+        }
+      }
+      if (sidebar_folder_depth > 0)
+      {
+        if (option (OPTSIDEBARSHORTPATH))
+          tmp_folder_name += lastsep;  /* basename */
+        sidebar_folder_name = malloc (strlen (tmp_folder_name) + sidebar_folder_depth*strlen (NONULL(SidebarIndentString)) + 1);
+                                 int sfn_len = strlen (tmp_folder_name) + sidebar_folder_depth*strlen (NONULL(SidebarIndentString)) + 1;
+        sidebar_folder_name = safe_malloc (sfn_len);
+        sidebar_folder_name[0]=0;
+        for (i=0; i < sidebar_folder_depth; i++)
+          safe_strcat (sidebar_folder_name, sfn_len, NONULL(SidebarIndentString));
+        safe_strcat (sidebar_folder_name, sfn_len, tmp_folder_name);
+      }
+    }
+    char str[STRING];
+    make_sidebar_entry (str, sizeof (str), w, sidebar_folder_name, entry);
+    printw ("%s", str);
+    if (sidebar_folder_depth > 0)
+      FREE (&sidebar_folder_name);
+    row++;
+  }
+
+  fill_empty_space (first_row + row, num_rows - row, w);
+}
+
+
+/**
+ * mutt_sb_init - Set some default values for the sidebar.
+ */
+void
+mutt_sb_init (void)
+{
+  OldVisible = option (OPTSIDEBAR);
+  if (SidebarWidth > 0)
+  {
+    OldWidth = SidebarWidth;
+  }
+  else
+  {
+    OldWidth = 20;
+    if (OldVisible)
+    {
+      SidebarWidth = OldWidth;
+    }
+  }
+}
+
+/**
+ * mutt_sb_draw - Completely redraw the sidebar
+ *
+ * Completely refresh the sidebar region.  First draw the divider; then, for
+ * each BUFFY, call make_sidebar_entry; finally blank out any remaining space.
+ */
+void mutt_sb_draw (void)
+{
+  if (!visible())
+    return;
+
+  /* XXX - if transitioning from invisible to visible */
+  /* if (OldVisible == 0) */
+  /* 	mutt_buffy_check (1); we probably have bad or no numbers */
+
+#ifdef USE_SLANG_CURSES
+  int x = SLsmg_get_column();
+  int y = SLsmg_get_row();
+#else
+  int x = getcurx (stdscr);
+  int y = getcury (stdscr);
+#endif
+
+  int first_row = 0;
+  int num_rows  = LINES - 2;
+
+  if (option (OPTHELP) || option (OPTSTATUSONTOP))
+    first_row++;
+
+  if (option (OPTHELP))
+    num_rows--;
+
+  int div_width = draw_divider (first_row, num_rows);
+  if (div_width < 0)
+    return;
+
+  if (!Incoming)
+  {
+    int w = MIN(COLS, (SidebarWidth - div_width));
+    fill_empty_space (first_row, num_rows, w);
+    return;
+  }
+
+  if (!prepare_sidebar (num_rows))
+    return;
+
+  draw_sidebar (first_row, num_rows, div_width);
+  move (y, x);
+}
+
+/**
+ * select_next - Selects the next unhidden mailbox
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int select_next (void)
+{
+  int entry = HilIndex;
+
+  if (!EntryCount || HilIndex < 0)
+    return 0;
+
+  do
+  {
+    entry++;
+    if (entry == EntryCount)
+      return 0;
+  } while (Entries[entry]->is_hidden);
+
+  HilIndex = entry;
+  return 1;
+}
+
+/**
+ * select_next_new - Selects the next new mailbox
+ *
+ * Search down the list of mail folders for one containing new mail.
+ *
+ * Returns:
+ *	1: Success
+ *	0: Failure
+ */
+static int select_next_new (void)
+{
+  int entry = HilIndex;
+
+  if (!EntryCount || HilIndex < 0)
+    return 0;
+
+  do
+  {
+    entry++;
+    if (entry == EntryCount)
+    {
+      if (option (OPTSIDEBARNEXTNEWWRAP))
+        entry = 0;
+      else
+        return 0;
+    }
+    if (entry == HilIndex)
+      return 0;
+  } while (!Entries[entry]->buffy->new &&
+           !Entries[entry]->buffy->msg_unread);
+
+  HilIndex = entry;
+  return 1;
+}
+
+/**
+ * select_prev - Selects the previous unhidden mailbox
+ *
+ * Returns:
+ *      1: Success
+ *      0: Failure
+ */
+static int select_prev (void)
+{
+  int entry = HilIndex;
+
+  if (!EntryCount || HilIndex < 0)
+    return 0;
+
+  do
+  {
+    entry--;
+    if (entry < 0)
+      return 0;
+  } while (Entries[entry]->is_hidden);
+
+  HilIndex = entry;
+  return 1;
+}
+
+/**
+ * select_prev_new - Selects the previous new mailbox
+ *
+ * Search up the list of mail folders for one containing new mail.
+ *
+ * Returns:
+ *	1: Success
+ *	0: Failure
+ */
+static int select_prev_new (void)
+{
+  int entry = HilIndex;
+
+  if (!EntryCount || HilIndex < 0)
+    return 0;
+
+  do
+  {
+    entry--;
+    if (entry < 0)
+    {
+      if (option (OPTSIDEBARNEXTNEWWRAP))
+        entry = EntryCount - 1;
+      else
+        return 0;
+    }
+    if (entry == HilIndex)
+      return 0;
+  } while (!Entries[entry]->buffy->new &&
+           !Entries[entry]->buffy->msg_unread);
+
+  HilIndex = entry;
+  return 1;
+}
+
+/**
+ * mutt_sb_change_mailbox - Change the selected mailbox
+ * @op: Operation code
+ *
+ * Change the selected mailbox, e.g. "Next mailbox", "Previous Mailbox
+ * with new mail". The operations are listed OPS.SIDEBAR which is built
+ * into an enum in keymap_defs.h.
+ *
+ * If the operation is successful, HilBuffy will be set to the new mailbox.
+ * This function only *selects* the mailbox, doesn't *open* it.
+ *
+ * Allowed values are: OP_SIDEBAR_NEXT, OP_SIDEBAR_NEXT_NEW,
+ * OP_SIDEBAR_PAGE_DOWN, OP_SIDEBAR_PAGE_UP, OP_SIDEBAR_PREV,
+ * OP_SIDEBAR_PREV_NEW.
+ */
+void mutt_sb_change_mailbox (int op)
+{
+  if (!option (OPTSIDEBAR))
+    return;
+
+  if (HilIndex < 0)	/* It'll get reset on the next draw */
+    return;
+
+  switch (op)
+  {
+    case OP_SIDEBAR_NEXT:
+      if (! select_next ())
+        return;
+      break;
+    case OP_SIDEBAR_NEXT_NEW:
+      if (! select_next_new ())
+        return;
+      break;
+    case OP_SIDEBAR_PAGE_DOWN:
+      HilIndex = BotIndex;
+      select_next ();
+      break;
+    case OP_SIDEBAR_PAGE_UP:
+      HilIndex = TopIndex;
+      select_prev ();
+      break;
+    case OP_SIDEBAR_PREV:
+      if (! select_prev ())
+        return;
+      break;
+    case OP_SIDEBAR_PREV_NEW:
+      if (! select_prev_new ())
+        return;
+      break;
+    default:
+      return;
+  }
+  SidebarNeedsRedraw = 1;
+}
+
+/**
+ * mutt_sb_set_buffystats - Update the BUFFY's message counts from the CONTEXT
+ * @ctx:  A mailbox CONTEXT
+ *
+ * Given a mailbox CONTEXT, find a matching mailbox BUFFY and copy the message
+ * counts into it.
+ */
+void mutt_sb_set_buffystats (const CONTEXT *ctx)
+{
+  /* Even if the sidebar's hidden,
+   * we should take note of the new data. */
+  BUFFY *b = Incoming;
+  if (!ctx || !b)
+    return;
+
+  for (; b; b = b->next)
+  {
+    if (!mutt_strcmp (b->realpath, ctx->realpath))
+    {
+      b->msg_unread  = ctx->unread;
+      b->msg_count   = ctx->msgcount;
+      b->msg_flagged = ctx->flagged;
+      break;
+    }
+  }
+}
+
+/**
+ * mutt_sb_get_highlight - Get the BUFFY that's highlighted in the sidebar
+ *
+ * Get the path of the mailbox that's highlighted in the sidebar.
+ *
+ * Returns:
+ *	Mailbox path
+ */
+const char *mutt_sb_get_highlight (void)
+{
+  if (!option (OPTSIDEBAR))
+    return NULL;
+
+  if (!EntryCount || HilIndex < 0)
+    return NULL;
+
+  return Entries[HilIndex]->buffy->path;
+}
+
+/**
+ * mutt_sb_set_open_buffy - Set the OpnBuffy based on the global Context
+ *
+ * Search through the list of mailboxes.  If a BUFFY has a matching path, set
+ * OpnBuffy to it.
+ */
+void mutt_sb_set_open_buffy (void)
+{
+  int entry;
+
+  OpnIndex = -1;
+
+  if (!Context)
+    return;
+
+  for (entry = 0; entry < EntryCount; entry++)
+  {
+    if (!mutt_strcmp (Entries[entry]->buffy->realpath, Context->realpath))
+    {
+      OpnIndex = entry;
+      HilIndex = entry;
+      break;
+    }
+  }
+}
+
+/**
+ * mutt_sb_notify_mailbox - The state of a BUFFY is about to change
+ *
+ * We receive a notification:
+ *	After a new BUFFY has been created
+ *	Before a BUFFY is deleted
+ *
+ * Before a deletion, check that our pointers won't be invalidated.
+ */
+void mutt_sb_notify_mailbox (BUFFY *b, int created)
+{
+  int del_index;
+
+  if (!b)
+    return;
+
+  /* Any new/deleted mailboxes will cause a refresh.  As long as
+   * they're valid, our pointers will be updated in prepare_sidebar() */
+
+  if (created)
+  {
+    if (EntryCount >= EntryLen)
+    {
+      EntryLen += 10;
+      safe_realloc (&Entries, EntryLen * sizeof (SBENTRY *));
+    }
+    Entries[EntryCount] = safe_calloc (1, sizeof(SBENTRY));
+    Entries[EntryCount]->buffy = b;
+
+    if (TopIndex < 0)
+      TopIndex = EntryCount;
+    if (HilIndex < 0)
+      HilIndex = EntryCount;
+    if (BotIndex < 0)
+      BotIndex = EntryCount;
+    if ((OpnIndex < 0) && Context &&
+        (mutt_strcmp (b->realpath, Context->realpath) == 0))
+      OpnIndex = EntryCount;
+
+    EntryCount++;
+  }
+  else
+  {
+    for (del_index = 0; del_index < EntryCount; del_index++)
+      if (Entries[del_index]->buffy == b)
+        break;
+    if (del_index == EntryCount)
+      return;
+    FREE (&Entries[del_index]);
+    EntryCount--;
+
+    if (TopIndex > del_index || TopIndex == EntryCount)
+      TopIndex--;
+    if (OpnIndex == del_index)
+      OpnIndex = -1;
+    else if (OpnIndex > del_index)
+      OpnIndex--;
+    if (HilIndex > del_index || HilIndex == EntryCount)
+      HilIndex--;
+    if (BotIndex > del_index || BotIndex == EntryCount)
+      BotIndex--;
+
+    for (; del_index < EntryCount; del_index++)
+      Entries[del_index] = Entries[del_index + 1];
+  }
+
+  SidebarNeedsRedraw = 1;
+}
diff --git a/sidebar.h b/sidebar.h
new file mode 100644
index 0000000..f7875ea
--- /dev/null
+++ b/sidebar.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * Copyright (C) 2015-2016 Richard Russon <rich@flatcap.org>
+ *
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ *
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */
+
+#ifndef SIDEBAR_H
+#define SIDEBAR_H
+
+#include "mutt.h"
+#include "buffy.h"
+
+void         mutt_sb_change_mailbox (int op);
+void         mutt_sb_draw (void);
+const char * mutt_sb_get_highlight (void);
+void         mutt_sb_init (void);
+void         mutt_sb_notify_mailbox (BUFFY *b, int created);
+void         mutt_sb_set_buffystats (const CONTEXT *ctx);
+BUFFY *      mutt_sb_set_open_buffy (void);
+
+#endif /* SIDEBAR_H */
diff --git a/smime.c b/smime.c
index 7f9a8b5..c6b96b7 100644
--- a/smime.c
+++ b/smime.c
@@ -159,6 +159,7 @@ int smime_valid_passphrase (void)
 static const char *_mutt_fmt_smime_command (char *dest,
 					    size_t destlen,
 					    size_t col,
+                                            int cols,
 					    char op,
 					    const char *src,
 					    const char *prefix,
@@ -284,10 +285,10 @@ static const char *_mutt_fmt_smime_command (char *dest,
   }
 
   if (optional)
-    mutt_FormatString (dest, destlen, col, ifstring, _mutt_fmt_smime_command,
+    mutt_FormatString (dest, destlen, col, cols, ifstring, _mutt_fmt_smime_command,
 		       data, 0);
   else if (flags & M_FORMAT_OPTIONAL)
-    mutt_FormatString (dest, destlen, col, elsestring, _mutt_fmt_smime_command,
+    mutt_FormatString (dest, destlen, col, cols, elsestring, _mutt_fmt_smime_command,
 		       data, 0);
 
   return (src);
@@ -298,7 +299,7 @@ static const char *_mutt_fmt_smime_command (char *dest,
 static void mutt_smime_command (char *d, size_t dlen,
 				struct smime_command_context *cctx, const char *fmt)
 {
-  mutt_FormatString (d, dlen, 0, NONULL(fmt), _mutt_fmt_smime_command,
+  mutt_FormatString (d, dlen, 0, COLS - SidebarWidth, NONULL(fmt), _mutt_fmt_smime_command,
 		    (unsigned long) cctx, 0);
   dprint (2,(debugfile, "mutt_smime_command: %s\n", d));
 }
diff --git a/sort.h b/sort.h
index f2832b2..26afdc6 100644
--- a/sort.h
+++ b/sort.h
@@ -31,6 +31,11 @@
 #define SORT_KEYID	12
 #define SORT_TRUST	13
 #define SORT_SPAM	14
+#define SORT_COUNT	15
+#define SORT_COUNT_NEW	16
+#define SORT_FLAGGED	17
+#define SORT_PATH	18
+
 /* dgc: Sort & SortAux are shorts, so I'm bumping these bitflags up from
  * bits 4 & 5 to bits 8 & 9 to make room for more sort keys in the future. */
 #define SORT_MASK	0xff
@@ -50,6 +55,7 @@ WHERE short BrowserSort INITVAL (SORT_SUBJECT);
 WHERE short Sort INITVAL (SORT_DATE);
 WHERE short SortAux INITVAL (SORT_DATE); /* auxiliary sorting method */
 WHERE short SortAlias INITVAL (SORT_ALIAS);
+WHERE short SidebarSortMethod INITVAL (SORT_ORDER);
 
 /* FIXME: This one does not belong to here */
 WHERE short PgpSortKeys INITVAL (SORT_ADDRESS);
diff --git a/status.c b/status.c
index 6051e3a..20ba601 100644
--- a/status.c
+++ b/status.c
@@ -40,7 +40,7 @@ static char *get_sort_str (char *buf, size_t buflen, int method)
   return buf;
 }
 
-static void _menu_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, const char *p);
+static void _menu_status_line (char *buf, size_t buflen, size_t col, int cols, MUTTMENU *menu, const char *p);
 
 /* %b = number of incoming folders with unread messages [option]
  * %d = number of deleted messages [option]
@@ -62,7 +62,7 @@ static void _menu_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *m
  * %v = Mutt version 
  * %V = currently active limit pattern [option] */
 static const char *
-status_format_str (char *buf, size_t buflen, size_t col, char op, const char *src,
+status_format_str (char *buf, size_t buflen, size_t col, int cols, char op, const char *src,
 		   const char *prefix, const char *ifstring,
 		   const char *elsestring,
 		   unsigned long data, format_flag flags)
@@ -290,19 +290,19 @@ status_format_str (char *buf, size_t buflen, size_t col, char op, const char *sr
   }
 
   if (optional)
-    _menu_status_line (buf, buflen, col, menu, ifstring);
+    _menu_status_line (buf, buflen, col, cols, menu, ifstring);
   else if (flags & M_FORMAT_OPTIONAL)
-    _menu_status_line (buf, buflen, col, menu, elsestring);
+    _menu_status_line (buf, buflen, col, cols, menu, elsestring);
 
   return (src);
 }
 
-static void _menu_status_line (char *buf, size_t buflen, size_t col, MUTTMENU *menu, const char *p)
+static void _menu_status_line (char *buf, size_t buflen, size_t col, int cols, MUTTMENU *menu, const char *p)
 {
-  mutt_FormatString (buf, buflen, col, p, status_format_str, (unsigned long) menu, 0);
+  mutt_FormatString (buf, buflen, col, cols, p, status_format_str, (unsigned long) menu, 0);
 }
 
 void menu_status_line (char *buf, size_t buflen, MUTTMENU *menu, const char *p)
 {
-  mutt_FormatString (buf, buflen, 0, p, status_format_str, (unsigned long) menu, 0);
+  mutt_FormatString (buf, buflen, 0, COLS - SidebarWidth, p, status_format_str, (unsigned long) menu, 0);
 }
