diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/all_cosnotify_clients.cc omniNotify-2.1.new/examples/all_cosnotify_clients.cc
--- omniNotify-2.1.orig/examples/all_cosnotify_clients.cc	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/all_cosnotify_clients.cc	2009-06-28 17:19:34.000000000 +0400
@@ -41,7 +41,7 @@
     num_con_events = 6 * num_events;
 
     // (2) Obtain reference to notification channel
-    if (verbose) cout << "Obtaining reference to notification channel" << endl;
+    if (verbose) std::cout << "Obtaining reference to notification channel" << std::endl;
     CosNA::EventChannel_ptr channel = getchan_from_ns(orb, channel_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getchan_from_iorfile(orb, ior_file, verbose);
@@ -51,7 +51,7 @@
     }
 
     // (3) Create all 12 CosNotify-style clients
-    if (verbose) cout << "Creating 12 clients" << endl;
+    if (verbose) std::cout << "Creating 12 clients" << std::endl;
 
     // (3.1) any_push_consumer
     PushConsumer_i* a_push_c =
@@ -59,7 +59,7 @@
 			     "", "", sample_consume_any_fn, sample_offer_change_fn,
 			     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! a_push_c) {
-      cerr << "Constructing any_push_consumer failed" << endl;
+      std::cerr << "Constructing any_push_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::PushConsumer_var my_a_push_c = a_push_c->_this();
@@ -71,7 +71,7 @@
 				       "", "", sample_consume_structured_fn, sample_offer_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! s_push_c) {
-      cerr << "Constructing struct_push_consumer failed" << endl;
+      std::cerr << "Constructing struct_push_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::StructuredPushConsumer_var my_s_push_c = s_push_c->_this();
@@ -83,7 +83,7 @@
 				     "", "", sample_consume_batch_fn, sample_offer_change_fn,
 				     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! b_push_c) {
-      cerr << "Constructing batch_push_consumer failed" << endl;
+      std::cerr << "Constructing batch_push_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::SequencePushConsumer_var my_b_push_c = b_push_c->_this();
@@ -95,7 +95,7 @@
 			     "", "", sample_consume_any_fn, sample_offer_change_fn,
 			     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! a_pull_c) {
-      cerr << "Constructing any_pull_consumer failed" << endl;
+      std::cerr << "Constructing any_pull_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::PullConsumer_var my_a_pull_c = a_pull_c->_this();
@@ -107,7 +107,7 @@
 				       "", "", sample_consume_structured_fn, sample_offer_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! s_pull_c) {
-      cerr << "Constructing struct_pull_consumer failed" << endl;
+      std::cerr << "Constructing struct_pull_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::StructuredPullConsumer_var my_s_pull_c = s_pull_c->_this();
@@ -119,7 +119,7 @@
 				     "", "", sample_consume_batch_fn, sample_offer_change_fn,
 				     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! b_pull_c) {
-      cerr << "Constructing batch_pull_consumer failed" << endl;
+      std::cerr << "Constructing batch_pull_consumer failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::SequencePullConsumer_var my_b_pull_c = b_pull_c->_this();
@@ -131,7 +131,7 @@
 			     "", "", sample_supply_any_fn, sample_subscription_change_fn,
 			     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! a_push_s) {
-      cerr << "Constructing any_push_supplier failed" << endl;
+      std::cerr << "Constructing any_push_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::PushSupplier_var my_a_push_s = a_push_s->_this();
@@ -143,7 +143,7 @@
 				       "", "", sample_supply_structured_fn, sample_subscription_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! s_push_s) {
-      cerr << "Constructing struct_push_supplier failed" << endl;
+      std::cerr << "Constructing struct_push_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::StructuredPushSupplier_var my_s_push_s = s_push_s->_this();
@@ -155,7 +155,7 @@
 				     "", "", sample_supply_batch_fn, sample_subscription_change_fn,
 				     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! b_push_s) {
-      cerr << "Constructing batch_push_supplier failed" << endl;
+      std::cerr << "Constructing batch_push_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::SequencePushSupplier_var my_b_push_s = b_push_s->_this();
@@ -167,7 +167,7 @@
 			     "", "", sample_supply_any_fn, sample_subscription_change_fn,
 			     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! a_pull_s) {
-      cerr << "Constructing any_pull_supplier failed" << endl;
+      std::cerr << "Constructing any_pull_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::PullSupplier_var my_a_pull_s = a_pull_s->_this();
@@ -179,7 +179,7 @@
 				       "", "", sample_supply_structured_fn, sample_subscription_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! s_pull_s) {
-      cerr << "Constructing struct_pull_supplier failed" << endl;
+      std::cerr << "Constructing struct_pull_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::StructuredPullSupplier_var my_s_pull_s = s_pull_s->_this();
@@ -191,75 +191,75 @@
 				     "", "", sample_supply_batch_fn, sample_subscription_change_fn,
 				     &evs, constraint_expr, millisecs, delay_millisecs, verbose);
     if (! b_pull_s) {
-      cerr << "Constructing batch_pull_supplier failed" << endl;
+      std::cerr << "Constructing batch_pull_supplier failed" << std::endl;
       goto error_return; // failed to create a client
     }
     CosNotifyComm::SequencePullSupplier_var my_b_pull_s = b_pull_s->_this();
     b_pull_s->_remove_ref(); // enables POA cleanup of servant
 
     // (4) Tell POA we are ready to go
-    if (verbose) cout << "Activating POA manager" << endl;
+    if (verbose) std::cout << "Activating POA manager" << std::endl;
     PortableServer::POAManager_var pman = poa->the_POAManager();
     pman->activate();
 
     // (5) Connect clients to their proxies -- consumers first
-    if (verbose) cout << "Connecting consumer clients to proxies" << endl;
+    if (verbose) std::cout << "Connecting consumer clients to proxies" << std::endl;
 
     if (a_push_c->connect()) {
-      cerr << "Connecting any_push_consumer failed" << endl;
+      std::cerr << "Connecting any_push_consumer failed" << std::endl;
       goto error_return;
     }
     if (s_push_c->connect()) {
-      cerr << "Connecting struct_push_consumer failed" << endl;
+      std::cerr << "Connecting struct_push_consumer failed" << std::endl;
       goto error_return;
     }
     if (b_push_c->connect()) {
-      cerr << "Connecting batch_push_consumer failed" << endl;
+      std::cerr << "Connecting batch_push_consumer failed" << std::endl;
       goto error_return;
     }
 
     if (a_pull_c->connect()) {
-      cerr << "Connecting any_pull_consumer failed" << endl;
+      std::cerr << "Connecting any_pull_consumer failed" << std::endl;
       goto error_return;
     }
     if (s_pull_c->connect()) {
-      cerr << "Connecting struct_pull_consumer failed" << endl;
+      std::cerr << "Connecting struct_pull_consumer failed" << std::endl;
       goto error_return;
     }
     if (b_pull_c->connect()) {
-      cerr << "Connecting batch_pull_consumer failed" << endl;
+      std::cerr << "Connecting batch_pull_consumer failed" << std::endl;
       goto error_return;
     }
 
-    if (verbose) cout << "Connecting supplier clients to proxies" << endl;
+    if (verbose) std::cout << "Connecting supplier clients to proxies" << std::endl;
 
     if (a_push_s->connect()) {
-      cerr << "Connecting any_push_supplier failed" << endl;
+      std::cerr << "Connecting any_push_supplier failed" << std::endl;
       goto error_return;
     }
     if (s_push_s->connect()) {
-      cerr << "Connecting struct_push_supplier failed" << endl;
+      std::cerr << "Connecting struct_push_supplier failed" << std::endl;
       goto error_return;
     }
     if (b_push_s->connect()) {
-      cerr << "Connecting batch_push_supplier failed" << endl;
+      std::cerr << "Connecting batch_push_supplier failed" << std::endl;
       goto error_return;
     }
 
     if (a_pull_s->connect()) {
-      cerr << "Connecting any_pull_supplier failed" << endl;
+      std::cerr << "Connecting any_pull_supplier failed" << std::endl;
       goto error_return;
     }
     if (s_pull_s->connect()) {
-      cerr << "Connecting struct_pull_supplier failed" << endl;
+      std::cerr << "Connecting struct_pull_supplier failed" << std::endl;
       goto error_return;
     }
     if (b_pull_s->connect()) {
-      cerr << "Connecting batch_pull_supplier failed" << endl;
+      std::cerr << "Connecting batch_pull_supplier failed" << std::endl;
       goto error_return;
     }
 
-    if (verbose) cout << "Waiting for all 12 clients to finish" << endl;
+    if (verbose) std::cout << "Waiting for all 12 clients to finish" << std::endl;
     CORBA::Boolean a_push_c_err = a_push_c->wait_done();
     CORBA::Boolean s_push_c_err = s_push_c->wait_done();
     CORBA::Boolean b_push_c_err = b_push_c->wait_done();
@@ -291,10 +291,10 @@
       b_pull_s_err;
 
     if (com_err && (num_events > 0)) {
-      if (verbose) cout << "Communication error -- probably did not process desired # of events" << endl;
+      if (verbose) std::cout << "Communication error -- probably did not process desired # of events" << std::endl;
     }
 
-    if (verbose) cout << "Cleaning up" << endl;
+    if (verbose) std::cout << "Cleaning up" << std::endl;
 
     if (!a_push_c_err) { a_push_c->cleanup(); }
     if (!s_push_c_err) { s_push_c->cleanup(); }
@@ -315,25 +315,25 @@
     goto normal_return;
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "main caught CORBA::SystemException." << endl;  
+    std::cerr << "main caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "main caught CORBA::Exception." << endl;        
+    std::cerr << "main caught CORBA::Exception." << std::endl;        
   }                                                    
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {                 
-    cerr << "main caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "main caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
 #endif
   catch(...) {                                         
     // nameclt comment says it is a bad idea to report an error here 
   }
-  cerr << "main caught an exception." << endl;       
+  std::cerr << "main caught an exception." << std::endl;       
  error_return:
-  cerr << "QUITTING due to error" << endl;
+  std::cerr << "QUITTING due to error" << std::endl;
   // orb->destroy();
   return -1;
  normal_return:
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/demo_add_filter.cc omniNotify-2.1.new/examples/demo_add_filter.cc
--- omniNotify-2.1.orig/examples/demo_add_filter.cc	2003-10-12 22:51:18.000000000 +0400
+++ omniNotify-2.1.new/examples/demo_add_filter.cc	2009-06-28 17:20:35.000000000 +0400
@@ -1,5 +1,5 @@
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 
 #include "CosNotifyShorthands.h"
@@ -25,14 +25,14 @@
 				 CORBA::Boolean verbose);
 
 void usage(char* pname) {
-  cerr << "Usage: " << pname << " [-n name] [-f file] -p file" << endl << endl;
-  cout << "  -n name  : channel name" << endl;
-  cout << "               => use event service to lookup this name" << endl;
-  cout << "  -f file  : file containing channel IOR" << endl;
-  cout << "               => use string_to_object on the IOR" << endl;
-  cout << "  -p file  : file with stringified IOR of proxy to be" << endl;
-  cout << "               sent add_filter messages (REQUIRED)" << endl;
-  cout << "(The channel is needed to obtain its default filter factory)" << endl;
+  std::cerr << "Usage: " << pname << " [-n name] [-f file] -p file" << std::endl << std::endl;
+  std::cout << "  -n name  : channel name" << std::endl;
+  std::cout << "               => use event service to lookup this name" << std::endl;
+  std::cout << "  -f file  : file containing channel IOR" << std::endl;
+  std::cout << "               => use string_to_object on the IOR" << std::endl;
+  std::cout << "  -p file  : file with stringified IOR of proxy to be" << std::endl;
+  std::cout << "               sent add_filter messages (REQUIRED)" << std::endl;
+  std::cout << "(The channel is needed to obtain its default filter factory)" << std::endl;
 }
 
 
@@ -84,11 +84,11 @@
     char buf[8096];
     FILE* ifile;
     if (! (ifile = fopen(proxy_ior_file, "r")) ) {
-      cerr << "Failed to open file " << proxy_ior_file << " for reading" << endl;
+      std::cerr << "Failed to open file " << proxy_ior_file << " for reading" << std::endl;
       goto cleanup;
     }
     if (fscanf(ifile, "%s", buf) != 1) {
-      cerr << "Failed to get an IOR from file " << proxy_ior_file << endl;
+      std::cerr << "Failed to get an IOR from file " << proxy_ior_file << std::endl;
       fclose(ifile);
       goto cleanup;
     }
@@ -97,32 +97,32 @@
     try {
       CORBA::Object_var proxy_ref = orb->string_to_object(buf);
       if ( CORBA::is_nil(proxy_ref) ) {
-	cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << endl;
+	std::cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << std::endl;
 	goto cleanup;
       }
       proxy = CosNF::FilterAdmin::_narrow(proxy_ref);
       if ( CORBA::is_nil(proxy) ) {
-	cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << endl;
+	std::cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << std::endl;
 	goto cleanup;
       }
     } catch (...) {
-      cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << endl;
+      std::cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << std::endl;
       goto cleanup;
     }
 
     CosNF::Filter_ptr filter = CosNF::Filter::_nil();
     while (1) {
-      cout << endl << "Enter a constraint ('exit' to quit, 'remove' to remove all filters): " << endl <<  flush;
+      std::cout << std::endl << "Enter a constraint ('exit' to quit, 'remove' to remove all filters): " << std::endl <<  std::flush;
       if (!(fgets(buf, 8090, stdin))) break;
       if (strlen(buf) < 2) continue; // skip empty lines
       buf[strlen(buf)-1] = '\0'; // strip newline from end
       if (strcmp(buf, "exit") == 0) {
 	break;
       }
-      cout << "Calling remove_all_filters on the proxy" << endl;
+      std::cout << "Calling remove_all_filters on the proxy" << std::endl;
       proxy->remove_all_filters();
       if (!CORBA::is_nil(filter)) {
-	cout << "Destroying the previous filter, which is no longer in use" << endl;
+	std::cout << "Destroying the previous filter, which is no longer in use" << std::endl;
 	filter->destroy();
 	filter = CosNF::Filter::_nil();
       }
@@ -134,27 +134,27 @@
 	evs.length(0);
 	sample_add_filter(channel, proxy, evs, buf, "demo_add_filter", filter, 1);
       }
-      cout << endl << "---------------------------------------------------------" << endl;
+      std::cout << std::endl << "---------------------------------------------------------" << std::endl;
     }
     orb->destroy();
     return 0; // success
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "Caught CORBA::SystemException." << endl;  
+    std::cerr << "Caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "Caught CORBA::Exception." << endl;        
+    std::cerr << "Caught CORBA::Exception." << std::endl;        
   }                                                    
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {                 
-    cerr << "Caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "Caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
 #endif
   catch(...) {                                         
-    cerr << "Caught unknown exception." << endl;       
+    std::cerr << "Caught unknown exception." << std::endl;       
   }
  cleanup:
   orb->destroy();
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/demo_offer_change.cc omniNotify-2.1.new/examples/demo_offer_change.cc
--- omniNotify-2.1.orig/examples/demo_offer_change.cc	2003-10-12 22:51:18.000000000 +0400
+++ omniNotify-2.1.new/examples/demo_offer_change.cc	2009-06-28 17:21:48.000000000 +0400
@@ -1,5 +1,5 @@
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 
 #include "CosNotifyShorthands.h"
@@ -58,9 +58,9 @@
 }
 
 void usage(char* pname) {
-  cerr << "Usage: " << pname << " -p file" << endl << endl;
-  cout << "  -p file  : file with stringified IOR of proxy to be" << endl;
-  cout << "               sent offer_change messages (REQUIRED)" << endl;
+  std::cerr << "Usage: " << pname << " -p file" << std::endl << std::endl;
+  std::cout << "  -p file  : file with stringified IOR of proxy to be" << std::endl;
+  std::cout << "               sent offer_change messages (REQUIRED)" << std::endl;
 }
 
 int main(int argc, char** argv)
@@ -96,11 +96,11 @@
     char buf2[8096];
     FILE* ifile;
     if (! (ifile = fopen(proxy_ior_file, "r")) ) {
-      cerr << "Failed to open file " << proxy_ior_file << " for reading" << endl;
+      std::cerr << "Failed to open file " << proxy_ior_file << " for reading" << std::endl;
       goto cleanup;
     }
     if (fscanf(ifile, "%s", buf) != 1) {
-      cerr << "Failed to get an IOR from file " << proxy_ior_file << endl;
+      std::cerr << "Failed to get an IOR from file " << proxy_ior_file << std::endl;
       fclose(ifile);
       goto cleanup;
     }
@@ -109,69 +109,69 @@
     try {
       CORBA::Object_var proxy_ref = orb->string_to_object(buf);
       if ( CORBA::is_nil(proxy_ref) ) {
-	cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << endl;
+	std::cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << std::endl;
 	goto cleanup;
       }
       proxy = CosNC::NotifyPublish::_narrow(proxy_ref);
       if ( CORBA::is_nil(proxy) ) {
-	cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << endl;
+	std::cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << std::endl;
 	goto cleanup;
       }
     } catch (...) {
-      cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << endl;
+      std::cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << std::endl;
       goto cleanup;
     }
 
     while (1) {
       added.length(0);
       deled.length(0);
-      cout << endl << "Enter list of removals (or empty for none): " << endl <<  flush;
+      std::cout << std::endl << "Enter list of removals (or empty for none): " << std::endl <<  std::flush;
       if (!(fgets(buf, 8090, stdin))) break;
       if (strlen(buf) < 1) break;
       buf[strlen(buf)-1] = '\0'; // strip newline from end
       if (strcmp(buf, "exit") == 0) break;
       if (strlen(buf)) {
 	if (parse_etype_list(buf, deled)) {
-	  cerr << "Failed to parse the input as an event type list" << endl;
+	  std::cerr << "Failed to parse the input as an event type list" << std::endl;
 	  continue;
 	}
       }
 
-      cout << endl << "Enter list of additions (or empty for none): " << endl <<  flush;
+      std::cout << std::endl << "Enter list of additions (or empty for none): " << std::endl <<  std::flush;
       if (!(fgets(buf2, 8090, stdin))) break;
       if (strlen(buf2) < 1) break;
       buf2[strlen(buf2)-1] = '\0'; // strip newline from end
       if (strcmp(buf2, "exit") == 0) break;
       if (strlen(buf2)) {
 	if (parse_etype_list(buf2, added)) {
-	  cerr << "Failed to parse the input as an event type list" << endl;
+	  std::cerr << "Failed to parse the input as an event type list" << std::endl;
 	  continue;
 	}
       }
 
-      cout << "Calling offer_change on the proxy" << endl;
+      std::cout << "Calling offer_change on the proxy" << std::endl;
       proxy->offer_change(added, deled);
-      cout << endl << "---------------------------------------------------------" << endl;
+      std::cout << std::endl << "---------------------------------------------------------" << std::endl;
     }
     orb->destroy();
     return 0; // success
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "Caught CORBA::SystemException." << endl;  
+    std::cerr << "Caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "Caught CORBA::Exception." << endl;        
+    std::cerr << "Caught CORBA::Exception." << std::endl;        
   }                                                    
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {                 
-    cerr << "Caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "Caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
 #endif
   catch(...) {                                         
-    cerr << "Caught unknown exception." << endl;       
+    std::cerr << "Caught unknown exception." << std::endl;       
   }
  cleanup:
   orb->destroy();
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/demo_subscription_change.cc omniNotify-2.1.new/examples/demo_subscription_change.cc
--- omniNotify-2.1.orig/examples/demo_subscription_change.cc	2003-10-12 22:51:18.000000000 +0400
+++ omniNotify-2.1.new/examples/demo_subscription_change.cc	2009-06-28 17:23:49.000000000 +0400
@@ -1,5 +1,5 @@
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 #include <stdio.h>
 
 #include "CosNotifyShorthands.h"
@@ -58,9 +58,9 @@
 }
 
 void usage(char* pname) {
-  cerr << "Usage: " << pname << " -p file" << endl << endl;
-  cout << "  -p file  : file with stringified IOR of proxy to be" << endl;
-  cout << "               sent subscription_change messages (REQUIRED)" << endl;
+  std::cerr << "Usage: " << pname << " -p file" << std::endl << std::endl;
+  std::cout << "  -p file  : file with stringified IOR of proxy to be" << std::endl;
+  std::cout << "               sent subscription_change messages (REQUIRED)" << std::endl;
 }
 
 int main(int argc, char** argv)
@@ -96,11 +96,11 @@
     char buf2[8096];
     FILE* ifile;
     if (! (ifile = fopen(proxy_ior_file, "r")) ) {
-      cerr << "Failed to open file " << proxy_ior_file << " for reading" << endl;
+      std::cerr << "Failed to open file " << proxy_ior_file << " for reading" << std::endl;
       goto cleanup;
     }
     if (fscanf(ifile, "%s", buf) != 1) {
-      cerr << "Failed to get an IOR from file " << proxy_ior_file << endl;
+      std::cerr << "Failed to get an IOR from file " << proxy_ior_file << std::endl;
       fclose(ifile);
       goto cleanup;
     }
@@ -109,69 +109,69 @@
     try {
       CORBA::Object_var proxy_ref = orb->string_to_object(buf);
       if ( CORBA::is_nil(proxy_ref) ) {
-	cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << endl;
+	std::cerr << "Failed to turn IOR in file " << proxy_ior_file << " into object" << std::endl;
 	goto cleanup;
       }
       proxy = CosNC::NotifySubscribe::_narrow(proxy_ref);
       if ( CORBA::is_nil(proxy) ) {
-	cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << endl;
+	std::cerr << "Failed to narrow object from IOR in file " << proxy_ior_file << std::endl;
 	goto cleanup;
       }
     } catch (...) {
-      cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << endl;
+      std::cerr << "Failed to convert to object from IOR in file " << proxy_ior_file << std::endl;
       goto cleanup;
     }
 
     while (1) {
       added.length(0);
       deled.length(0);
-      cout << endl << "Enter list of removals (or empty for none): " << endl <<  flush;
+      std::cout << std::endl << "Enter list of removals (or empty for none): " << std::endl <<  std::flush;
       if (!(fgets(buf, 8090, stdin))) break;
       if (strlen(buf) < 1) break;
       buf[strlen(buf)-1] = '\0'; // strip newline from end
       if (strcmp(buf, "exit") == 0) break;
       if (strlen(buf)) {
 	if (parse_etype_list(buf, deled)) {
-	  cerr << "Failed to parse the input as an event type list" << endl;
+	  std::cerr << "Failed to parse the input as an event type list" << std::endl;
 	  continue;
 	}
       }
 
-      cout << endl << "Enter list of additions (or empty for none): " << endl <<  flush;
+      std::cout << std::endl << "Enter list of additions (or empty for none): " << std::endl <<  std::flush;
       if (!(fgets(buf2, 8090, stdin))) break;
       if (strlen(buf2) < 1) break;
       buf2[strlen(buf2)-1] = '\0'; // strip newline from end
       if (strcmp(buf2, "exit") == 0) break;
       if (strlen(buf2)) {
 	if (parse_etype_list(buf2, added)) {
-	  cerr << "Failed to parse the input as an event type list" << endl;
+	  std::cerr << "Failed to parse the input as an event type list" << std::endl;
 	  continue;
 	}
       }
 
-      cout << "Calling subscription_change on the proxy" << endl;
+      std::cout << "Calling subscription_change on the proxy" << std::endl;
       proxy->subscription_change(added, deled);
-      cout << endl << "---------------------------------------------------------" << endl;
+      std::cout << std::endl << "---------------------------------------------------------" << std::endl;
     }
     orb->destroy();
     return 0; // success
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "Caught CORBA::SystemException." << endl;  
+    std::cerr << "Caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "Caught CORBA::Exception." << endl;        
+    std::cerr << "Caught CORBA::Exception." << std::endl;        
   }                                                    
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {                 
-    cerr << "Caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "Caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
 #endif
   catch(...) {                                         
-    cerr << "Caught unknown exception." << endl;       
+    std::cerr << "Caught unknown exception." << std::endl;       
   }
  cleanup:
   orb->destroy();
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/get_channel.h omniNotify-2.1.new/examples/get_channel.h
--- omniNotify-2.1.orig/examples/get_channel.h	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/get_channel.h	2009-06-28 17:10:29.000000000 +0400
@@ -19,11 +19,11 @@
   CosNA::EventChannel_ptr channel = CosNA::EventChannel::_nil();
   if (!ior_file || strlen(ior_file) == 0) return channel; // empty string -- ignore
   if (! (ifile = fopen(ior_file, "r")) ) {
-    cerr << "Failed to open file " << ior_file << " for reading" << endl;
+    std::cerr << "Failed to open file " << ior_file << " for reading" << std::endl;
     return channel; // failure
   }
   if (fscanf(ifile, "%s", buf) != 1) {
-    cerr << "Failed to get an IOR from file " << ior_file << endl;
+    std::cerr << "Failed to get an IOR from file " << ior_file << std::endl;
     fclose(ifile);
     return channel; // failure
   }
@@ -31,21 +31,21 @@
   try {
     CORBA::Object_var channel_ref = orb->string_to_object(buf);
     if ( CORBA::is_nil(channel_ref) ) {
-      cerr << "Failed to turn IOR in file " << ior_file << " into object" << endl;
+      std::cerr << "Failed to turn IOR in file " << ior_file << " into object" << std::endl;
       return channel; // failure
     }
     channel = CosNA::EventChannel::_narrow(channel_ref);
     if ( CORBA::is_nil(channel) ) {
-      cerr << "Failed to narrow object from IOR in file " << ior_file <<
-	" to type CosNotifyChannelAdmin::EventChannel" << endl;
+      std::cerr << "Failed to narrow object from IOR in file " << ior_file <<
+	" to type CosNotifyChannelAdmin::EventChannel" << std::endl;
       return channel; // failure
     }
   } catch (...) {
-    cerr << "Failed to convert IOR in file " << ior_file << " to object" << endl;
+    std::cerr << "Failed to convert IOR in file " << ior_file << " to object" << std::endl;
     return channel; // failure
   }
   if (verbose)
-    cout << "Found valid channel reference" << endl;
+    std::cout << "Found valid channel reference" << std::endl;
   return channel; // success
 }
 
@@ -59,29 +59,29 @@
   if (!channel_name || strlen(channel_name) == 0) return channel; // empty string -- ignore
 
   if (verbose)
-    cout << "Obtaining naming service reference" << endl;
+    std::cout << "Obtaining naming service reference" << std::endl;
   try {
     CORBA::Object_var name_service;
     name_service = orb->resolve_initial_references("NameService"); 
     name_context = CosNaming::NamingContext::_narrow(name_service);
     if ( CORBA::is_nil(name_context) ) {
-      cerr << "Failed to obtain context for NameService" << endl;
+      std::cerr << "Failed to obtain context for NameService" << std::endl;
       return channel; // failure
     } 
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Service required is invalid [does not exist]" << endl;
+    std::cerr << "Service required is invalid [does not exist]" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving the naming service" << endl;
+    std::cerr << "Caught exception while resolving the naming service" << std::endl;
     return channel; // failure
   }
 
   if (verbose)
-    cout << "Looking up channel name " << channel_name << " . " << channel_name << endl;
+    std::cout << "Looking up channel name " << channel_name << " . " << channel_name << std::endl;
 
   name.length(1);
   name[0].id   = CORBA::string_dup((const char*)channel_name);
@@ -91,23 +91,23 @@
     CORBA::Object_var channel_ref = name_context->resolve(name);
     channel = CosNA::EventChannel::_narrow(channel_ref);
     if ( CORBA::is_nil(channel) ) {
-      cerr << "Failed to narrow object found in naming service " <<
-	" to type CosNotifyChannelAdmin::EventChannel" << endl;
+      std::cerr << "Failed to narrow object found in naming service " <<
+	" to type CosNotifyChannelAdmin::EventChannel" << std::endl;
       return channel; // failure
     }
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Invalid name" << endl;
+    std::cerr << "Invalid name" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while resolving event channel name" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while resolving event channel name" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving event channel name" << endl;
+    std::cerr << "Caught exception while resolving event channel name" << std::endl;
     return channel; // failure
   }
   if (verbose)
-    cout << "Found valid channel reference" << endl;
+    std::cout << "Found valid channel reference" << std::endl;
   return channel; // success
 }
 
@@ -121,30 +121,30 @@
   CosNaming::Name name;
 
   if (verbose)
-    cout << "Obtaining naming service reference" << endl;
+    std::cout << "Obtaining naming service reference" << std::endl;
   if (!factory_name || strlen(factory_name) == 0) return channel; // empty string -- ignore
   try {
     CORBA::Object_var name_service;
     name_service = orb->resolve_initial_references("NameService"); 
     name_context = CosNaming::NamingContext::_narrow(name_service);
     if ( CORBA::is_nil(name_context) ) {
-      cerr << "Failed to obtain context for NameService" << endl;
+      std::cerr << "Failed to obtain context for NameService" << std::endl;
       return channel; // failure
     } 
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Service required is invalid [does not exist]" << endl;
+    std::cerr << "Service required is invalid [does not exist]" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving the naming service" << endl;
+    std::cerr << "Caught exception while resolving the naming service" << std::endl;
     return channel; // failure
   }
 
   if (verbose)
-    cout << "Looking up channel factory name " << factory_name << " . " << factory_name << endl;
+    std::cout << "Looking up channel factory name " << factory_name << " . " << factory_name << std::endl;
 
   name.length(1);
   name[0].id   = CORBA::string_dup((const char*)factory_name);
@@ -154,41 +154,41 @@
     CORBA::Object_var factory_ref = name_context->resolve(name);
     factory = CosNA::EventChannelFactory::_narrow(factory_ref);
     if ( CORBA::is_nil(factory) ) {
-      cerr << "Failed to narrow object found in naming service " <<
-	" to type CosNotifyChannelAdmin::EventChannelFactory" << endl;
+      std::cerr << "Failed to narrow object found in naming service " <<
+	" to type CosNotifyChannelAdmin::EventChannelFactory" << std::endl;
       return channel; // failure
     }
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Invalid name" << endl;
+    std::cerr << "Invalid name" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while resolving event channel factory name" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while resolving event channel factory name" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving event channel factory name" << endl;
+    std::cerr << "Caught exception while resolving event channel factory name" << std::endl;
     return channel; // failure
   }
   if (verbose) {
-    cout << "Found valid channel factory reference" << endl;
-    cout << "Looking up channel id " << chan_id << endl;
+    std::cout << "Found valid channel factory reference" << std::endl;
+    std::cout << "Looking up channel id " << chan_id << std::endl;
   }
 
   try {
     channel = factory->get_event_channel( chan_id );
     if ( CORBA::is_nil(channel) ) {
-      cerr << "Failed to find channel id " << chan_id << endl;
+      std::cerr << "Failed to find channel id " << chan_id << std::endl;
       return channel; // failure
     }
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while invoking get_event_channel" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while invoking get_event_channel" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while invoking get_event_channel" << endl;
+    std::cerr << "Caught exception while invoking get_event_channel" << std::endl;
     return channel; // failure
   }
   if (verbose)
-    cout << "Found valid channel reference" << endl;
+    std::cout << "Found valid channel reference" << std::endl;
   return channel; // success
 }
 
@@ -201,30 +201,30 @@
   CosNaming::Name name;
 
   if (verbose)
-    cout << "Obtaining naming service reference" << endl;
+    std::cout << "Obtaining naming service reference" << std::endl;
   if (!factory_name || strlen(factory_name) == 0) return channel; // empty string -- ignore
   try {
     CORBA::Object_var name_service;
     name_service = orb->resolve_initial_references("NameService"); 
     name_context = CosNaming::NamingContext::_narrow(name_service);
     if ( CORBA::is_nil(name_context) ) {
-      cerr << "Failed to obtain context for NameService" << endl;
+      std::cerr << "Failed to obtain context for NameService" << std::endl;
       return channel; // failure
     } 
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Service required is invalid [does not exist]" << endl;
+    std::cerr << "Service required is invalid [does not exist]" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving the naming service" << endl;
+    std::cerr << "Caught exception while resolving the naming service" << std::endl;
     return channel; // failure
   }
 
   if (verbose)
-    cout << "Looking up channel factory name " << factory_name << " . " << factory_name << endl;
+    std::cout << "Looking up channel factory name " << factory_name << " . " << factory_name << std::endl;
 
   name.length(1);
   name[0].id   = CORBA::string_dup((const char*)factory_name);
@@ -234,24 +234,24 @@
     CORBA::Object_var factory_ref = name_context->resolve(name);
     factory = CosNA::EventChannelFactory::_narrow(factory_ref);
     if ( CORBA::is_nil(factory) ) {
-      cerr << "Failed to narrow object found in naming service " <<
-	" to type CosNotifyChannelAdmin::EventChannelFactory" << endl;
+      std::cerr << "Failed to narrow object found in naming service " <<
+	" to type CosNotifyChannelAdmin::EventChannelFactory" << std::endl;
       return channel; // failure
     }
   }
   catch(CORBA::ORB::InvalidName& ex) {
-    cerr << "Invalid name" << endl;
+    std::cerr << "Invalid name" << std::endl;
     return channel; // failure
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while resolving event channel factory name" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while resolving event channel factory name" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while resolving event channel factory name" << endl;
+    std::cerr << "Caught exception while resolving event channel factory name" << std::endl;
     return channel; // failure
   }
   if (verbose) {
-    cout << "Found valid channel factory reference" << endl;
-    cout << "Creating new channel" << endl;
+    std::cout << "Found valid channel factory reference" << std::endl;
+    std::cout << "Creating new channel" << std::endl;
   }
 
   CosNA::ChannelID         chan_id;
@@ -264,18 +264,18 @@
 
     channel = factory->create_channel(qosP, admP, chan_id);
     if ( CORBA::is_nil(channel) ) {
-      cerr << "Failed to create new channel" << endl;
+      std::cerr << "Failed to create new channel" << std::endl;
       return channel; // failure
     }
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while invoking create_channel" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while invoking create_channel" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while invoking create_channel" << endl;
+    std::cerr << "Caught exception while invoking create_channel" << std::endl;
     return channel; // failure
   }
   if (verbose)
-    cout << "Created a new channel with channel ID " << chan_id << endl;
+    std::cout << "Created a new channel with channel ID " << chan_id << std::endl;
   return channel; // success
 }
 
@@ -289,11 +289,11 @@
 
   if (!ior_file || strlen(ior_file) == 0) return channel; // empty string -- ignore
   if (! (ifile = fopen(ior_file, "r")) ) {
-    cerr << "Failed to open file " << ior_file << " for reading" << endl;
+    std::cerr << "Failed to open file " << ior_file << " for reading" << std::endl;
     return channel; // failure
   }
   if (fscanf(ifile, "%s", buf) != 1) {
-    cerr << "Failed to get an IOR from file " << ior_file << endl;
+    std::cerr << "Failed to get an IOR from file " << ior_file << std::endl;
     fclose(ifile);
     return channel; // failure
   }
@@ -301,22 +301,22 @@
   try {
     CORBA::Object_var fact_ref = orb->string_to_object(buf);
     if ( CORBA::is_nil(fact_ref) ) {
-      cerr << "Failed to turn IOR in file " << ior_file << " into object" << endl;
+      std::cerr << "Failed to turn IOR in file " << ior_file << " into object" << std::endl;
       return channel; // failure
     }
     factory = CosNA::EventChannelFactory::_narrow(fact_ref);
     if ( CORBA::is_nil(factory) ) {
-      cerr << "Failed to narrow object from IOR in file " << ior_file <<
-	" to type CosNotifyChannelAdmin::EventChannelFactory" << endl;
+      std::cerr << "Failed to narrow object from IOR in file " << ior_file <<
+	" to type CosNotifyChannelAdmin::EventChannelFactory" << std::endl;
       return channel; // failure
     }
   } catch (...) {
-    cerr << "Failed to convert IOR in file " << ior_file << " to object" << endl;
+    std::cerr << "Failed to convert IOR in file " << ior_file << " to object" << std::endl;
     return channel; // failure
   }
   if (verbose) {
-    cout << "Found valid channel factory reference" << endl;
-    cout << "Creating new channel" << endl;
+    std::cout << "Found valid channel factory reference" << std::endl;
+    std::cout << "Creating new channel" << std::endl;
   }
 
   CosNA::ChannelID         chan_id;
@@ -329,18 +329,18 @@
 
     channel = factory->create_channel(qosP, admP, chan_id);
     if ( CORBA::is_nil(channel) ) {
-      cerr << "Failed to create new channel" << endl;
+      std::cerr << "Failed to create new channel" << std::endl;
       return channel; // failure
     }
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << "Caught system exception COMM_FAILURE while invoking create_channel" << endl;
+    std::cerr << "Caught system exception COMM_FAILURE while invoking create_channel" << std::endl;
     return channel; // failure
   } catch (...) {
-    cerr << "Caught exception while invoking create_channel" << endl;
+    std::cerr << "Caught exception while invoking create_channel" << std::endl;
     return channel; // failure
   }
   if (verbose)
-    cout << "Created a new channel with channel ID " << chan_id << endl;
+    std::cout << "Created a new channel with channel ID " << chan_id << std::endl;
   return channel; // success
 }
 
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/legacy_clients.cc omniNotify-2.1.new/examples/legacy_clients.cc
--- omniNotify-2.1.orig/examples/legacy_clients.cc	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/legacy_clients.cc	2009-06-28 17:19:01.000000000 +0400
@@ -4,8 +4,8 @@
 // See legacy_clients.h
 // -------------------------------------------------------------- //
 
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include "thread_wrappers.h"
 
 #include "CosNotifyShorthands.h"
@@ -40,22 +40,22 @@
   try {
     admin = channel->for_consumers();
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return 0; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return 0;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
   try {
     proxy = admin->obtain_push_supplier();
   } catch (...) {  }
   if ( CORBA::is_nil(proxy) ) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     return 0;
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
 
     // Construct a client
   LegacyPushConsumer_i* client =
@@ -70,16 +70,16 @@
   try {
     _my_proxy->connect_push_consumer(_this());
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs) 
     _worker = new GenericBoundWorkerThread(this);
@@ -91,7 +91,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPushConsumer", "LegacyPushConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -113,7 +113,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPushConsumer", "LegacyPushConsumer_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     // invariant: _oplock held at top of loop
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
@@ -138,7 +138,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using connect_push_consumer" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using connect_push_consumer" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -158,16 +158,16 @@
   _num_events++;
   if (_consume_fn)
     (*_consume_fn)(data, _obj_name, _num_events, _verbose);
-  else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+  else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
     _done = 1;
     _finish.broadcast();
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying push response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying push response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -180,7 +180,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "LegacyPushConsumer", "LegacyPushConsumer_i::diconnect_push_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -231,22 +231,22 @@
   try {
     admin = channel->for_consumers();
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return 0; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return 0;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
   try {
     proxy = admin->obtain_pull_supplier();
   } catch (...) {  }
   if ( CORBA::is_nil(proxy) ) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     return 0;
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
 
     // Construct a client
   LegacyPullConsumer_i* client =
@@ -261,17 +261,17 @@
   try {
     _my_proxy->connect_pull_consumer(_this());
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pulling
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -281,7 +281,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPullConsumer", "LegacyPullConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -309,7 +309,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPullConsumer", "LegacyPullConsumer_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main pull loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main pull loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       { // introduce temporary lock release scope; do not hold oplock across pull
@@ -322,7 +322,7 @@
       } // end temporary lock release scope
       if (_done) break; // must have disconnected during pull
       if (!data) {
-	if (_verbose) cout << _obj_name << ": strange failure: pull() returned nil" << endl;
+	if (_verbose) std::cout << _obj_name << ": strange failure: pull() returned nil" << std::endl;
 	_com_err = 1;
 	break; // break from while loop -- done
       }
@@ -330,11 +330,11 @@
       _num_events++;
       if (_consume_fn)
 	(*_consume_fn)(*data, _obj_name, _num_events, _verbose);
-      else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+      else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
       delete data;
       data = 0;
       if (_max_events && (_num_events >= _max_events)) {
-	if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	break; // done 
       }
       if (_millisecs) { // sleep for specified interval
@@ -349,7 +349,7 @@
       continue; // continue pulling
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while calling pull()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling pull()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -370,7 +370,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "LegacyPullConsumer", "LegacyPullConsumer_i::disconnect_pull_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -422,22 +422,22 @@
   try {
     admin = channel->for_suppliers();
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return 0; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return 0;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
   try {
     proxy = admin->obtain_push_consumer();
   } catch (...) {  }
   if ( CORBA::is_nil(proxy) ) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     return 0; // failure
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
 
     // Construct a client
   LegacyPushSupplier_i* client =
@@ -452,17 +452,17 @@
   try {
     _my_proxy->connect_push_supplier(_this());
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pushing
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -472,7 +472,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPushSupplier", "LegacyPushSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -500,7 +500,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPushSupplier", "LegacyPushSupplier_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main push loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main push loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
@@ -515,9 +515,9 @@
 	if (_done) break; // must have disconnected during push
 	_num_events++;
 	// [rather than doing the following we let supply_fn report if it wants to]
-	// if (_verbose) cout << _obj_name << ": Pushed an event, event count = " << _num_events << endl;
+	// if (_verbose) std::cout << _obj_name << ": Pushed an event, event count = " << _num_events << std::endl;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  break; // done
 	}
       }
@@ -534,7 +534,7 @@
       continue; // continue pushing
     com_fail:
       if (_done) break; // must have disconnected during push
-      if (_verbose) cout << _obj_name << ": communication error while calling push()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling push()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -554,7 +554,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "LegacyPushSupplier", "LegacyPushSupplier_i::disconnect_push_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -606,22 +606,22 @@
   try {
     admin = channel->for_suppliers();
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return 0; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return 0;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
   try {
     proxy = admin->obtain_pull_consumer();
   } catch (...) {  }
   if ( CORBA::is_nil(proxy) ) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     return 0; // failure
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
 
     // Construct a client
   LegacyPullSupplier_i* client =
@@ -636,16 +636,16 @@
   try {
     _my_proxy->connect_pull_supplier(_this());
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs)
     _worker = new GenericBoundWorkerThread(this);
@@ -657,7 +657,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPullSupplier", "LegacyPullSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -678,7 +678,7 @@
 
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPullSupplier", "LegacyPullSupplier_i::start_working");
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     // invariant: _oplock held at top of loop
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
@@ -703,7 +703,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using connect_pull_supplier" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using connect_pull_supplier" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -722,7 +722,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "LegacyPullSupplier", "LegacyPullSupplier_i::try_pull");
   if (_done) return data;
-  if (_verbose) cout << _obj_name << ": Channel called try_pull" << endl;
+  if (_verbose) std::cout << _obj_name << ": Channel called try_pull" << std::endl;
 
   // If we reached done point during last try_pull, it is broadcast now
   // and we return from this try_pull call without an event.
@@ -730,10 +730,10 @@
   // processed the previous try_pull (the final supplied event) before
   // we disconnect this supplier.
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << std::endl;
     _done = 1;
     _finish.broadcast();
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
     return data;
   }
 
@@ -741,14 +741,14 @@
     has_event = 1;
     _num_events++;
     // [rather than doing the following we let supply_fn report if it wants to]
-    // if (_verbose) cout << _obj_name << ": Returning an event, event count = " << _num_events << endl;
+    // if (_verbose) std::cout << _obj_name << ": Returning an event, event count = " << _num_events << std::endl;
   } else {
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying try_pull response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying try_pull response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -771,7 +771,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "LegacyPullSupplier", "LegacyPullSupplier_i::pull");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Channel called pull" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Channel called pull" << std::endl;
     // invariants: _oplock is held entering top of loop and 
     // also whenever we break out of loop
     while ( 1 ) {
@@ -779,9 +779,9 @@
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
 	_num_events++;
 	// [rather than doing the following we let supply_fn report if it wants to]
-	// if (_verbose) cout << _obj_name << ": Returning an event, event count = " << _num_events << endl;
+	// if (_verbose) std::cout << _obj_name << ": Returning an event, event count = " << _num_events << std::endl;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  _done = 1;
 	  _finish.broadcast();
 	}
@@ -801,7 +801,7 @@
     if (!_done && _delay_millisecs) {
       unsigned long d_secs     =  _delay_millisecs / 1000;
       unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-      if (_verbose) cout << _obj_name << ": delaying pull response for " << _delay_millisecs << " millisecs" << endl;
+      if (_verbose) std::cout << _obj_name << ": delaying pull response for " << _delay_millisecs << " millisecs" << std::endl;
       unsigned long t_secs, t_nanosecs;
       TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
       _finish.timedwait(t_secs, t_nanosecs);
@@ -816,7 +816,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "LegacyPullSupplier", "LegacyPullSupplier_i::discconnect_pull_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/main_program.h omniNotify-2.1.new/examples/main_program.h
--- omniNotify-2.1.orig/examples/main_program.h	2004-03-19 00:39:20.000000000 +0300
+++ omniNotify-2.1.new/examples/main_program.h	2009-06-28 17:24:41.000000000 +0400
@@ -58,7 +58,7 @@
 
 #ifndef CREATE_CHANNEL
     // (2) Obtain reference to notification channel
-    if (verbose) cout << "Obtaining reference to notification channel" << endl;
+    if (verbose) std::cout << "Obtaining reference to notification channel" << std::endl;
     CosNA::EventChannel_ptr channel = getchan_from_ns(orb, channel_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getchan_from_iorfile(orb, ior_file, verbose);
@@ -68,7 +68,7 @@
     }
 #else
     // (2) Create a new notification channel
-    if (verbose) cout << "Creating a new notification channel" << endl;
+    if (verbose) std::cout << "Creating a new notification channel" << std::endl;
     CosNA::EventChannel_ptr channel = getnewchan_use_ns(orb, cfact_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getnewchan_use_iorfile(orb, cfact_ior_file, verbose);
@@ -79,7 +79,7 @@
 #endif
 
     // (3) Create a client
-    if (verbose) cout << "Creating client" << endl;
+    if (verbose) std::cout << "Creating client" << std::endl;
 #ifndef LEGACY_CLIENT
     CLIENT_IMPL_CLASS* client =
       CLIENT_IMPL_CLASS::create(orb, channel, num_events, batch_size, CLIENT_NAME, proxy_ior_file, admin_ior_file,
@@ -94,55 +94,55 @@
       goto error_return; // failed to create client
     }
     // Obtain reference to the external client object
-    if (verbose) cout << "Obtaining CORBA object ref to client" << endl;
+    if (verbose) std::cout << "Obtaining CORBA object ref to client" << std::endl;
     CLIENT_CLASS_VAR myref = client->_this(); // implicit activation
     client->_remove_ref(); // enables POA cleanup of servant
 
     // (4) Tell POA we are ready to go
-    if (verbose) cout << "Activating POA manager" << endl;
+    if (verbose) std::cout << "Activating POA manager" << std::endl;
     PortableServer::POAManager_var pman = poa->the_POAManager();
     pman->activate();
 
     // (5) Connect client to its proxy, wait for desired # of events
-    if (verbose) cout << "Connecting client to its proxy" << endl;
+    if (verbose) std::cout << "Connecting client to its proxy" << std::endl;
     if (client->connect()) {
       // an immediate error occurred
     } else {
-      if (verbose) cout << "Waiting for desired # of events" << endl;
+      if (verbose) std::cout << "Waiting for desired # of events" << std::endl;
       // Wait until num_events has been reached
       CORBA::Boolean communication_error = client->wait_done();
       if (communication_error && (num_events > 0)) {
-	if (verbose) cout << "Communication error -- probably did not process desired # of events" << endl;
+	if (verbose) std::cout << "Communication error -- probably did not process desired # of events" << std::endl;
       }
-      if (verbose) cout << "Cleaning up" << endl;
+      if (verbose) std::cout << "Cleaning up" << std::endl;
       client->cleanup();
     }
     goto normal_return;
   }
   catch(CORBA::SystemException&) {
-    cerr << "main caught CORBA::SystemException." << endl;
+    std::cerr << "main caught CORBA::SystemException." << std::endl;
   }
   catch(CORBA::Exception&) {
-    cerr << "main caught CORBA::Exception." << endl;
+    std::cerr << "main caught CORBA::Exception." << std::endl;
   }
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {
-    cerr << "main caught omniORB::fatalException:" << endl;
-    cerr << "  file: " << fe.file() << endl;
-    cerr << "  line: " << fe.line() << endl;
-    cerr << "  mesg: " << fe.errmsg() << endl;
+    std::cerr << "main caught omniORB::fatalException:" << std::endl;
+    std::cerr << "  file: " << fe.file() << std::endl;
+    std::cerr << "  line: " << fe.line() << std::endl;
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;
   }
 #endif
   catch(...) {
     // nameclt comment says it is a bad idea to report an error here 
   }
-  cerr << "main caught an exception." << endl;
+  std::cerr << "main caught an exception." << std::endl;
  error_return:
 #ifdef CREATE_CHANNEL
 #ifdef DESTROY_CHANNEL
   try {
     if (!CORBA::is_nil(channel)) {
-      if (verbose) cout << "Destroying the channel we created" << endl;
+      if (verbose) std::cout << "Destroying the channel we created" << std::endl;
       channel->destroy();
     }
   } catch(...) { }
@@ -155,7 +155,7 @@
 #ifdef DESTROY_CHANNEL
   try {
     if (!CORBA::is_nil(channel)) {
-      if (verbose) cout << "Destroying the channel we created" << endl;
+      if (verbose) std::cout << "Destroying the channel we created" << std::endl;
       channel->destroy();
     }
   } catch(...) { }
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/ndadmin.cc omniNotify-2.1.new/examples/ndadmin.cc
--- omniNotify-2.1.orig/examples/ndadmin.cc	2003-10-12 22:51:18.000000000 +0400
+++ omniNotify-2.1.new/examples/ndadmin.cc	2009-06-28 17:09:16.000000000 +0400
@@ -6,7 +6,7 @@
 #error COS_USES_BOA should not be set for this example
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "orb_init_name.h"
 #include "get_channel.h"
@@ -23,15 +23,15 @@
 
 static void usage(const char* pname)
 {
-  cout << "Usage: " << pname << " [-n name] [-f file] [-v]" << endl;
-  cout << "  -n name  : channel name" << endl;
-  cout << "               => use event service to lookup this name" << endl;
-  cout << "  -f file  : file containing channel IOR" << endl;
-  cout << "               => use string_to_object on the IOR" << endl;
-  cout << "  -v       : verbose output" << endl;
-  cout << "NOTE: The server has a default channel; " << pname << " finds this channel" << endl;
-  cout << "      and then goes 'UP' to find the notifd server" << endl;
-  cout << endl;
+  std::cout << "Usage: " << pname << " [-n name] [-f file] [-v]" << std::endl;
+  std::cout << "  -n name  : channel name" << std::endl;
+  std::cout << "               => use event service to lookup this name" << std::endl;
+  std::cout << "  -f file  : file containing channel IOR" << std::endl;
+  std::cout << "               => use string_to_object on the IOR" << std::endl;
+  std::cout << "  -v       : verbose output" << std::endl;
+  std::cout << "NOTE: The server has a default channel; " << pname << " finds this channel" << std::endl;
+  std::cout << "      and then goes 'UP' to find the notifd server" << std::endl;
+  std::cout << std::endl;
 }
 
 int main(int argc, char** argv) {
@@ -78,12 +78,12 @@
     }
 
     // (2) Obtain reference to notification channel
-    if (verbose) cout << "Obtaining reference to notification channel" << endl;
+    if (verbose) std::cout << "Obtaining reference to notification channel" << std::endl;
     channel = getchan_from_ns(orb, channel_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getchan_from_iorfile(orb, ior_file, verbose);
       if (CORBA::is_nil(channel)) {
-	if (verbose) cout << "Could not find server's default channel" << endl;
+	if (verbose) std::cout << "Could not find server's default channel" << std::endl;
 	goto err_return; // both methods failed
       }
     }
@@ -97,7 +97,7 @@
     catch ( CORBA::OBJECT_NOT_EXIST& e ) { docmd_problem = 1; } \
     catch ( CORBA::COMM_FAILURE& e ) { docmd_problem = 1; }
     if (!success || !target_changed || docmd_problem) {
-      if (verbose) cout << "Could not find server's default channel" << endl;
+      if (verbose) std::cout << "Could not find server's default channel" << std::endl;
       goto err_return;
     }
     target = next_target;
@@ -108,7 +108,7 @@
     catch ( CORBA::OBJECT_NOT_EXIST& e ) { docmd_problem = 1; } \
     catch ( CORBA::COMM_FAILURE& e ) { docmd_problem = 1; }
     if (!success || !target_changed || docmd_problem) {
-      if (verbose) cout << "Could not find server's default channel" << endl;
+      if (verbose) std::cout << "Could not find server's default channel" << std::endl;
       goto err_return;
     }
     target = AttN::Interactive::_duplicate(next_target);
@@ -119,23 +119,23 @@
     goto norm_return;
   }
   catch(CORBA::SystemException&) {                     
-    cerr << pname << " main caught CORBA::SystemException." << endl;  
+    std::cerr << pname << " main caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << pname << " main caught CORBA::Exception." << endl;        
+    std::cerr << pname << " main caught CORBA::Exception." << std::endl;        
   }                                                    
   catch(omniORB::fatalException& fe) {                 
-    cerr << "main caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "main caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
   catch(...) {                                         
     // nameclt comment says it is a bad idea to report an error here 
   }
-  cerr << "main caught an exception." << endl;
+  std::cerr << "main caught an exception." << std::endl;
  err_return:
-  cerr << "QUITTING due to error" << endl;
+  std::cerr << "QUITTING due to error" << std::endl;
   return -1;
  norm_return:
   return 0;
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/parse_cmd_line.h omniNotify-2.1.new/examples/parse_cmd_line.h
--- omniNotify-2.1.orig/examples/parse_cmd_line.h	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/parse_cmd_line.h	2009-06-28 17:13:49.000000000 +0400
@@ -4,7 +4,7 @@
 #define _PARSE_CMD_LINE_H
 
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 
 #include "CosNotifyShorthands.h"
 
@@ -18,47 +18,47 @@
 
 static void usage(const char* pname, CORBA::Boolean supports_filters)
 {
-  cout << "Usage: " << pname << " [-d #] [-b #] [-m #] [-M #] [-n name] [-f file] [-N name] [-F file] [-p file] [-a file] [-v]";
+  std::cout << "Usage: " << pname << " [-d #] [-b #] [-m #] [-M #] [-n name] [-f file] [-N name] [-F file] [-p file] [-a file] [-v]";
   if (supports_filters) {
-    cout << " [-t types] [-e expr]" << endl;
+    std::cout << " [-t types] [-e expr]" << std::endl;
   } else {
-    cout << endl;
+    std::cout << std::endl;
   }
-  cout << "  -d #     : disconnect after # events [default 0 means never disconnect]" << endl;
-  cout << "  -b #     : batch size (only relevant for batch supplier programs) [default 5]" << endl;
-  cout << "               => must be >= 1" << endl;
-  cout << "  -m #     : # of milliseconds to pause between each push/pull [default 0]" << endl;
-  cout << "  -M #     : # of milliseconds to pause during incoming push, pull, try_pull [default 0]" << endl;
-  cout << "             (-M only applies to push consumers and pull suppliers)" << endl;
-  cout << "  -n name  : channel name" << endl;
-  cout << "               => use event service to lookup this name" << endl;
-  cout << "  -f file  : file containing channel IOR" << endl;
-  cout << "               => use string_to_object on the IOR" << endl;
-  cout << "  -N name  : factory name" << endl;
-  cout << "               => use event service to lookup this name" << endl;
-  cout << "  -F file  : file containing channel factory IOR" << endl;
-  cout << "               => use string_to_object on the IOR" << endl;
-  cout << "  -p file  : file to store IOR of the proxy used by this client" << endl;
-  cout << "                (used by demo_add_filter, demo_offer_change, or demo_subscription_chang)" << endl;
-  cout << "  -a file  : file to store IOR of the admin used by this client" << endl;
-  cout << "                (used by demo_add_filter, demo_offer_change, or demo_subscription_chang)" << endl;
-  cout << "  -v       : verbose output" << endl;
-  cout << endl;
+  std::cout << "  -d #     : disconnect after # events [default 0 means never disconnect]" << std::endl;
+  std::cout << "  -b #     : batch size (only relevant for batch supplier programs) [default 5]" << std::endl;
+  std::cout << "               => must be >= 1" << std::endl;
+  std::cout << "  -m #     : # of milliseconds to pause between each push/pull [default 0]" << std::endl;
+  std::cout << "  -M #     : # of milliseconds to pause during incoming push, pull, try_pull [default 0]" << std::endl;
+  std::cout << "             (-M only applies to push consumers and pull suppliers)" << std::endl;
+  std::cout << "  -n name  : channel name" << std::endl;
+  std::cout << "               => use event service to lookup this name" << std::endl;
+  std::cout << "  -f file  : file containing channel IOR" << std::endl;
+  std::cout << "               => use string_to_object on the IOR" << std::endl;
+  std::cout << "  -N name  : factory name" << std::endl;
+  std::cout << "               => use event service to lookup this name" << std::endl;
+  std::cout << "  -F file  : file containing channel factory IOR" << std::endl;
+  std::cout << "               => use string_to_object on the IOR" << std::endl;
+  std::cout << "  -p file  : file to store IOR of the proxy used by this client" << std::endl;
+  std::cout << "                (used by demo_add_filter, demo_offer_change, or demo_subscription_chang)" << std::endl;
+  std::cout << "  -a file  : file to store IOR of the admin used by this client" << std::endl;
+  std::cout << "                (used by demo_add_filter, demo_offer_change, or demo_subscription_chang)" << std::endl;
+  std::cout << "  -v       : verbose output" << std::endl;
+  std::cout << std::endl;
   if (supports_filters) {
-    cout << "Options for adding a filter:" << endl;
-    cout << "  -t types : add a filter for the specified types, which should be a" << endl;
-    cout << "               comma-separated list of types of the form D::T" << endl;
-    cout << "  -e expr  : add a filter with the specified boolean expression" << endl;
-    cout << endl;
-    cout << "If only -t specified, the expression \"true\" is used for the filter" << endl;
-    cout << "If only -e specified, the event type \"*::*\" is used for the filter" << endl;
-    cout << endl;
-  }
-  cout << "If both -n and -f are specified, the -n option is tried first" << endl;
-  cout << endl;
-  cout << "If neither -n or -f is specified, program first tries name service" << endl;
-  cout << "using name \"EventChannel\", then default IOR file /tmp/rdichan.ior" << endl;
-  cout << endl;
+    std::cout << "Options for adding a filter:" << std::endl;
+    std::cout << "  -t types : add a filter for the specified types, which should be a" << std::endl;
+    std::cout << "               comma-separated list of types of the form D::T" << std::endl;
+    std::cout << "  -e expr  : add a filter with the specified boolean expression" << std::endl;
+    std::cout << std::endl;
+    std::cout << "If only -t specified, the expression \"true\" is used for the filter" << std::endl;
+    std::cout << "If only -e specified, the event type \"*::*\" is used for the filter" << std::endl;
+    std::cout << std::endl;
+  }
+  std::cout << "If both -n and -f are specified, the -n option is tried first" << std::endl;
+  std::cout << std::endl;
+  std::cout << "If neither -n or -f is specified, program first tries name service" << std::endl;
+  std::cout << "using name \"EventChannel\", then default IOR file /tmp/rdichan.ior" << std::endl;
+  std::cout << std::endl;
 }
 
 // return 0 if etype_list is a valid comma-separated event type list
@@ -201,12 +201,12 @@
     cfact_ior_file = (char*)"/tmp/rdifact.ior";
   }
   if ( (!supports_filters) && ( strlen(etype_list) || strlen(constraint_expr) ) ) {
-    cout << "Filter options not supported for this client" << endl;
+    std::cout << "Filter options not supported for this client" << std::endl;
     usage(pname, supports_filters);
     return 1; // error
   }
   if (strlen(etype_list) && parse_etype_list(etype_list, evs)) {
-    cout << "Event type list for -t option must be comma-separated list of D::T" << endl << endl; 
+    std::cout << "Event type list for -t option must be comma-separated list of D::T" << std::endl << std::endl; 
     usage(pname, supports_filters);
     return 1;
   }
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/sample_clients.cc omniNotify-2.1.new/examples/sample_clients.cc
--- omniNotify-2.1.orig/examples/sample_clients.cc	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/sample_clients.cc	2009-06-28 17:17:16.000000000 +0400
@@ -7,9 +7,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fstream.h>
-#include <iostream.h>
-#include <iomanip.h>
+#include <fstream>
+#include <iostream>
+#include <iomanip>
 
 #ifdef HAVE_UNISTD_H
 #  include <unistd.h>
@@ -70,7 +70,7 @@
 
 // This helper routine informs channel that type ANY will be supplied
 void offer_any(CosNC::NotifyPublish_ptr proxy, const char* objnm, CORBA::Boolean verbose) {
-  if (verbose) cout << objnm << ": offering type %ANY" << endl;
+  if (verbose) std::cout << objnm << ": offering type %ANY" << std::endl;
   CosN::EventTypeSeq added, deled;
   added.length(1);
   added[0].domain_name = CORBA::string_dup("");
@@ -79,13 +79,13 @@
   try {
     proxy->offer_change(added, deled);
   } catch (...) {
-    if (verbose) cout << "** registration failed **" << endl;
+    if (verbose) std::cout << "** registration failed **" << std::endl;
   }
 }
 
 // This helper routine informs channel that types Stock::Ticker and Bond::Ticker will be supplied
 void offer_ticker(CosNC::NotifyPublish_ptr proxy, const char* objnm, CORBA::Boolean verbose) {
-  if (verbose) cout << objnm << ": offering types Stock::Ticker and Bond::Ticker" << endl;
+  if (verbose) std::cout << objnm << ": offering types Stock::Ticker and Bond::Ticker" << std::endl;
   CosN::EventTypeSeq added, deled;
   added.length(2);
   added[0].domain_name = CORBA::string_dup("Stock");
@@ -96,7 +96,7 @@
   try {
     proxy->offer_change(added, deled);
   } catch (...) {
-    if (verbose) cout << "** registration failed **" << endl;
+    if (verbose) std::cout << "** registration failed **" << std::endl;
   }
 }
 
@@ -104,19 +104,19 @@
 void write_ior_to_file(CORBA::ORB_ptr orb, CORBA::Object_ptr o,
 		       const char* filenm, CORBA::Boolean verbose) {
   if (strlen(filenm) == 0) {
-    if (verbose) cout << "ior filename empty -- skipping" << endl;
+    if (verbose) std::cout << "ior filename empty -- skipping" << std::endl;
     return;
   }
-  ofstream file(filenm, ios::out);
+  std::ofstream file(filenm, std::ios::out);
   if ( ! file ) {
-    if (verbose) cerr << "Failed to open IOR file: " << filenm << endl;
+    if (verbose) std::cerr << "Failed to open IOR file: " << filenm << std::endl;
     return;
   }
   char* ior_name = orb->object_to_string(o);
   file << ior_name;
   file.close();
   delete [] ior_name;
-  if (verbose) cout << "wrote IOR to file: " << filenm << endl;
+  if (verbose) std::cout << "wrote IOR to file: " << filenm << std::endl;
 }
 
 // These 2 helper routines are used to obtain one of the
@@ -138,14 +138,14 @@
   try {
     admin = channel->new_for_suppliers(ifoper, admID);
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return generic_proxy; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return generic_proxy;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
 
   CosNA::ProxyID prxID;
   try {
@@ -156,14 +156,14 @@
     }
   } catch (...) {  }
   if (CORBA::is_nil(generic_proxy)) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     try {
       admin->destroy();
     } catch (...) { }
     admin = CosNA::SupplierAdmin::_nil();
     return generic_proxy;
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
   write_ior_to_file(orb, admin, admin_ior_file, verbose);
   return generic_proxy; // success if generic_proxy is non-nil, otherwise failure
 }
@@ -183,14 +183,14 @@
   try {
     admin = channel->new_for_consumers(ifoper, admID);
     if ( CORBA::is_nil(admin) ) {
-      cerr << "Failed to obtain admin" << endl;
+      std::cerr << "Failed to obtain admin" << std::endl;
       return generic_proxy; // failure
     }
   } catch (...) {
-    cerr << "Failed to obtain admin" << endl;
+    std::cerr << "Failed to obtain admin" << std::endl;
     return generic_proxy;  // failure
   }
-  if (verbose) cout << "Obtained admin from the channel" << endl;
+  if (verbose) std::cout << "Obtained admin from the channel" << std::endl;
 
   CosNA::ProxyID prxID;
   try {
@@ -201,14 +201,14 @@
     }
   } catch (...) {  }
   if (CORBA::is_nil(generic_proxy)) {
-    cerr << "Failed to obtain proxy" << endl;
+    std::cerr << "Failed to obtain proxy" << std::endl;
     try {
       admin->destroy();
     } catch (...) { }
     admin = CosNA::ConsumerAdmin::_nil();
     return generic_proxy;
   }
-  if (verbose) cout << "Obtained proxy from admin" << endl;
+  if (verbose) std::cout << "Obtained proxy from admin" << std::endl;
   write_ior_to_file(orb, admin, admin_ior_file, verbose);
   return generic_proxy; // success if generic_proxy is non-nil, otherwise failure
 }
@@ -226,24 +226,24 @@
 		  CORBA::Boolean verbose) {
   // if evs and constraint expr are empty, we ignore them + do not add a filter
   if ( (evs.length() == 0) && (strlen(constraint_expr) == 0) ) {
-    if (verbose) cout << obj_name << ": (no filter used)" << endl;
+    if (verbose) std::cout << obj_name << ": (no filter used)" << std::endl;
     return 0; // OK
   }
   // Obtain a reference to the default filter factory; create a filter object 
   CosNF::FilterFactory_ptr ffp;
   filter = CosNF::Filter::_nil();
   try {
-    if (verbose) cout << obj_name << ": Obtaining default filter factory" << endl;
+    if (verbose) std::cout << obj_name << ": Obtaining default filter factory" << std::endl;
     ffp    = channel->default_filter_factory();  
     filter = ffp->create_filter("EXTENDED_TCL");
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << obj_name << ": Caught COMM_FAILURE obtaining filter object" << endl;
+    std::cerr << obj_name << ": Caught COMM_FAILURE obtaining filter object" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << obj_name << ": Caught exception obtaining filter object" << endl;
+    std::cerr << obj_name << ": Caught exception obtaining filter object" << std::endl;
     return 1; // error
   }
-  if (verbose) cout << obj_name << ": Obtained filter from default filter factory" << endl;
+  if (verbose) std::cout << obj_name << ": Obtained filter from default filter factory" << std::endl;
 
   // Construct a simple constraint expression; add it to fadmin
   CosNF::ConstraintExpSeq   exp;
@@ -252,32 +252,32 @@
   exp[0].constraint_expr = CORBA::string_dup(constraint_expr);
   CORBA::Boolean res = 0; // OK
   try {
-    if (verbose) cout << obj_name << ": Adding constraints to filter" << endl;
+    if (verbose) std::cout << obj_name << ": Adding constraints to filter" << std::endl;
     filter->add_constraints(exp);
-    if (verbose) cout << obj_name << ": Adding filter to target" << endl;
+    if (verbose) std::cout << obj_name << ": Adding filter to target" << std::endl;
     fadmin->add_filter(filter);
     if (verbose) {
       if (evs.length()) {
-	cout << obj_name << ": Added filter for types ";
+	std::cout << obj_name << ": Added filter for types ";
 	for (unsigned int j = 0; j < evs.length(); j++) { 
-	  cout << (const char*)evs[j].domain_name << "::" << (const char*)evs[j].type_name;
+	  std::cout << (const char*)evs[j].domain_name << "::" << (const char*)evs[j].type_name;
 	  if ((j+1) < evs.length())
-	    cout << ", ";
+	    std::cout << ", ";
 	}
       } else {
-	cout << obj_name << ": Added filter for type *::* ";
+	std::cout << obj_name << ": Added filter for type *::* ";
       }
-      cout << " and constraint expression \"" << constraint_expr << "\" " << endl;
+      std::cout << " and constraint expression \"" << constraint_expr << "\" " << std::endl;
     }
   }
   catch(CosNF::InvalidConstraint& _exobj1) {
-    cerr << obj_name << ": Exception thrown : Invalid constraint given "
-	 << (const char *)constraint_expr << endl;
+    std::cerr << obj_name << ": Exception thrown : Invalid constraint given "
+	 << (const char *)constraint_expr << std::endl;
     res = 1; // error
   }
   catch (...) {
-    cerr << obj_name << ": Exception thrown while adding constraint " 
-	 << (const char *)constraint_expr << endl; 
+    std::cerr << obj_name << ": Exception thrown while adding constraint " 
+	 << (const char *)constraint_expr << std::endl; 
     res = 1; // error
   }
   if (res == 1) { // error so destroy filter
@@ -306,17 +306,17 @@
   CosNF::FilterFactory_ptr ffp;
   filter = CosNF::Filter::_nil();
   try {
-    if (verbose) cout << obj_name << ": Obtaining default filter factory" << endl;
+    if (verbose) std::cout << obj_name << ": Obtaining default filter factory" << std::endl;
     ffp    = channel->default_filter_factory();  
     filter = ffp->create_filter("EXTENDED_TCL");
   } catch (CORBA::COMM_FAILURE& ex) {
-    cerr << obj_name << ": Caught COMM_FAILURE obtaining filter object" << endl;
+    std::cerr << obj_name << ": Caught COMM_FAILURE obtaining filter object" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << obj_name << ": Caught exception obtaining filter object" << endl;
+    std::cerr << obj_name << ": Caught exception obtaining filter object" << std::endl;
     return 1; // error
   }
-  if (verbose) cout << obj_name << ": Obtained filter from default filter factory" << endl;
+  if (verbose) std::cout << obj_name << ": Obtained filter from default filter factory" << std::endl;
 
   // Construct a simple constraint expression; add it to fadmin
   CosNF::ConstraintExpSeq   exp;
@@ -327,29 +327,29 @@
   exp[0].constraint_expr = CORBA::string_dup("true");
   CORBA::Boolean res = 0; // OK
   try {
-    if (verbose) cout << obj_name << ": Adding initial dummy constraint to filter" << endl;
+    if (verbose) std::cout << obj_name << ": Adding initial dummy constraint to filter" << std::endl;
     if (verbose) {
-      cout << obj_name << ": Adding constraint with dummy type Type_XXX and constraint \"true\" to filter" << endl;
+      std::cout << obj_name << ": Adding constraint with dummy type Type_XXX and constraint \"true\" to filter" << std::endl;
     }
     filter->add_constraints(exp);
-    if (verbose) cout << obj_name << ": Adding filter to target" << endl;
+    if (verbose) std::cout << obj_name << ": Adding filter to target" << std::endl;
     fadmin->add_filter(filter);
     for (int i = 0; i < 512; i++) {
       char buf[1024];
       sprintf(buf, "Type_%03d", i);
       exp[0].event_types[0].type_name = CORBA::string_dup(buf);
       if (verbose) {
-	cout << obj_name << ": Adding constraint with type " << buf << " and constraint \"true\" to filter" << endl;
+	std::cout << obj_name << ": Adding constraint with type " << buf << " and constraint \"true\" to filter" << std::endl;
       }
       filter->add_constraints(exp);
     }
   }
   catch(CosNF::InvalidConstraint& _exobj1) {
-    cerr << obj_name << ": Exception thrown : Invalid constraint given" << endl;
+    std::cerr << obj_name << ": Exception thrown : Invalid constraint given" << std::endl;
     res = 1; // error
   }
   catch (...) {
-    cerr << obj_name << ": Exception thrown while adding constraint/filter" << endl; 
+    std::cerr << obj_name << ": Exception thrown while adding constraint/filter" << std::endl; 
     res = 1; // error
   }
 
@@ -445,16 +445,16 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl;
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl;
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs)
     _worker = new GenericBoundWorkerThread(this);
@@ -466,11 +466,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PushConsumer", "PushConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy
@@ -496,7 +496,7 @@
 
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PushConsumer", "PushConsumer_i::start_working");
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
       unsigned long t_secs = 0, t_nanosecs = 0;
@@ -518,7 +518,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -538,16 +538,16 @@
   _num_events++;
   if (_consume_fn)
     (*_consume_fn)(data, _obj_name, _num_events, _verbose);
-  else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+  else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
     _done = 1;
     _finish.broadcast();
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying push response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying push response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -560,7 +560,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "PushConsumer", "PushConsumer_i::disconnect_push_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -590,11 +590,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -678,16 +678,16 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs) 
     _worker = new GenericBoundWorkerThread(this);
@@ -699,11 +699,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPushConsumer", "StructuredPushConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -730,7 +730,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPushConsumer", "StructuredPushConsumer_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
       unsigned long t_secs = 0, t_nanosecs = 0;
@@ -752,7 +752,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -771,16 +771,16 @@
   _num_events++;
   if (_consume_fn)
     (*_consume_fn)(data, _obj_name, _num_events, _verbose);
-  else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+  else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
     _done = 1;
     _finish.broadcast();
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying push_structured_event response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying push_structured_event response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -793,7 +793,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "StructuredPushConsumer", "StructuredPushConsumer_i::disconnect_structured_push_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -823,11 +823,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -922,16 +922,16 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs) 
     _worker = new GenericBoundWorkerThread(this);
@@ -943,11 +943,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "Structured512PushConsumer", "Structured512PushConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -974,7 +974,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "Structured512PushConsumer", "Structured512PushConsumer_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     // invariant: _oplock held at top of loop
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
@@ -997,7 +997,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -1016,16 +1016,16 @@
   _num_events++;
   if (_consume_fn)
     (*_consume_fn)(data, _obj_name, _num_events, _verbose);
-  else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+  else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
     _done = 1;
     _finish.broadcast();
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying push_structured_event response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying push_structured_event response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1038,7 +1038,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "Structured512PushConsumer", "Structured512PushConsumer_i::disconnect_structured_push_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -1068,11 +1068,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1155,16 +1155,16 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   // if _millisecs is set, spawn a thread to ping the proxy
   if (_millisecs)
     _worker = new GenericBoundWorkerThread(this);
@@ -1176,11 +1176,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePushConsumer", "SequencePushConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -1207,7 +1207,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePushConsumer", "SequencePushConsumer_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     // invariant: _oplock held at top of loop
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
@@ -1230,7 +1230,7 @@
       continue; // continue ping loop
     com_fail:
 	if (_done) break;
-	if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+	if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
 	_done = 1;
 	_finish.broadcast();
 	_com_err = 1;
@@ -1250,16 +1250,16 @@
   _num_events += data.length();
   if (_consume_fn)
     (*_consume_fn)(data, _obj_name, _num_events, _num_batches, _verbose);
-  else if (_verbose) cout << _obj_name << ": event count = " << _num_events << " batch count = " << _num_batches << endl;
+  else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << " batch count = " << _num_batches << std::endl;
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
     _done = 1;
     _finish.broadcast();
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying push_structured_events response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying push_structured_events response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1272,7 +1272,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "SequencePushConsumer", "SequencePushConsumer_i::disconnect_sequence_push_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -1302,11 +1302,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1393,17 +1393,17 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pulling
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -1413,11 +1413,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PullConsumer", "PullConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -1450,7 +1450,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PullConsumer", "PullConsumer_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main pull loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main pull loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       { // introduce temporary lock release scope; do not hold oplock across pull
@@ -1463,7 +1463,7 @@
       } // end temporary lock release scope
       if (_done) break; // must have disconnected during pull
       if (!data) {
-	if (_verbose) cout << _obj_name << ": strange failure: pull() returned nil" << endl;
+	if (_verbose) std::cout << _obj_name << ": strange failure: pull() returned nil" << std::endl;
 	_com_err = 1;
 	break; // break from while loop -- done
       }
@@ -1471,11 +1471,11 @@
       _num_events++;
       if (_consume_fn)
 	(*_consume_fn)(*data, _obj_name, _num_events, _verbose);
-      else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+      else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
       delete data;
       data = 0;
       if (_max_events && (_num_events >= _max_events)) {
-	if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	break; // done 
       }
       if (_millisecs) { // sleep for specified interval
@@ -1490,7 +1490,7 @@
       continue; // continue pulling
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while calling pull()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling pull()" << std::endl;
       _com_err = 1;
       break;
     } // end while loop
@@ -1510,7 +1510,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "PullConsumer", "PullConsumer_i::disconnect_pull_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -1540,11 +1540,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1629,17 +1629,17 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pulling
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -1649,11 +1649,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPullConsumer", "StructuredPullConsumer_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -1686,7 +1686,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPullConsumer", "StructuredPullConsumer_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main pull loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main pull loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       { // introduce temporary lock release scope; do not hold oplock across pull
@@ -1699,7 +1699,7 @@
       } // end temporary lock release scope
       if (_done) break; // must have disconnected during pull
       if (!data) {
-	if (_verbose) cout << _obj_name << ": strange failure: pull_structured_event() returned nil" << endl;
+	if (_verbose) std::cout << _obj_name << ": strange failure: pull_structured_event() returned nil" << std::endl;
 	_com_err = 1;
 	break; // break from while loop -- done
       }
@@ -1707,11 +1707,11 @@
       _num_events++;
       if (_consume_fn)
 	(*_consume_fn)(*data, _obj_name, _num_events, _verbose);
-      else if (_verbose) cout << _obj_name << ": event count = " << _num_events << endl;
+      else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << std::endl;
       delete data;
       data = 0;
       if (_max_events && (_num_events >= _max_events)) {
-	if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	break; // done
       }
       if (_millisecs) { // sleep for specified interval
@@ -1726,7 +1726,7 @@
       continue; // continue pulling
     com_fail:
       if (_done) break; // must have disconnected during pull
-      if (_verbose) cout << _obj_name << ": communication error while calling pull_structured_event()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling pull_structured_event()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -1747,7 +1747,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "StructuredPullConsumer", "StructuredPullConsumer_i::disconnect_structured_pull_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -1777,11 +1777,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -1865,17 +1865,17 @@
       _my_proxy->obtain_offered_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pulling
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to consume events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to consume events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -1885,11 +1885,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePullConsumer", "SequencePullConsumer_i::connect");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -1922,7 +1922,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePullConsumer", "SequencePullConsumer_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main pull loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main pull loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       { // introduce temporary lock release scope; do not hold oplock across pull
@@ -1935,7 +1935,7 @@
       } // end temporary lock release scope
       if (_done) break; // must have disconnected during pull
       if (!data) {
-	if (_verbose) cout << _obj_name << ": strange failure: pull_structured_events() returned nil" << endl;
+	if (_verbose) std::cout << _obj_name << ": strange failure: pull_structured_events() returned nil" << std::endl;
 	_com_err = 1;
 	break; // break from while loop -- done
       }
@@ -1944,11 +1944,11 @@
       _num_events += data->length();
       if (_consume_fn)
 	(*_consume_fn)(*data, _obj_name, _num_events, _num_batches, _verbose);
-      else if (_verbose) cout << _obj_name << ": event count = " << _num_events << " batch count = " << _num_batches << endl;
+      else if (_verbose) std::cout << _obj_name << ": event count = " << _num_events << " batch count = " << _num_batches << std::endl;
       delete data;
       data = 0;
       if (_max_events && (_num_events >= _max_events)) {
-	if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	break; // done
       }
       if (_millisecs) { // sleep for specified interval
@@ -1963,7 +1963,7 @@
       continue; // continue pulling
     com_fail:
       if (_done) break; // must have disconnected during pull
-      if (_verbose) cout << _obj_name << ": communication error while calling pull_structured_events()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling pull_structured_events()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -1983,7 +1983,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "SequencePullConsumer", "SequencePullConsumer_i::disconnect_sequence_pull_consumer");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -2013,11 +2013,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": offer_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying offer_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -2115,19 +2115,19 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // register the types to be supplied
   offer_any(_my_proxy, _obj_name, _verbose);
   // spawn a thread to do pushing
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -2137,11 +2137,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PushSupplier", "PushSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -2174,7 +2174,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PushSupplier", "PushSupplier_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main push loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main push loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
@@ -2189,7 +2189,7 @@
 	if (_done) break; // must have disconnected during push
 	_num_events++;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  break; // done
 	}
       }
@@ -2206,7 +2206,7 @@
       continue; // continue pushing
     com_fail:
       if (_done) break; // must have disconnected during push
-      if (_verbose) cout << _obj_name << ": communication error while calling push()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling push()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -2226,7 +2226,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "PushSupplier", "PushSupplier_i::disconnect_push_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -2256,11 +2256,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -2345,19 +2345,19 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // register the types to be supplied
   offer_ticker(_my_proxy, _obj_name, _verbose);
   // spawn a thread to do pushing
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -2367,11 +2367,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPushSupplier", "StructuredPushSupplier_i::connect");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -2404,7 +2404,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPushSupplier", "StructuredPushSupplier_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main push loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main push loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
@@ -2419,7 +2419,7 @@
 	if (_done) break; // must have disconnected during push
 	_num_events++;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  break; // done
 	}
       }
@@ -2436,7 +2436,7 @@
       continue; // continue pushing
     com_fail:
       if (_done) break; // must have disconnected during push
-      if (_verbose) cout << _obj_name << ": communication error while calling push_structured_event()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling push_structured_event()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -2456,7 +2456,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "StructuredPushSupplier", "StructuredPushSupplier_i::disconnect_structured_push_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -2486,11 +2486,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -2575,17 +2575,17 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // spawn a thread to do pushing
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -2595,11 +2595,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "Structured512PushSupplier", "Structured512PushSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -2631,7 +2631,7 @@
   CosN::StructuredEvent* data = new CosN::StructuredEvent;
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "Structured512PushSupplier", "Structured512PushSupplier_i::start_working");
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main push loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main push loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
@@ -2646,7 +2646,7 @@
 	if (_done) break; // must have disconnected during push
 	_num_events++;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  break; // done
 	}
       }
@@ -2663,7 +2663,7 @@
       continue; // continue pushing
     com_fail:
       if (_done) break; // must have disconnected during push
-      if (_verbose) cout << _obj_name << ": communication error while calling push_structured_event()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling push_structured_event()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } //end while loop
@@ -2683,7 +2683,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "Structured512PushSupplier", "Structured512PushSupplier_i::disconnect_structured_push_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -2713,11 +2713,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -2807,19 +2807,19 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
   // register the types to be supplied
   offer_ticker(_my_proxy, _obj_name, _verbose);
   // spawn a thread to do pushing
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   _worker = new GenericBoundWorkerThread(this);
   return 0; // OK
 }
@@ -2829,11 +2829,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePushSupplier", "SequencePushSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -2867,7 +2867,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePushSupplier", "SequencePushSupplier_i::start_working");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Spawned thread entering main push loop" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Spawned thread entering main push loop" << std::endl;
     while ( 1 ) {
       if (_done) break; // must have disconnected
       data->length(0);
@@ -2884,7 +2884,7 @@
 	_num_batches++;
 	_num_events += data->length();
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  break; // done
 	}
       }
@@ -2901,7 +2901,7 @@
       continue; // continue pushing
     com_fail:
       if (_done) break; // must have disconnected during push
-      if (_verbose) cout << _obj_name << ": communication error while calling push_structured_events()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while calling push_structured_events()" << std::endl;
       _com_err = 1;
       break; // break from while loop -- done
     } // end while loop
@@ -2921,7 +2921,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "SequencePushSupplier", "SequencePushSupplier_i::disconnect_sequence_push_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -2951,11 +2951,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3053,16 +3053,16 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   // register the types to be supplied
   offer_any(_my_proxy, _obj_name, _verbose);
   // if _millisecs is set, spawn a thread to ping the proxy
@@ -3076,11 +3076,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PullSupplier", "PullSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -3107,7 +3107,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PullSupplier", "PullSupplier_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
       unsigned long t_secs = 0, t_nanosecs = 0;
@@ -3129,7 +3129,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -3148,7 +3148,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "PullSupplier", "PullSupplier_i::try_pull");
   if (_done) return data;
-  if (_verbose) cout << _obj_name << ": Channel called try_pull" << endl;
+  if (_verbose) std::cout << _obj_name << ": Channel called try_pull" << std::endl;
 
   // If we reached done point during last try_pull, it is broadcast now
   // and we return from this try_pull call without an event.
@@ -3156,10 +3156,10 @@
   // processed the previous try_pull (the final supplied event) before
   // we disconnect this supplier.
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << std::endl;
     _done = 1;
     _finish.broadcast();
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
     return data;
   }
 
@@ -3167,12 +3167,12 @@
     has_event = 1;
     _num_events++;
   } else {
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying try_pull response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying try_pull response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3194,7 +3194,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "PullSupplier", "PullSupplier_i::pull");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Channel called pull" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Channel called pull" << std::endl;
     // invariants: _oplock is held entering top of loop and 
     // also whenever we break out of loop
     // (it is *not* held during yield() and timedwait() calls)
@@ -3206,7 +3206,7 @@
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
 	_num_events++;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  _done = 1;
 	  _finish.broadcast();
 	}
@@ -3227,7 +3227,7 @@
     if (!_done && _delay_millisecs) {
       unsigned long d_secs     =  _delay_millisecs / 1000;
       unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-      if (_verbose) cout << _obj_name << ": delaying pull response for " << _delay_millisecs << " millisecs" << endl;
+      if (_verbose) std::cout << _obj_name << ": delaying pull response for " << _delay_millisecs << " millisecs" << std::endl;
       unsigned long t_secs, t_nanosecs;
       TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
       _finish.timedwait(t_secs, t_nanosecs);
@@ -3242,7 +3242,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "PullSupplier", "PullSupplier_i::disconnect_pull_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -3272,11 +3272,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3361,16 +3361,16 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   // register the types to be supplied
   offer_ticker(_my_proxy, _obj_name, _verbose);
   // if _millisecs is set, spawn a thread to ping the proxy
@@ -3384,11 +3384,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPullSupplier", "StructuredPullSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -3416,7 +3416,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPullSupplier", "StructuredPullSupplier_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
       unsigned long t_secs = 0, t_nanosecs = 0;
@@ -3438,7 +3438,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -3457,7 +3457,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "StructuredPullSupplier", "StructuredPullSupplier_i::try_pull_structured_event");
   if (_done) return data;
-  if (_verbose) cout << _obj_name << ": Channel called try_pull_structured_event" << endl;
+  if (_verbose) std::cout << _obj_name << ": Channel called try_pull_structured_event" << std::endl;
 
   // If we reached done point during last try_pull, it is broadcast now
   // and we return from this try_pull call without an event.
@@ -3465,10 +3465,10 @@
   // processed the previous try_pull (the final supplied event) before
   // we disconnect this supplier.
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << std::endl;
     _done = 1;
     _finish.broadcast();
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
     return data;
   }
 
@@ -3476,12 +3476,12 @@
     has_event = 1;
     _num_events++;
   } else {
-    if (_verbose) cout << _obj_name << ": NOT returning an event" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning an event" << std::endl;
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying try_pull_structured_event response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying try_pull_structured_event response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3503,7 +3503,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "StructuredPullSupplier", "StructuredPullSupplier_i::pull_structured_event");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Channel called pull_structured_event" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Channel called pull_structured_event" << std::endl;
     // invariants: _oplock is held entering top of loop and 
     // also whenever we break out of loop
     // (it is *not* held during yield() and timedwait() calls)
@@ -3515,7 +3515,7 @@
       if ((*_supply_fn)(*data, _obj_name, _num_events+1, _verbose)) {
 	_num_events++;
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  _done = 1;
 	  _finish.broadcast();
 	}
@@ -3536,7 +3536,7 @@
     if (!_done && _delay_millisecs) {
       unsigned long d_secs     =  _delay_millisecs / 1000;
       unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-      if (_verbose) cout << _obj_name << ": delaying pull_structured_event response for " << _delay_millisecs << " millisecs" << endl;
+      if (_verbose) std::cout << _obj_name << ": delaying pull_structured_event response for " << _delay_millisecs << " millisecs" << std::endl;
       unsigned long t_secs, t_nanosecs;
       TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
       _finish.timedwait(t_secs, t_nanosecs);
@@ -3551,7 +3551,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "StructuredPullSupplier", "StructuredPullSupplier_i::disconnect_structured_pull_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -3581,11 +3581,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3675,16 +3675,16 @@
       _my_proxy->obtain_subscription_types(CosNA::NONE_NOW_UPDATES_OFF);
     }
   } catch (CORBA::BAD_PARAM& ex) {
-    cerr << _obj_name << ": BAD_PARAM Exception while connecting" << endl;
+    std::cerr << _obj_name << ": BAD_PARAM Exception while connecting" << std::endl;
     return 1; // error
   } catch (CosEvCA::AlreadyConnected& ex) {
-    cerr << _obj_name << ": Already connected" << endl;
+    std::cerr << _obj_name << ": Already connected" << std::endl;
     return 1; // error
   } catch (...) {
-    cerr << _obj_name << ": Failed to connect" << endl;
+    std::cerr << _obj_name << ": Failed to connect" << std::endl;
     return 1; // error
   }
-  if (_verbose) cout << _obj_name << ": Connected to proxy, ready to supply events" << endl; 
+  if (_verbose) std::cout << _obj_name << ": Connected to proxy, ready to supply events" << std::endl; 
   // register the types to be supplied
   offer_ticker(_my_proxy, _obj_name, _verbose);
   // if _millisecs is set, spawn a thread to ping the proxy
@@ -3698,11 +3698,11 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePullSupplier", "SequencePullSupplier_i::cleanup");
     if (_worker || (!_done)) {
-      cerr << "Coding error: only call c->cleanup() after c->wait_done()" << endl;
+      std::cerr << "Coding error: only call c->cleanup() after c->wait_done()" << std::endl;
       return;
     }
     if (CORBA::is_nil(_my_proxy)) {
-      cerr << "Coding error: cleanup already called?" << endl;
+      std::cerr << "Coding error: cleanup already called?" << std::endl;
       return;
     }
     // this method takes sole ownership of _my_proxy ref
@@ -3729,7 +3729,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePullSupplier", "SequencePullSupplier_i::start_working");
 
-    if (_verbose && (!_done) && _millisecs) cout << _obj_name << ": Spawned thread entering ping loop" << endl;
+    if (_verbose && (!_done) && _millisecs) std::cout << _obj_name << ": Spawned thread entering ping loop" << std::endl;
     while ( 1 ) {
       if (_done || (_millisecs == 0)) break;
       unsigned long t_secs = 0, t_nanosecs = 0;
@@ -3751,7 +3751,7 @@
       continue; // continue ping loop
     com_fail:
       if (_done) break;
-      if (_verbose) cout << _obj_name << ": communication error while pinging proxy using MyType()" << endl;
+      if (_verbose) std::cout << _obj_name << ": communication error while pinging proxy using MyType()" << std::endl;
       _done = 1;
       _finish.broadcast();
       _com_err = 1;
@@ -3772,7 +3772,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "SequencePullSupplier", "SequencePullSupplier_i::try_pull_structured_events");
   if (_done) return data;
-  if (_verbose) cout << _obj_name << ": Channel called try_pull_structured_events" << endl;
+  if (_verbose) std::cout << _obj_name << ": Channel called try_pull_structured_events" << std::endl;
 
   // If we reached done point during last try_pull, it is broadcast now
   // and we return from this try_pull call without an event batch.
@@ -3780,10 +3780,10 @@
   // processed the previous try_pull (the final supplied event batch) before
   // we disconnect this supplier.
   if (_max_events && (_num_events >= _max_events)) {
-    if (_verbose) cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << endl;
+    if (_verbose) std::cout << _obj_name << ": DONE [max_events reached; we waited for 1 extra try_pull]" << std::endl;
     _done = 1;
     _finish.broadcast();
-    if (_verbose) cout << _obj_name << ": NOT returning a batch" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning a batch" << std::endl;
     return data;
   }
 
@@ -3792,12 +3792,12 @@
     _num_batches++;
     _num_events += data->length();
   } else {
-    if (_verbose) cout << _obj_name << ": NOT returning a batch" << endl;
+    if (_verbose) std::cout << _obj_name << ": NOT returning a batch" << std::endl;
   }
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying try_pull_structured_events response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying try_pull_structured_events response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
@@ -3820,7 +3820,7 @@
   { // introduce lock scope
     TW_SCOPE_LOCK(lock, _oplock, "SequencePullSupplier", "SequencePullSupplier_i::pull_structured_events");
 
-    if (_verbose && (!_done)) cout << _obj_name << ": Channel called pull_structured_events" << endl;
+    if (_verbose && (!_done)) std::cout << _obj_name << ": Channel called pull_structured_events" << std::endl;
     // invariants: _oplock is held entering top of loop and 
     // also whenever we break out of loop
     // (it is *not* held during yield() and timedwait() calls)
@@ -3834,7 +3834,7 @@
 	_num_batches++;
 	_num_events += data->length();
 	if (_max_events && (_num_events >= _max_events)) {
-	  if (_verbose) cout << _obj_name << ": DONE [max_events reached]" << endl;
+	  if (_verbose) std::cout << _obj_name << ": DONE [max_events reached]" << std::endl;
 	  _done = 1;
 	  _finish.broadcast();
 	}
@@ -3855,7 +3855,7 @@
     if (!_done && _delay_millisecs) {
       unsigned long d_secs     =  _delay_millisecs / 1000;
       unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-      if (_verbose) cout << _obj_name << ": delaying pull_structured_events response for " << _delay_millisecs << " millisecs" << endl;
+      if (_verbose) std::cout << _obj_name << ": delaying pull_structured_events response for " << _delay_millisecs << " millisecs" << std::endl;
       unsigned long t_secs, t_nanosecs;
       TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
       _finish.timedwait(t_secs, t_nanosecs);
@@ -3870,7 +3870,7 @@
 
   TW_SCOPE_LOCK(lock, _oplock, "SequencePullSupplier", "SequencePullSupplier_i::disconnect_sequence_pull_supplier");
   if (_done) return;
-  if (_verbose) cout << _obj_name << ": disconnected" << endl;
+  if (_verbose) std::cout << _obj_name << ": disconnected" << std::endl;
   _done = 1;
   _finish.broadcast();
 }
@@ -3900,11 +3900,11 @@
   if (_done) return;
   _num_changes++;
   if (_change_fn) (*_change_fn)(added, deled, _obj_name, _num_changes, _verbose);
-  else if (_verbose) cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << endl;
+  else if (_verbose) std::cout << _obj_name << ": subscription_change received [# " << _num_changes << "]" << std::endl;
   if (!_done && _delay_millisecs) {
     unsigned long d_secs     =  _delay_millisecs / 1000;
     unsigned long d_nanosecs = (_delay_millisecs % 1000) * 1000000;
-    if (_verbose) cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << endl;
+    if (_verbose) std::cout << _obj_name << ": delaying subscription_change response for " << _delay_millisecs << " millisecs" << std::endl;
     unsigned long t_secs, t_nanosecs;
     TW_GET_TIME(&t_secs, &t_nanosecs, d_secs, d_nanosecs);
     _finish.timedwait(t_secs, t_nanosecs);
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/sample_functions.cc omniNotify-2.1.new/examples/sample_functions.cc
--- omniNotify-2.1.orig/examples/sample_functions.cc	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/sample_functions.cc	2009-06-28 17:12:44.000000000 +0400
@@ -2,8 +2,8 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <iostream.h>
-#include <iomanip.h>
+#include <iostream>
+#include <iomanip>
 #include "sample_functions.h"
 
 ///////////////////////////////////////////////////////////////////
@@ -20,7 +20,7 @@
 		      )
 {
   event <<= event_num;
-  if (verbose) cout << "Supplied event # " << event_num << endl;
+  if (verbose) std::cout << "Supplied event # " << event_num << std::endl;
   return 1; // OK
 }
 
@@ -33,9 +33,9 @@
 {
   CORBA::ULong ul;
   if (event >>= ul) {
-    if (verbose) cout << obj_name << ": event data = " << ul << ", event count = " << event_num << endl;
+    if (verbose) std::cout << obj_name << ": event data = " << ul << ", event count = " << event_num << std::endl;
   } else {
-    if (verbose) cout << obj_name << ": event data not known (not a ULong), event count = " << event_num << endl;
+    if (verbose) std::cout << obj_name << ": event data not known (not a ULong), event count = " << event_num << std::endl;
   }
 }
 
@@ -59,9 +59,9 @@
 			      )
 {
   if (verbose) {
-    cout << setw(10) << obj_name << " : " <<
-      setw(4) << event_num << " : " <<
-      setw(5) << event.header.fixed_header.event_type.domain_name << "::" <<
+    std::cout << std::setw(10) << obj_name << " : " <<
+      std::setw(4) << event_num << " : " <<
+      std::setw(5) << event.header.fixed_header.event_type.domain_name << "::" <<
       event.header.fixed_header.event_type.type_name << " -- ";
     const char* stock_or_bond_name = "";
     CORBA::ULong value = 0;
@@ -71,15 +71,15 @@
 	(event.filterable_data.length() > 1) &&
 	(event.filterable_data[0].value >>= stock_or_bond_name) &&
 	(event.filterable_data[1].value >>= value)) {
-      cout << "Name: " << stock_or_bond_name << " Value: " << setw(4) << value << " Quote# "; 
+      std::cout << "Name: " << stock_or_bond_name << " Value: " << std::setw(4) << value << " Quote# "; 
       CORBA::ULong l = 0;
       if (event.remainder_of_body >>= l) {
-	cout << setw(4) << l << endl;
+	std::cout << std::setw(4) << l << std::endl;
       } else {
-	cout << "????" << endl;
+	std::cout << "????" << std::endl;
       }
     } else {
-      cout << "(not a Stock or Bond quote -- ignoring)" << endl;
+      std::cout << "(not a Stock or Bond quote -- ignoring)" << std::endl;
     }
   }
 }
@@ -121,7 +121,7 @@
   event.filterable_data[1].name = (const char*) "Value";
   event.filterable_data[1].value <<= (CORBA::ULong) sample_stockbond_val[i];
   event.remainder_of_body <<= (CORBA::ULong) event_num;
-  if (verbose) cout << "Supplied event # " << event_num << endl;
+  if (verbose) std::cout << "Supplied event # " << event_num << std::endl;
   return 1;
 }
 
@@ -141,8 +141,8 @@
 {
   CORBA::ULong evnum = event_num;
   // We re-use the singleton example function
-  if (verbose) cout << "--------- " << obj_name << " Supplying Event Batch " <<
-		 batch_num << " -------------" << endl;
+  if (verbose) std::cout << "--------- " << obj_name << " Supplying Event Batch " <<
+		 batch_num << " -------------" << std::endl;
   events.length(batch_size);
   for (unsigned int i = 0; i < batch_size; i++) {
     sample_supply_structured_fn(events[i], obj_name, evnum++, verbose);
@@ -160,8 +160,8 @@
 {
   // We re-use the singleton example function
   CORBA::ULong evnum = (event_num - events.length()) + 1;
-  if (verbose) cout << "--------- " << obj_name << " Got Event Batch " <<
-		 batch_num << " -------------" << endl;
+  if (verbose) std::cout << "--------- " << obj_name << " Got Event Batch " <<
+		 batch_num << " -------------" << std::endl;
   for (unsigned int i = 0; i < events.length(); i++) {
     sample_consume_structured_fn(events[i], "", evnum++, verbose);
   }
@@ -177,15 +177,15 @@
 			  )
 {
   if (verbose) {
-    cout << setw(10) << obj_name << " : " <<
-      setw(4) << event_num << " : " <<
-      setw(5) << event.header.fixed_header.event_type.domain_name << "::" <<
+    std::cout << std::setw(10) << obj_name << " : " <<
+      std::setw(4) << event_num << " : " <<
+      std::setw(5) << event.header.fixed_header.event_type.domain_name << "::" <<
       event.header.fixed_header.event_type.type_name << " -- ";
     CORBA::ULong l = 0;
     if (event.remainder_of_body >>= l) {
-      cout << setw(4) << l << endl;
+      std::cout << std::setw(4) << l << std::endl;
     } else {
-      cout << "????" << endl;
+      std::cout << "????" << std::endl;
     }
   }
 }
@@ -209,13 +209,13 @@
   event.filterable_data[0].name = (const char*) "TypeNum";
   event.filterable_data[0].value <<= (CORBA::ULong) i;
   event.remainder_of_body <<= (CORBA::ULong) event_num;
-  if (verbose) cout << "Supplied event # " << event_num << endl;
+  if (verbose) std::cout << "Supplied event # " << event_num << std::endl;
   return 1;
 }
 
 // Helper functions
 
-ostream& operator<< (ostream& out, const CosN::EventType & t) {
+std::ostream& operator<< (std::ostream& out, const CosN::EventType & t) {
   const char* dname = (t.domain_name ? (const char*)t.domain_name : "*");
   const char* tname = (t.type_name ? (const char*)t.type_name : "*");
   return out << dname << "::" << tname;
@@ -228,10 +228,10 @@
   CORBA::ULong indx;
   CosN::EventType type;
   for (indx = 0; indx < added.length(); indx++) {
-    cout << "\t+ " << added[indx] << endl;
+    std::cout << "\t+ " << added[indx] << std::endl;
   }
   for (indx = 0; indx < deled.length(); indx++) {
-    cout << "\t- " << deled[indx] << endl;
+    std::cout << "\t- " << deled[indx] << std::endl;
   }
 }
 
@@ -247,8 +247,8 @@
 		       )
 {
   if (verbose) {
-    cout << "Object " << obj_name <<
-      " received offer_change msg [# " << num_changes << "]:" << endl;
+    std::cout << "Object " << obj_name <<
+      " received offer_change msg [# " << num_changes << "]:" << std::endl;
     sample_describe_change_fn(added, deled);
   }
 }
@@ -262,8 +262,8 @@
 		       )
 {
   if (verbose) {
-    cout << "Object " << obj_name << 
-      " received subscription_change msg [# " << num_changes << "]:" << endl;
+    std::cout << "Object " << obj_name << 
+      " received subscription_change msg [# " << num_changes << "]:" << std::endl;
     sample_describe_change_fn(added, deled);
   }
 }
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/some_notify_clients.cc omniNotify-2.1.new/examples/some_notify_clients.cc
--- omniNotify-2.1.orig/examples/some_notify_clients.cc	2003-10-12 22:51:18.000000000 +0400
+++ omniNotify-2.1.new/examples/some_notify_clients.cc	2009-06-28 17:18:19.000000000 +0400
@@ -4,7 +4,7 @@
 #endif
 
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 
 #include "orb_init_name.h"
 #include "get_channel.h"
@@ -23,58 +23,58 @@
 
 static void usage(const char* pname)
 {
-  cout << "Usage: " << pname << " -u client_type [-u client_type ...] [-c #] [-s #] [-b #] [-m #] [-M #] [-n name] [-f file] [-v] [-t types] [-e expr]" << endl;
-  cout << "  -u type  : use the specified client type (one client of that type is used)." << endl;
-  cout << "             Specify as many as you like, one -u option for each.  Types:" << endl;
-  cout << "                lpushc : legacy push consumer" << endl;   
-  cout << "                apushc : any push consumer" << endl; 
-  cout << "                spushc : structured push consumer" << endl; 
-  cout << "                bpushc : batch push consumer" << endl; 
-  cout << endl;
-  cout << "                lpullc : legacy pull consumer" << endl;   
-  cout << "                apullc : any pull consumer" << endl; 
-  cout << "                spullc : structured pull consumer" << endl; 
-  cout << "                bpullc : batch pull consumer" << endl; 
-  cout << endl;
-  cout << "                lpushs : legacy push supplier" << endl;   
-  cout << "                apushs : any push supplier" << endl; 
-  cout << "                spushs : structured push supplier" << endl; 
-  cout << "                bpushs : batch push supplier" << endl; 
-  cout << endl;
-  cout << "                lpulls : legacy pull supplier" << endl;   
-  cout << "                apulls : any pull supplier" << endl; 
-  cout << "                spulls : structured pull supplier" << endl; 
-  cout << "                bpulls : batch pull supplier" << endl; 
-  cout << endl;
-  cout << "  -s #     : for suppliers: disconnect after # events supplied [default 0 means never disconnect]" << endl;
-  cout << "  -c #     : for consumers: disconnect after # events consumed [default 0 means never disconnect]" << endl;
-  cout << "             **  N.B. You should take # of suppliers into account:" << endl;
-  cout << "                 if 3 suppliers supply 30 events, each consumer should consume 90 events" << endl; 
-  cout << "  -b #     : batch size (only relevant for batch supplier programs) [default 5]" << endl;
-  cout << "               => must be >= 1" << endl;
-  cout << "  -m #     : # of milliseconds to pause between each push/pull [default 0]" << endl;
-  cout << "  -M #     : # of milliseconds to pause during incoming push, pull, try_pull [default 0]" << endl;
-  cout << "             (-M only applies to push consumers and pull suppliers)" << endl;
-  cout << "  -n name  : channel name" << endl;
-  cout << "               => use event service to lookup this name" << endl;
-  cout << "  -f file  : file containing channel IOR" << endl;
-  cout << "               => use string_to_object on the IOR" << endl;
-  cout << "  -v       : verbose output" << endl;
-  cout << endl;
-  cout << "Options for adding a filter **:" << endl;
-  cout << "  -t types : add a filter for the specified types, which should be a" << endl;
-  cout << "               comma-separated list of types of the form D::T" << endl;
-  cout << "  -e expr  : add a filter with the specified boolean expression" << endl;
-  cout << "** N.B. Only add filters that always evaluate to TRUE to get proper program termination" << endl;
-  cout << endl;
-  cout << "If only -t specified, the expression \"true\" is used for the filter" << endl;
-  cout << "If only -e specified, the event type \"*::*\" is used for the filter" << endl;
-  cout << endl;
-  cout << "If both -n and -f are specified, the -n option is tried first" << endl;
-  cout << endl;
-  cout << "If neither -n or -f is specified, program first tries name service" << endl;
-  cout << "using name \"EventChannel\", then default IOR file /tmp/rdichan.ior" << endl;
-  cout << endl;
+  std::cout << "Usage: " << pname << " -u client_type [-u client_type ...] [-c #] [-s #] [-b #] [-m #] [-M #] [-n name] [-f file] [-v] [-t types] [-e expr]" << std::endl;
+  std::cout << "  -u type  : use the specified client type (one client of that type is used)." << std::endl;
+  std::cout << "             Specify as many as you like, one -u option for each.  Types:" << std::endl;
+  std::cout << "                lpushc : legacy push consumer" << std::endl;   
+  std::cout << "                apushc : any push consumer" << std::endl; 
+  std::cout << "                spushc : structured push consumer" << std::endl; 
+  std::cout << "                bpushc : batch push consumer" << std::endl; 
+  std::cout << std::endl;
+  std::cout << "                lpullc : legacy pull consumer" << std::endl;   
+  std::cout << "                apullc : any pull consumer" << std::endl; 
+  std::cout << "                spullc : structured pull consumer" << std::endl; 
+  std::cout << "                bpullc : batch pull consumer" << std::endl; 
+  std::cout << std::endl;
+  std::cout << "                lpushs : legacy push supplier" << std::endl;   
+  std::cout << "                apushs : any push supplier" << std::endl; 
+  std::cout << "                spushs : structured push supplier" << std::endl; 
+  std::cout << "                bpushs : batch push supplier" << std::endl; 
+  std::cout << std::endl;
+  std::cout << "                lpulls : legacy pull supplier" << std::endl;   
+  std::cout << "                apulls : any pull supplier" << std::endl; 
+  std::cout << "                spulls : structured pull supplier" << std::endl; 
+  std::cout << "                bpulls : batch pull supplier" << std::endl; 
+  std::cout << std::endl;
+  std::cout << "  -s #     : for suppliers: disconnect after # events supplied [default 0 means never disconnect]" << std::endl;
+  std::cout << "  -c #     : for consumers: disconnect after # events consumed [default 0 means never disconnect]" << std::endl;
+  std::cout << "             **  N.B. You should take # of suppliers into account:" << std::endl;
+  std::cout << "                 if 3 suppliers supply 30 events, each consumer should consume 90 events" << std::endl; 
+  std::cout << "  -b #     : batch size (only relevant for batch supplier programs) [default 5]" << std::endl;
+  std::cout << "               => must be >= 1" << std::endl;
+  std::cout << "  -m #     : # of milliseconds to pause between each push/pull [default 0]" << std::endl;
+  std::cout << "  -M #     : # of milliseconds to pause during incoming push, pull, try_pull [default 0]" << std::endl;
+  std::cout << "             (-M only applies to push consumers and pull suppliers)" << std::endl;
+  std::cout << "  -n name  : channel name" << std::endl;
+  std::cout << "               => use event service to lookup this name" << std::endl;
+  std::cout << "  -f file  : file containing channel IOR" << std::endl;
+  std::cout << "               => use string_to_object on the IOR" << std::endl;
+  std::cout << "  -v       : verbose output" << std::endl;
+  std::cout << std::endl;
+  std::cout << "Options for adding a filter **:" << std::endl;
+  std::cout << "  -t types : add a filter for the specified types, which should be a" << std::endl;
+  std::cout << "               comma-separated list of types of the form D::T" << std::endl;
+  std::cout << "  -e expr  : add a filter with the specified boolean expression" << std::endl;
+  std::cout << "** N.B. Only add filters that always evaluate to TRUE to get proper program termination" << std::endl;
+  std::cout << std::endl;
+  std::cout << "If only -t specified, the expression \"true\" is used for the filter" << std::endl;
+  std::cout << "If only -e specified, the event type \"*::*\" is used for the filter" << std::endl;
+  std::cout << std::endl;
+  std::cout << "If both -n and -f are specified, the -n option is tried first" << std::endl;
+  std::cout << std::endl;
+  std::cout << "If neither -n or -f is specified, program first tries name service" << std::endl;
+  std::cout << "using name \"EventChannel\", then default IOR file /tmp/rdichan.ior" << std::endl;
+  std::cout << std::endl;
 }
 
 // return 0 if etype_list is a valid comma-separated event type list
@@ -195,7 +195,7 @@
 	} else if (strcmp(optarg, "bpulls") == 0) {
 	  USE_B_PULL_S = 1; num_sup++;
 	} else {
-	  cout << endl << "Bad client type (" << optarg << ") for -u option" << endl;
+	  std::cout << std::endl << "Bad client type (" << optarg << ") for -u option" << std::endl;
 	  usage(pname);
 	  goto error_return;
 	}
@@ -250,7 +250,7 @@
       ior_file = (char*)"/tmp/rdichan.ior";
     }
     if (strlen(etype_list) && parse_etype_list(etype_list, evs)) {
-      cout << "Event type list for -t option must be comma-separated list of D::T" << endl << endl; 
+      std::cout << "Event type list for -t option must be comma-separated list of D::T" << std::endl << std::endl; 
       usage(pname);
       goto error_return;
     }
@@ -258,19 +258,19 @@
       constraint_expr = (char*)"true";
     }
     if (num_con + num_sup == 0) {
-      cout << endl << "** You must use at least one -u option to specify a client **" << endl;
+      std::cout << std::endl << "** You must use at least one -u option to specify a client **" << std::endl;
       usage(pname);
       goto error_return;
     }
     if (num_con && num_sup && num_con_events && num_sup_events && (num_con_events != (num_sup * num_sup_events))) {
-      cout << endl << "** WARNING: Unless filtering or external clients change the count, your math is wrong" << endl;
-      cout << "    num_con_events != num_sup * num_sup_events" << endl;
-      cout << "    ( " << num_con_events << " != " << num_sup << " * " << num_sup_events << " )" << endl;
-      cout << "Proceeding anyway" << endl;
+      std::cout << std::endl << "** WARNING: Unless filtering or external clients change the count, your math is wrong" << std::endl;
+      std::cout << "    num_con_events != num_sup * num_sup_events" << std::endl;
+      std::cout << "    ( " << num_con_events << " != " << num_sup << " * " << num_sup_events << " )" << std::endl;
+      std::cout << "Proceeding anyway" << std::endl;
     }
 
     // (2) Obtain reference to notification channel
-    if (verbose) cout << "Obtaining reference to notification channel" << endl;
+    if (verbose) std::cout << "Obtaining reference to notification channel" << std::endl;
     CosNA::EventChannel_ptr channel = getchan_from_ns(orb, channel_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getchan_from_iorfile(orb, ior_file, verbose);
@@ -323,12 +323,12 @@
 
     // (3.1) legacy_push_consumer
     if (USE_L_PUSH_C) {
-      cout << "Constructing legacy_push_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing legacy_push_consumer, num_con_events = " << num_con_events << std::endl;
       l_push_c =
 	LegacyPushConsumer_i::create(channel, num_con_events, "legacy_push_consumer",
 				     sample_consume_any_fn, millisecs, delay_millisecs, verbose);
       if (! l_push_c) {
-	cerr << "Constructing legacy_push_consumer failed" << endl;
+	std::cerr << "Constructing legacy_push_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_l_push_c = l_push_c->_this();
@@ -337,12 +337,12 @@
 
       // (3.2) legacy_pull_consumer
     if (USE_L_PULL_C) {
-      cout << "Constructing legacy_pull_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing legacy_pull_consumer, num_con_events = " << num_con_events << std::endl;
       l_pull_c =
 	LegacyPullConsumer_i::create(channel, num_con_events, "legacy_pull_consumer",
 				     sample_consume_any_fn, millisecs, delay_millisecs, verbose);
       if (! l_pull_c) {
-	cerr << "Constructing legacy_pull_consumer failed" << endl;
+	std::cerr << "Constructing legacy_pull_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_l_pull_c = l_pull_c->_this();
@@ -351,13 +351,13 @@
 
     // (3.3) any_push_consumer
     if (USE_A_PUSH_C) {
-      cout << "Constructing any_push_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing any_push_consumer, num_con_events = " << num_con_events << std::endl;
       a_push_c =
 	PushConsumer_i::create(orb, channel, num_con_events, batch_size, "any_push_consumer",
 			       "", "", sample_consume_any_fn, sample_offer_change_fn,
 			       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! a_push_c) {
-	cerr << "Constructing any_push_consumer failed" << endl;
+	std::cerr << "Constructing any_push_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_a_push_c = a_push_c->_this();
@@ -366,13 +366,13 @@
 
     // (3.4) struct_push_consumer
     if (USE_S_PUSH_C) {
-      cout << "Constructing struct_push_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing struct_push_consumer, num_con_events = " << num_con_events << std::endl;
       s_push_c =
 	StructuredPushConsumer_i::create(orb, channel, num_con_events, batch_size, "struct_push_consumer",
 					 "", "", sample_consume_structured_fn, sample_offer_change_fn,
 					 &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! s_push_c) {
-	cerr << "Constructing struct_push_consumer failed" << endl;
+	std::cerr << "Constructing struct_push_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_s_push_c = s_push_c->_this();
@@ -381,13 +381,13 @@
 
     // (3.5) batch_push_consumer
     if (USE_B_PUSH_C) {
-      cout << "Constructing batch_push_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing batch_push_consumer, num_con_events = " << num_con_events << std::endl;
       b_push_c =
 	SequencePushConsumer_i::create(orb, channel, num_con_events, batch_size, "batch_push_consumer",
 				       "", "", sample_consume_batch_fn, sample_offer_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! b_push_c) {
-	cerr << "Constructing batch_push_consumer failed" << endl;
+	std::cerr << "Constructing batch_push_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_b_push_c = b_push_c->_this();
@@ -396,13 +396,13 @@
 
     // (3.6) any_pull_consumer
     if (USE_A_PULL_C) {
-      cout << "Constructing any_pull_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing any_pull_consumer, num_con_events = " << num_con_events << std::endl;
       a_pull_c =
 	PullConsumer_i::create(orb, channel, num_con_events, batch_size, "any_pull_consumer",
 			       "", "", sample_consume_any_fn, sample_offer_change_fn,
 			       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! a_pull_c) {
-	cerr << "Constructing any_pull_consumer failed" << endl;
+	std::cerr << "Constructing any_pull_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_a_pull_c = a_pull_c->_this();
@@ -411,13 +411,13 @@
 
     // (3.7) struct_pull_consumer
     if (USE_S_PULL_C) {
-      cout << "Constructing struct_pull_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing struct_pull_consumer, num_con_events = " << num_con_events << std::endl;
       s_pull_c =
 	StructuredPullConsumer_i::create(orb, channel, num_con_events, batch_size, "struct_pull_consumer",
 					 "", "", sample_consume_structured_fn, sample_offer_change_fn,
 					 &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! s_pull_c) {
-	cerr << "Constructing struct_pull_consumer failed" << endl;
+	std::cerr << "Constructing struct_pull_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_s_pull_c = s_pull_c->_this();
@@ -426,13 +426,13 @@
 
     // (3.8) batch_pull_consumer
     if (USE_B_PULL_C) {
-      cout << "Constructing batch_pull_consumer, num_con_events = " << num_con_events << endl;
+      std::cout << "Constructing batch_pull_consumer, num_con_events = " << num_con_events << std::endl;
       b_pull_c =
 	SequencePullConsumer_i::create(orb, channel, num_con_events, batch_size, "batch_pull_consumer",
 				       "", "", sample_consume_batch_fn, sample_offer_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! b_pull_c) {
-	cerr << "Constructing batch_pull_consumer failed" << endl;
+	std::cerr << "Constructing batch_pull_consumer failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_b_pull_c = b_pull_c->_this();
@@ -441,12 +441,12 @@
 
     // (3.9) legacy_push_supplier
     if (USE_L_PUSH_S) {
-      cout << "Constructing legacy_push_supplier, num_sup_events = " << num_sup_events << endl;
+      std::cout << "Constructing legacy_push_supplier, num_sup_events = " << num_sup_events << std::endl;
       l_push_s =
 	LegacyPushSupplier_i::create(channel, num_sup_events, "legacy_push_supplier",
 				     sample_supply_any_fn, millisecs, delay_millisecs, verbose);
       if (! l_push_s) {
-	cerr << "Constructing legacy_push_supplier failed" << endl;
+	std::cerr << "Constructing legacy_push_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_l_push_s = l_push_s->_this();
@@ -455,12 +455,12 @@
 
     // (3.10) legacy_pull_supplier
     if (USE_L_PULL_S) {
-      cout << "Constructing legacy_pull_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing legacy_pull_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       l_pull_s =
 	LegacyPullSupplier_i::create(channel, num_sup_events, "legacy_pull_supplier",
 				     sample_supply_any_fn, millisecs, delay_millisecs, verbose);
       if (! l_pull_s) {
-	cerr << "Constructing legacy_pull_supplier failed" << endl;
+	std::cerr << "Constructing legacy_pull_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_l_pull_s = l_pull_s->_this();
@@ -469,13 +469,13 @@
 
     // (3.11) any_push_supplier
     if (USE_A_PUSH_S) {
-      cout << "Constructing any_push_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing any_push_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       a_push_s =
 	PushSupplier_i::create(orb, channel, num_sup_events, batch_size, "any_push_supplier",
 			       "", "", sample_supply_any_fn, sample_subscription_change_fn,
 			       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! a_push_s) {
-	cerr << "Constructing any_push_supplier failed" << endl;
+	std::cerr << "Constructing any_push_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_a_push_s = a_push_s->_this();
@@ -484,13 +484,13 @@
 
     // (3.12) struct_push_supplier
     if (USE_S_PUSH_S) {
-      cout << "Constructing struct_push_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing struct_push_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       s_push_s =
 	StructuredPushSupplier_i::create(orb, channel, num_sup_events, batch_size, "struct_push_supplier",
 					 "", "", sample_supply_structured_fn, sample_subscription_change_fn,
 					 &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! s_push_s) {
-	cerr << "Constructing struct_push_supplier failed" << endl;
+	std::cerr << "Constructing struct_push_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_s_push_s = s_push_s->_this();
@@ -499,13 +499,13 @@
 
     // (3.13) batch_push_supplier
     if (USE_B_PUSH_S) {
-      cout << "Constructing batch_push_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing batch_push_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       b_push_s =
 	SequencePushSupplier_i::create(orb, channel, num_sup_events, batch_size, "batch_push_supplier",
 				       "", "", sample_supply_batch_fn, sample_subscription_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! b_push_s) {
-	cerr << "Constructing batch_push_supplier failed" << endl;
+	std::cerr << "Constructing batch_push_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_b_push_s = b_push_s->_this();
@@ -514,13 +514,13 @@
 
     // (3.14) any_pull_supplier
     if (USE_A_PULL_S) {
-      cout << "Constructing any_pull_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing any_pull_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       a_pull_s =
 	PullSupplier_i::create(orb, channel, num_sup_events, batch_size, "any_pull_supplier",
 			       "", "", sample_supply_any_fn, sample_subscription_change_fn,
 			       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! a_pull_s) {
-	cerr << "Constructing any_pull_supplier failed" << endl;
+	std::cerr << "Constructing any_pull_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_a_pull_s = a_pull_s->_this();
@@ -529,13 +529,13 @@
 
     // (3.15) struct_pull_supplier
     if (USE_S_PULL_S) {
-      cout << "Constructing struct_pull_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing struct_pull_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       s_pull_s =
 	StructuredPullSupplier_i::create(orb, channel, num_sup_events, batch_size, "struct_pull_supplier",
 					 "", "", sample_supply_structured_fn, sample_subscription_change_fn,
 					 &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! s_pull_s) {
-	cerr << "Constructing struct_pull_supplier failed" << endl;
+	std::cerr << "Constructing struct_pull_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_s_pull_s = s_pull_s->_this();
@@ -544,13 +544,13 @@
 
     // (3.16) batch_pull_supplier
     if (USE_B_PULL_S) {
-      cout << "Constructing batch_pull_supplier, num_sup_events = " << num_sup_events <<  endl;
+      std::cout << "Constructing batch_pull_supplier, num_sup_events = " << num_sup_events <<  std::endl;
       b_pull_s =
 	SequencePullSupplier_i::create(orb, channel, num_sup_events, batch_size, "batch_pull_supplier",
 				       "", "", sample_supply_batch_fn, sample_subscription_change_fn,
 				       &evs, constraint_expr, millisecs, delay_millisecs, verbose);
       if (! b_pull_s) {
-	cerr << "Constructing batch_pull_supplier failed" << endl;
+	std::cerr << "Constructing batch_pull_supplier failed" << std::endl;
 	goto error_return; // failed to create a client
       }
       my_b_pull_s = b_pull_s->_this();
@@ -558,116 +558,116 @@
     }
 
     // (4) Tell POA we are ready to go
-    if (verbose) cout << "Activating POA manager" << endl;
+    if (verbose) std::cout << "Activating POA manager" << std::endl;
     PortableServer::POAManager_var pman = poa->the_POAManager();
     pman->activate();
 
     // (5) Connect clients to their proxies -- consumers first
-    if (verbose) cout << "Connecting consumer clients to proxies" << endl;
+    if (verbose) std::cout << "Connecting consumer clients to proxies" << std::endl;
 
     if (USE_L_PUSH_C) {
       if (l_push_c->connect()) {
-	cerr << "Connecting legacy_push_consumer failed" << endl;
+	std::cerr << "Connecting legacy_push_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_A_PUSH_C) {
       if (a_push_c->connect()) {
-	cerr << "Connecting any_push_consumer failed" << endl;
+	std::cerr << "Connecting any_push_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_S_PUSH_C) {
       if (s_push_c->connect()) {
-	cerr << "Connecting struct_push_consumer failed" << endl;
+	std::cerr << "Connecting struct_push_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_B_PUSH_C) {
       if (b_push_c->connect()) {
-	cerr << "Connecting batch_push_consumer failed" << endl;
+	std::cerr << "Connecting batch_push_consumer failed" << std::endl;
 	goto error_return;
       }
     }
 
     if (USE_L_PULL_C) {
       if (l_pull_c->connect()) {
-	cerr << "Connecting legacy_pull_consumer failed" << endl;
+	std::cerr << "Connecting legacy_pull_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_A_PULL_C) {
       if (a_pull_c->connect()) {
-	cerr << "Connecting any_pull_consumer failed" << endl;
+	std::cerr << "Connecting any_pull_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_S_PULL_C) {
       if (s_pull_c->connect()) {
-	cerr << "Connecting struct_pull_consumer failed" << endl;
+	std::cerr << "Connecting struct_pull_consumer failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_B_PULL_C) {
       if (b_pull_c->connect()) {
-	cerr << "Connecting batch_pull_consumer failed" << endl;
+	std::cerr << "Connecting batch_pull_consumer failed" << std::endl;
 	goto error_return;
       }
     }
 
-    if (verbose) cout << "Connecting supplier clients to proxies" << endl;
+    if (verbose) std::cout << "Connecting supplier clients to proxies" << std::endl;
 
     if (USE_L_PUSH_S) {
       if (l_push_s->connect()) {
-	cerr << "Connecting legacy_push_supplier failed" << endl;
+	std::cerr << "Connecting legacy_push_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_A_PUSH_S) {
       if (a_push_s->connect()) {
-	cerr << "Connecting any_push_supplier failed" << endl;
+	std::cerr << "Connecting any_push_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_S_PUSH_S) {
       if (s_push_s->connect()) {
-	cerr << "Connecting struct_push_supplier failed" << endl;
+	std::cerr << "Connecting struct_push_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_B_PUSH_S) {
       if (b_push_s->connect()) {
-	cerr << "Connecting batch_push_supplier failed" << endl;
+	std::cerr << "Connecting batch_push_supplier failed" << std::endl;
 	goto error_return;
       }
     }
 
     if (USE_L_PULL_S) {
       if (l_pull_s->connect()) {
-	cerr << "Connecting legacy_pull_supplier failed" << endl;
+	std::cerr << "Connecting legacy_pull_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_A_PULL_S) {
       if (a_pull_s->connect()) {
-	cerr << "Connecting any_pull_supplier failed" << endl;
+	std::cerr << "Connecting any_pull_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_S_PULL_S) {
       if (s_pull_s->connect()) {
-	cerr << "Connecting struct_pull_supplier failed" << endl;
+	std::cerr << "Connecting struct_pull_supplier failed" << std::endl;
 	goto error_return;
       }
     }
     if (USE_B_PULL_S) {
       if (b_pull_s->connect()) {
-	cerr << "Connecting batch_pull_supplier failed" << endl;
+	std::cerr << "Connecting batch_pull_supplier failed" << std::endl;
 	goto error_return;
       }
     }
 
-    if (verbose) cout << "Waiting for all 16 clients to finish" << endl;
+    if (verbose) std::cout << "Waiting for all 16 clients to finish" << std::endl;
 
     CORBA::Boolean l_push_c_err = 0, l_pull_c_err = 0, l_push_s_err = 0, l_pull_s_err = 0;
     CORBA::Boolean a_push_c_err = 0, a_pull_c_err = 0, a_push_s_err = 0, a_pull_s_err = 0;
@@ -745,13 +745,13 @@
       s_pull_s_err ||
       b_pull_s_err;
     if (sup_com_err && (num_sup_events > 0)) {
-      if (verbose) cout << "Supplier communication error -- probably did not supply desired # of events" << endl;
+      if (verbose) std::cout << "Supplier communication error -- probably did not supply desired # of events" << std::endl;
     }
     if (con_com_err && (num_con_events > 0)) {
-      if (verbose) cout << "Consumer communication error -- probably did not consume desired # of events" << endl;
+      if (verbose) std::cout << "Consumer communication error -- probably did not consume desired # of events" << std::endl;
     }
 
-    if (verbose) cout << "Cleaning up" << endl;
+    if (verbose) std::cout << "Cleaning up" << std::endl;
 
     if (USE_L_PUSH_C) {
       if (!l_push_c_err) { l_push_c->cleanup(); }
@@ -808,23 +808,23 @@
     goto normal_return;
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "main caught CORBA::SystemException." << endl;  
+    std::cerr << "main caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "main caught CORBA::Exception." << endl;        
+    std::cerr << "main caught CORBA::Exception." << std::endl;        
   }                                                    
   catch(omniORB::fatalException& fe) {                 
-    cerr << "main caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "main caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
   catch(...) {                                         
     // nameclt comment says it is a bad idea to report an error here 
   }
-  cerr << "main caught an exception." << endl;       
+  std::cerr << "main caught an exception." << std::endl;       
  error_return:
-  cerr << "QUITTING due to error" << endl;
+  std::cerr << "QUITTING due to error" << std::endl;
   // orb->destroy();
   return -1;
  normal_return:
diff -Naur --exclude=CVS omniNotify-2.1.orig/examples/ten_any_pull_consumers.cc omniNotify-2.1.new/examples/ten_any_pull_consumers.cc
--- omniNotify-2.1.orig/examples/ten_any_pull_consumers.cc	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/examples/ten_any_pull_consumers.cc	2009-06-28 17:14:26.000000000 +0400
@@ -32,7 +32,7 @@
     PortableServer::POA_var poa = PortableServer::POA::_narrow(obj);
 
     // (1) Tell POA we are ready to go
-    if (verbose) cout << "Activating POA manager" << endl;
+    if (verbose) std::cout << "Activating POA manager" << std::endl;
     PortableServer::POAManager_var pman = poa->the_POAManager();
     pman->activate();
 
@@ -46,7 +46,7 @@
     num_con_events = num_events;
 
     // (3) Obtain reference to notification channel
-    if (verbose) cout << "Obtaining reference to notification channel" << endl;
+    if (verbose) std::cout << "Obtaining reference to notification channel" << std::endl;
     CosNA::EventChannel_ptr channel = getchan_from_ns(orb, channel_name, verbose);
     if (CORBA::is_nil(channel)) { // name service lookup failed
       channel = getchan_from_iorfile(orb, ior_file, verbose);
@@ -56,14 +56,14 @@
     }
 
     // (4) Create all 12 CosNotify-style clients
-    if (verbose) cout << "Creating 10 any_pull_consumer clients" << endl;
+    if (verbose) std::cout << "Creating 10 any_pull_consumer clients" << std::endl;
 
     PullConsumer_i* a_pull_c[10];
     CosNotifyComm::PullConsumer_var my_a_pull_c[10];
     char buf[100];
     for (i = 0; i < 10; i++) {
       sprintf(buf, "any_pull_consumer%d", i);
-      if (verbose) cout << "Creating " << buf << endl;
+      if (verbose) std::cout << "Creating " << buf << std::endl;
       a_pull_c[i] =
 	PullConsumer_i::create(orb, channel, num_con_events, batch_size, CORBA::string_dup(buf),
 			       "", "", sample_consume_any_fn, sample_offer_change_fn,
@@ -76,14 +76,14 @@
     }
 
     // (5) Connect clients to their proxies -- consumers first
-    if (verbose) cout << "Connecting consumer clients to proxies" << endl;
+    if (verbose) std::cout << "Connecting consumer clients to proxies" << std::endl;
 
     for (i = 0; i < 10; i++) {
-      if (verbose) cout << "Connecting Client # " << i+1 << endl;
+      if (verbose) std::cout << "Connecting Client # " << i+1 << std::endl;
       if (a_pull_c[i]->connect()) { goto error_return; }
     }
 
-    if (verbose) cout << "Waiting for all 10 clients to finish" << endl;
+    if (verbose) std::cout << "Waiting for all 10 clients to finish" << std::endl;
 
     CORBA::Boolean a_com_err[10];
     CORBA::Boolean com_err = 0;
@@ -95,10 +95,10 @@
     }
 
     if (com_err && (num_events > 0)) {
-      if (verbose) cout << "Communication error -- probably did not process desired # of events" << endl;
+      if (verbose) std::cout << "Communication error -- probably did not process desired # of events" << std::endl;
     }
 
-    if (verbose) cout << "Cleaning up" << endl;
+    if (verbose) std::cout << "Cleaning up" << std::endl;
 
     for (i = 0; i < 10; i++) {
       if (!a_com_err[i]) { a_pull_c[i]->cleanup(); }
@@ -107,23 +107,23 @@
     goto normal_return;
   }
   catch(CORBA::SystemException&) {                     
-    cerr << "main caught CORBA::SystemException." << endl;  
+    std::cerr << "main caught CORBA::SystemException." << std::endl;  
   }                                                    
   catch(CORBA::Exception&) {                           
-    cerr << "main caught CORBA::Exception." << endl;        
+    std::cerr << "main caught CORBA::Exception." << std::endl;        
   }                                                    
 #if defined(__OMNIORB3__) || defined(__OMNIORB4__)
   catch(omniORB::fatalException& fe) {                 
-    cerr << "main caught omniORB::fatalException:" << endl; 
-    cerr << "  file: " << fe.file() << endl;           
-    cerr << "  line: " << fe.line() << endl;           
-    cerr << "  mesg: " << fe.errmsg() << endl;         
+    std::cerr << "main caught omniORB::fatalException:" << std::endl; 
+    std::cerr << "  file: " << fe.file() << std::endl;           
+    std::cerr << "  line: " << fe.line() << std::endl;           
+    std::cerr << "  mesg: " << fe.errmsg() << std::endl;         
   }                                                    
 #endif
   catch(...) {                                         
     // nameclt comment says it is a bad idea to report an error here 
   }
-  cerr << "main caught an exception." << endl;       
+  std::cerr << "main caught an exception." << std::endl;       
  error_return:
   // orb->destroy();
   return -1;
diff -Naur --exclude=CVS omniNotify-2.1.orig/include/ModFlexLexer.h omniNotify-2.1.new/include/ModFlexLexer.h
--- omniNotify-2.1.orig/include/ModFlexLexer.h	2003-10-23 08:39:11.000000000 +0400
+++ omniNotify-2.1.new/include/ModFlexLexer.h	2009-06-28 17:03:57.000000000 +0400
@@ -31,10 +31,10 @@
  
 // XXX ModFlexLexer overrides the 2 yylex decls, from
 // XXX        int yylex()
-// XXX        int yylex( istream* new_in, ostream* new_out = 0 )
+// XXX        int yylex( std::istream* new_in, std::ostream* new_out = 0 )
 // XXX to
 // XXX        int yylex(YYSTYPE* lvalp, RDI_PCState* ps)
-// XXX        int yylex(YYSTYPE* lvalp, RDI_PCState* ps, istream* new_in, ostream* new_out = 0 )
+// XXX        int yylex(YYSTYPE* lvalp, RDI_PCState* ps, std::istream* new_in, std::ostream* new_out = 0 )
 // XXX 
 // XXX It therefore requires these 2 lines:
 #include "RDIConstraint.h"
@@ -88,7 +88,8 @@
 // Never included before - need to define base class.
 #define __FLEX_LEXER_H
 
-#include <iostream.h>
+#include <iostream>
+
 
 extern "C++" {
 
@@ -105,16 +106,16 @@
 	virtual void
 		yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
 	virtual struct yy_buffer_state*
-		yy_create_buffer( istream* s, int size ) = 0;
+		yy_create_buffer( std::istream* s, int size ) = 0;
 	virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
-	virtual void yyrestart( istream* s ) = 0;
+	virtual void yyrestart( std::istream* s ) = 0;
 
 	virtual int yylex(YYSTYPE* lvalp, RDI_PCState* ps) = 0;
 	//	virtual int yylex() = 0;
 
 	// Call yylex with new input/output sources.
-	int yylex(YYSTYPE* lvalp, RDI_PCState* ps, istream* new_in, ostream* new_out = 0 )
-	// int yylex( istream* new_in, ostream* new_out = 0 )
+	int yylex(YYSTYPE* lvalp, RDI_PCState* ps, std::istream* new_in, std::ostream* new_out = 0 )
+	// int yylex( std::istream* new_in, std::ostream* new_out = 0 )
 		{
 		switch_streams( new_in, new_out );
 		return yylex(lvalp, ps);
@@ -122,8 +123,8 @@
 
 	// Switch to new input/output streams.  A nil stream pointer
 	// indicates "keep the current one".
-	virtual void switch_streams( istream* new_in = 0,
-					ostream* new_out = 0 ) = 0;
+	virtual void switch_streams( std::istream* new_in = 0,
+					std::ostream* new_out = 0 ) = 0;
 
 	int lineno() const		{ return yylineno; }
 
@@ -150,17 +151,17 @@
 public:
 	// arg_yyin and arg_yyout default to the cin and cout, but we
 	// only make that assignment when initializing in yylex().
-	yyFlexLexer( istream* arg_yyin = 0, ostream* arg_yyout = 0 );
+	yyFlexLexer( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0 );
 
 	virtual ~yyFlexLexer();
 
 	void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
-	struct yy_buffer_state* yy_create_buffer( istream* s, int size );
+	struct yy_buffer_state* yy_create_buffer( std::istream* s, int size );
 	void yy_delete_buffer( struct yy_buffer_state* b );
-	void yyrestart( istream* s );
+	void yyrestart( std::istream* s );
 
 	virtual int yylex(YYSTYPE* lvalp, RDI_PCState* ps);
-	virtual void switch_streams( istream* new_in, ostream* new_out );
+	virtual void switch_streams( std::istream* new_in, std::ostream* new_out );
 
 protected:
 	virtual int LexerInput( char* buf, int max_size );
@@ -171,7 +172,7 @@
 	int yyinput();
 
 	void yy_load_buffer_state();
-	void yy_init_buffer( struct yy_buffer_state* b, istream* s );
+	void yy_init_buffer( struct yy_buffer_state* b, std::istream* s );
 	void yy_flush_buffer( struct yy_buffer_state* b );
 
 	int yy_start_stack_ptr;
@@ -186,8 +187,8 @@
 	yy_state_type yy_try_NUL_trans( yy_state_type current_state );
 	int yy_get_next_buffer();
 
-	istream* yyin;	// input source for default LexerInput
-	ostream* yyout;	// output sink for default LexerOutput
+	std::istream* yyin;	// input source for default LexerInput
+	std::ostream* yyout;	// output sink for default LexerOutput
 
 	struct yy_buffer_state* yy_current_buffer;
 
diff -Naur --exclude=CVS omniNotify-2.1.orig/lib/RDIParser_l.cc omniNotify-2.1.new/lib/RDIParser_l.cc
--- omniNotify-2.1.orig/lib/RDIParser_l.cc	2003-10-23 08:39:12.000000000 +0400
+++ omniNotify-2.1.new/lib/RDIParser_l.cc	2009-06-28 17:06:28.000000000 +0400
@@ -53,7 +53,7 @@
 #ifdef __cplusplus
 
 #include <stdlib.h>
-#include <iostream.h>
+#include <iostream>
 
 /* Use prototypes in function declarations. */
 #define YY_USE_PROTOS
@@ -172,7 +172,7 @@
 
 struct yy_buffer_state
 	{
-	istream* yy_input_file;
+	std::istream* yy_input_file;
 
 	char *yy_ch_buf;		/* input buffer */
 	char *yy_buf_pos;		/* current position in input buffer */
@@ -1764,10 +1764,10 @@
 			yy_start = 1;	/* first start state */
 
 		if ( ! yyin )
-			yyin = &cin;
+			yyin = &std::cin;
 
 		if ( ! yyout )
-			yyout = &cout;
+			yyout = &std::cout;
 
 		if ( ! yy_current_buffer )
 			yy_current_buffer =
@@ -2123,7 +2123,7 @@
 		} /* end of scanning one token */
 	} /* end of yylex */
 
-yyFlexLexer::yyFlexLexer( istream* arg_yyin, ostream* arg_yyout )
+yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout )
 	{
 	yyin = arg_yyin;
 	yyout = arg_yyout;
@@ -2157,7 +2157,7 @@
 	yy_delete_buffer( yy_current_buffer );
 	}
 
-void yyFlexLexer::switch_streams( istream* new_in, ostream* new_out )
+void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )
 	{
 	if ( new_in )
 		{
@@ -2497,7 +2497,7 @@
 	}
 
 
-void yyFlexLexer::yyrestart( istream* input_file )
+void yyFlexLexer::yyrestart( std::istream* input_file )
 	{
 	if ( ! yy_current_buffer )
 		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );
@@ -2541,7 +2541,7 @@
 	}
 
 
-YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( istream* file, int size )
+YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )
 	{
 	YY_BUFFER_STATE b;
 
@@ -2582,7 +2582,7 @@
 
 
 extern "C" int isatty YY_PROTO(( int ));
-void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, istream* file )
+void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream* file )
 
 	{
 	yy_flush_buffer( b );
@@ -2681,7 +2681,7 @@
 
 void yyFlexLexer::LexerError( yyconst char msg[] )
 	{
-	cerr << msg << '\n';
+	std::cerr << msg << '\n';
 	exit( YY_EXIT_FAILURE );
 	}
 
