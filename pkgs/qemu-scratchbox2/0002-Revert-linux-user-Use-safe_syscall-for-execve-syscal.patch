From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Frajo Haider <f_haider@gmx.at>
Date: Wed, 22 Jan 2020 10:48:18 +0200
Subject: [PATCH] Revert "linux-user: Use safe_syscall for execve syscall"

This reverts commit ffdcbe223d23461669869e85786145cce65e1e8c.
---
 linux-user/syscall.c | 13 +------------
 1 file changed, 1 insertion(+), 12 deletions(-)

diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 9ed3e732cd7444cf18a951677663cc5f45acffde..56310dd38dcffba5b846e36af03e6beb5dd006eb 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -643,7 +643,6 @@ safe_syscall4(pid_t, wait4, pid_t, pid, int *, status, int, options, \
 #endif
 safe_syscall5(int, waitid, idtype_t, idtype, id_t, id, siginfo_t *, infop, \
               int, options, struct rusage *, rusage)
-safe_syscall3(int, execve, const char *, filename, char **, argv, char **, envp)
 #if defined(TARGET_NR_select) || defined(TARGET_NR__newselect) || \
     defined(TARGET_NR_pselect6) || defined(TARGET_NR_pselect6_time64)
 safe_syscall6(int, pselect6, int, nfds, fd_set *, readfds, fd_set *, writefds, \
@@ -8813,17 +8812,7 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
 
             if (!(p = lock_user_string(arg1)))
                 goto execve_efault;
-            /* Although execve() is not an interruptible syscall it is
-             * a special case where we must use the safe_syscall wrapper:
-             * if we allow a signal to happen before we make the host
-             * syscall then we will 'lose' it, because at the point of
-             * execve the process leaves QEMU's control. So we use the
-             * safe syscall wrapper to ensure that we either take the
-             * signal as a guest signal, or else it does not happen
-             * before the execve completes and makes it the other
-             * program's problem.
-             */
-            ret = get_errno(safe_execve(p, argp, envp));
+            ret = get_errno(execve(p, argp, envp));
             unlock_user(p, arg1, 0);
 
             goto execve_end;
